{"ast":null,"code":"\"use strict\";\n\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\nvar _toConsumableArray = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classStaticPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classStaticPrivateMethodGet.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;\nvar index_js_1 = require(\"../address/index.js\");\nvar index_js_2 = require(\"../constants/index.js\");\nvar index_js_3 = require(\"../contract/index.js\");\nvar index_js_4 = require(\"../hash/index.js\");\nvar index_js_5 = require(\"../utils/index.js\");\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n  if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n    link = link.substring(12);\n  } else if (link.match(/^ipfs:\\/\\//i)) {\n    link = link.substring(7);\n  } else {\n    (0, index_js_5.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n  }\n  return \"https://gateway.ipfs.io/ipfs/\".concat(link);\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nvar MulticoinProviderPlugin = /*#__PURE__*/function () {\n  /**\n   *  Creates a new **MulticoinProviderPluing** for %%name%%.\n   */\n  function MulticoinProviderPlugin(name) {\n    _classCallCheck(this, MulticoinProviderPlugin);\n    /**\n     *  The name.\n     */\n    _defineProperty(this, \"name\", void 0);\n    (0, index_js_5.defineProperties)(this, {\n      name: name\n    });\n  }\n  _createClass(MulticoinProviderPlugin, [{\n    key: \"connect\",\n    value: function connect(proivder) {\n      return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n  }, {\n    key: \"supportsCoinType\",\n    value: function supportsCoinType(coinType) {\n      return false;\n    }\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */\n  }, {\n    key: \"encodeAddress\",\n    value: function () {\n      var _encodeAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(coinType, address) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              throw new Error(\"unsupported coin\");\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function encodeAddress(_x, _x2) {\n        return _encodeAddress.apply(this, arguments);\n      }\n      return encodeAddress;\n    }()\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */\n  }, {\n    key: \"decodeAddress\",\n    value: function () {\n      var _decodeAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(coinType, data) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new Error(\"unsupported coin\");\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function decodeAddress(_x3, _x4) {\n        return _decodeAddress.apply(this, arguments);\n      }\n      return decodeAddress;\n    }()\n  }]);\n  return MulticoinProviderPlugin;\n}();\nexports.MulticoinProviderPlugin = MulticoinProviderPlugin;\nvar BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nvar BasicMulticoinProviderPlugin = /*#__PURE__*/function (_MulticoinProviderPlu) {\n  _inherits(BasicMulticoinProviderPlugin, _MulticoinProviderPlu);\n  var _super = _createSuper(BasicMulticoinProviderPlugin);\n  /**\n   *  Creates a new **BasicMulticoinProviderPlugin**.\n   */\n  function BasicMulticoinProviderPlugin() {\n    _classCallCheck(this, BasicMulticoinProviderPlugin);\n    return _super.call(this, BasicMulticoinPluginId);\n  }\n  return _createClass(BasicMulticoinProviderPlugin);\n}(MulticoinProviderPlugin);\nexports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;\nvar matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nvar matchers = [new RegExp(\"^(https):/\\/(.*)$\", \"i\"), new RegExp(\"^(data):(.*)$\", \"i\"), matcherIpfs, new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nvar _supports = /*#__PURE__*/new WeakMap();\nvar _resolver = /*#__PURE__*/new WeakMap();\nvar _fetch = /*#__PURE__*/new WeakSet();\nvar EnsResolver = /*#__PURE__*/function () {\n  function EnsResolver(provider, address, name) {\n    _classCallCheck(this, EnsResolver);\n    _classPrivateMethodInitSpec(this, _fetch);\n    /**\n     *  The connected provider.\n     */\n    _defineProperty(this, \"provider\", void 0);\n    /**\n     *  The address of the resolver.\n     */\n    _defineProperty(this, \"address\", void 0);\n    /**\n     *  The name this resolver was resolved against.\n     */\n    _defineProperty(this, \"name\", void 0);\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _classPrivateFieldInitSpec(this, _supports, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _resolver, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_5.defineProperties)(this, {\n      provider: provider,\n      address: address,\n      name: name\n    });\n    _classPrivateFieldSet(this, _supports, null);\n    _classPrivateFieldSet(this, _resolver, new index_js_3.Contract(address, [\"function supportsInterface(bytes4) view returns (bool)\", \"function resolve(bytes, bytes) view returns (bytes)\", \"function addr(bytes32) view returns (address)\", \"function addr(bytes32, uint) view returns (bytes)\", \"function text(bytes32, string) view returns (string)\", \"function contenthash(bytes32) view returns (bytes)\"], provider));\n  }\n  /**\n   *  Resolves to true if the resolver supports wildcard resolution.\n   */\n  _createClass(EnsResolver, [{\n    key: \"supportsWildcard\",\n    value: function () {\n      var _supportsWildcard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (_classPrivateFieldGet(this, _supports) == null) {\n                _classPrivateFieldSet(this, _supports, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.prev = 0;\n                        _context3.next = 3;\n                        return _classPrivateFieldGet(_this, _resolver).supportsInterface(\"0x9061b923\");\n                      case 3:\n                        return _context3.abrupt(\"return\", _context3.sent);\n                      case 6:\n                        _context3.prev = 6;\n                        _context3.t0 = _context3[\"catch\"](0);\n                        if (!(0, index_js_5.isError)(_context3.t0, \"CALL_EXCEPTION\")) {\n                          _context3.next = 10;\n                          break;\n                        }\n                        return _context3.abrupt(\"return\", false);\n                      case 10:\n                        // Let future attempts try again...\n                        _classPrivateFieldSet(_this, _supports, null);\n                        throw _context3.t0;\n                      case 12:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[0, 6]]);\n                }))());\n              }\n              _context4.next = 3;\n              return _classPrivateFieldGet(this, _supports);\n            case 3:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function supportsWildcard() {\n        return _supportsWildcard.apply(this, arguments);\n      }\n      return supportsWildcard;\n    }()\n  }, {\n    key: \"getAddress\",\n    value:\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(coinType) {\n        var result, ethCoinType, _data, coinPlugin, _iterator, _step, plugin, data, address;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (coinType == null) {\n                coinType = 60;\n              }\n              if (!(coinType === 60)) {\n                _context5.next = 16;\n                break;\n              }\n              _context5.prev = 2;\n              _context5.next = 5;\n              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, \"addr(bytes32)\");\n            case 5:\n              result = _context5.sent;\n              if (!(result == null || result === index_js_2.ZeroAddress)) {\n                _context5.next = 8;\n                break;\n              }\n              return _context5.abrupt(\"return\", null);\n            case 8:\n              return _context5.abrupt(\"return\", result);\n            case 11:\n              _context5.prev = 11;\n              _context5.t0 = _context5[\"catch\"](2);\n              if (!(0, index_js_5.isError)(_context5.t0, \"CALL_EXCEPTION\")) {\n                _context5.next = 15;\n                break;\n              }\n              return _context5.abrupt(\"return\", null);\n            case 15:\n              throw _context5.t0;\n            case 16:\n              if (!(coinType >= 0 && coinType < 0x80000000)) {\n                _context5.next = 23;\n                break;\n              }\n              ethCoinType = coinType + 0x80000000;\n              _context5.next = 20;\n              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, \"addr(bytes32,uint)\", [ethCoinType]);\n            case 20:\n              _data = _context5.sent;\n              if (!(0, index_js_5.isHexString)(_data, 20)) {\n                _context5.next = 23;\n                break;\n              }\n              return _context5.abrupt(\"return\", (0, index_js_1.getAddress)(_data));\n            case 23:\n              coinPlugin = null;\n              _iterator = _createForOfIteratorHelper(this.provider.plugins);\n              _context5.prev = 25;\n              _iterator.s();\n            case 27:\n              if ((_step = _iterator.n()).done) {\n                _context5.next = 36;\n                break;\n              }\n              plugin = _step.value;\n              if (plugin instanceof MulticoinProviderPlugin) {\n                _context5.next = 31;\n                break;\n              }\n              return _context5.abrupt(\"continue\", 34);\n            case 31:\n              if (!plugin.supportsCoinType(coinType)) {\n                _context5.next = 34;\n                break;\n              }\n              coinPlugin = plugin;\n              return _context5.abrupt(\"break\", 36);\n            case 34:\n              _context5.next = 27;\n              break;\n            case 36:\n              _context5.next = 41;\n              break;\n            case 38:\n              _context5.prev = 38;\n              _context5.t1 = _context5[\"catch\"](25);\n              _iterator.e(_context5.t1);\n            case 41:\n              _context5.prev = 41;\n              _iterator.f();\n              return _context5.finish(41);\n            case 44:\n              if (!(coinPlugin == null)) {\n                _context5.next = 46;\n                break;\n              }\n              return _context5.abrupt(\"return\", null);\n            case 46:\n              _context5.next = 48;\n              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, \"addr(bytes32,uint)\", [coinType]);\n            case 48:\n              data = _context5.sent;\n              if (!(data == null || data === \"0x\")) {\n                _context5.next = 51;\n                break;\n              }\n              return _context5.abrupt(\"return\", null);\n            case 51:\n              _context5.next = 53;\n              return coinPlugin.decodeAddress(coinType, data);\n            case 53:\n              address = _context5.sent;\n              if (!(address != null)) {\n                _context5.next = 56;\n                break;\n              }\n              return _context5.abrupt(\"return\", address);\n            case 56:\n              (0, index_js_5.assert)(false, \"invalid coin data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getAddress(\".concat(coinType, \")\"),\n                info: {\n                  coinType: coinType,\n                  data: data\n                }\n              });\n            case 57:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[2, 11], [25, 38, 41, 44]]);\n      }));\n      function getAddress(_x5) {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n  }, {\n    key: \"getText\",\n    value: function () {\n      var _getText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key) {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, \"text(bytes32,string)\", [key]);\n            case 2:\n              data = _context6.sent;\n              if (!(data == null || data === \"0x\")) {\n                _context6.next = 5;\n                break;\n              }\n              return _context6.abrupt(\"return\", null);\n            case 5:\n              return _context6.abrupt(\"return\", data);\n            case 6:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getText(_x6) {\n        return _getText.apply(this, arguments);\n      }\n      return getText;\n    }()\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n  }, {\n    key: \"getContentHash\",\n    value: function () {\n      var _getContentHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var data, ipfs, scheme, length, swarm;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, \"contenthash(bytes32)\");\n            case 2:\n              data = _context7.sent;\n              if (!(data == null || data === \"0x\")) {\n                _context7.next = 5;\n                break;\n              }\n              return _context7.abrupt(\"return\", null);\n            case 5:\n              // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n              ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n              if (!ipfs) {\n                _context7.next = 11;\n                break;\n              }\n              scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n              length = parseInt(ipfs[4], 16);\n              if (!(ipfs[5].length === length * 2)) {\n                _context7.next = 11;\n                break;\n              }\n              return _context7.abrupt(\"return\", \"\".concat(scheme, \"://\").concat((0, index_js_5.encodeBase58)(\"0x\" + ipfs[2])));\n            case 11:\n              // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n              swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n              if (!(swarm && swarm[1].length === 64)) {\n                _context7.next = 14;\n                break;\n              }\n              return _context7.abrupt(\"return\", \"bzz://\".concat(swarm[1]));\n            case 14:\n              (0, index_js_5.assert)(false, \"invalid or unsupported content hash data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getContentHash()\",\n                info: {\n                  data: data\n                }\n              });\n            case 15:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getContentHash() {\n        return _getContentHash.apply(this, arguments);\n      }\n      return getContentHash;\n    }()\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n  }, {\n    key: \"getAvatar\",\n    value: function () {\n      var _getAvatar2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var avatar;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return this._getAvatar();\n            case 2:\n              avatar = _context8.sent;\n              return _context8.abrupt(\"return\", avatar.url);\n            case 4:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getAvatar() {\n        return _getAvatar2.apply(this, arguments);\n      }\n      return getAvatar;\n    }()\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n  }, {\n    key: \"_getAvatar\",\n    value: function () {\n      var _getAvatar3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var linkage, avatar, i, match, scheme, url, selector, owner, comps, tokenId, contract, tokenOwner, balance, metadataUrl, metadata, response, bytes, imageUrl, ipfs;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              linkage = [{\n                type: \"name\",\n                value: this.name\n              }];\n              _context9.prev = 1;\n              _context9.next = 4;\n              return this.getText(\"avatar\");\n            case 4:\n              avatar = _context9.sent;\n              if (!(avatar == null)) {\n                _context9.next = 8;\n                break;\n              }\n              linkage.push({\n                type: \"!avatar\",\n                value: \"\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 8:\n              linkage.push({\n                type: \"avatar\",\n                value: avatar\n              });\n              i = 0;\n            case 10:\n              if (!(i < matchers.length)) {\n                _context9.next = 109;\n                break;\n              }\n              match = avatar.match(matchers[i]);\n              if (!(match == null)) {\n                _context9.next = 14;\n                break;\n              }\n              return _context9.abrupt(\"continue\", 106);\n            case 14:\n              scheme = match[1].toLowerCase();\n              _context9.t0 = scheme;\n              _context9.next = _context9.t0 === \"https\" ? 18 : _context9.t0 === \"data\" ? 18 : _context9.t0 === \"ipfs\" ? 20 : _context9.t0 === \"erc721\" ? 24 : _context9.t0 === \"erc1155\" ? 24 : 106;\n              break;\n            case 18:\n              linkage.push({\n                type: \"url\",\n                value: avatar\n              });\n              return _context9.abrupt(\"return\", {\n                linkage: linkage,\n                url: avatar\n              });\n            case 20:\n              url = getIpfsLink(avatar);\n              linkage.push({\n                type: \"ipfs\",\n                value: avatar\n              });\n              linkage.push({\n                type: \"url\",\n                value: url\n              });\n              return _context9.abrupt(\"return\", {\n                linkage: linkage,\n                url: url\n              });\n            case 24:\n              // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n              selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n              linkage.push({\n                type: scheme,\n                value: avatar\n              });\n              // The owner of this name\n              _context9.next = 28;\n              return this.getAddress();\n            case 28:\n              owner = _context9.sent;\n              if (!(owner == null)) {\n                _context9.next = 32;\n                break;\n              }\n              linkage.push({\n                type: \"!owner\",\n                value: \"\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 32:\n              comps = (match[2] || \"\").split(\"/\");\n              if (!(comps.length !== 2)) {\n                _context9.next = 36;\n                break;\n              }\n              linkage.push({\n                type: \"!\".concat(scheme, \"caip\"),\n                value: match[2] || \"\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 36:\n              tokenId = comps[1];\n              contract = new index_js_3.Contract(comps[0], [\n              // ERC-721\n              \"function tokenURI(uint) view returns (string)\", \"function ownerOf(uint) view returns (address)\",\n              // ERC-1155\n              \"function uri(uint) view returns (string)\", \"function balanceOf(address, uint256) view returns (uint)\"], this.provider); // Check that this account owns the token\n              if (!(scheme === \"erc721\")) {\n                _context9.next = 48;\n                break;\n              }\n              _context9.next = 41;\n              return contract.ownerOf(tokenId);\n            case 41:\n              tokenOwner = _context9.sent;\n              if (!(owner !== tokenOwner)) {\n                _context9.next = 45;\n                break;\n              }\n              linkage.push({\n                type: \"!owner\",\n                value: tokenOwner\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 45:\n              linkage.push({\n                type: \"owner\",\n                value: tokenOwner\n              });\n              _context9.next = 56;\n              break;\n            case 48:\n              if (!(scheme === \"erc1155\")) {\n                _context9.next = 56;\n                break;\n              }\n              _context9.next = 51;\n              return contract.balanceOf(owner, tokenId);\n            case 51:\n              balance = _context9.sent;\n              if (balance) {\n                _context9.next = 55;\n                break;\n              }\n              linkage.push({\n                type: \"!balance\",\n                value: \"0\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 55:\n              linkage.push({\n                type: \"balance\",\n                value: balance.toString()\n              });\n            case 56:\n              _context9.next = 58;\n              return contract[selector](tokenId);\n            case 58:\n              metadataUrl = _context9.sent;\n              if (!(metadataUrl == null || metadataUrl === \"0x\")) {\n                _context9.next = 62;\n                break;\n              }\n              linkage.push({\n                type: \"!metadata-url\",\n                value: \"\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 62:\n              linkage.push({\n                type: \"metadata-url-base\",\n                value: metadataUrl\n              });\n              // ERC-1155 allows a generic {id} in the URL\n              if (scheme === \"erc1155\") {\n                metadataUrl = metadataUrl.replace(\"{id}\", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));\n                linkage.push({\n                  type: \"metadata-url-expanded\",\n                  value: metadataUrl\n                });\n              }\n              // Transform IPFS metadata links\n              if (metadataUrl.match(/^ipfs:/i)) {\n                metadataUrl = getIpfsLink(metadataUrl);\n              }\n              linkage.push({\n                type: \"metadata-url\",\n                value: metadataUrl\n              });\n              // Get the token metadata\n              metadata = {};\n              _context9.next = 69;\n              return new index_js_5.FetchRequest(metadataUrl).send();\n            case 69:\n              response = _context9.sent;\n              response.assertOk();\n              _context9.prev = 71;\n              metadata = response.bodyJson;\n              _context9.next = 87;\n              break;\n            case 75:\n              _context9.prev = 75;\n              _context9.t1 = _context9[\"catch\"](71);\n              _context9.prev = 77;\n              linkage.push({\n                type: \"!metadata\",\n                value: response.bodyText\n              });\n              _context9.next = 86;\n              break;\n            case 81:\n              _context9.prev = 81;\n              _context9.t2 = _context9[\"catch\"](77);\n              bytes = response.body;\n              if (bytes) {\n                linkage.push({\n                  type: \"!metadata\",\n                  value: (0, index_js_5.hexlify)(bytes)\n                });\n              }\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 86:\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 87:\n              if (metadata) {\n                _context9.next = 90;\n                break;\n              }\n              linkage.push({\n                type: \"!metadata\",\n                value: \"\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 90:\n              linkage.push({\n                type: \"metadata\",\n                value: JSON.stringify(metadata)\n              });\n              // Pull the image URL out\n              imageUrl = metadata.image;\n              if (!(typeof imageUrl !== \"string\")) {\n                _context9.next = 95;\n                break;\n              }\n              linkage.push({\n                type: \"!imageUrl\",\n                value: \"\"\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 95:\n              if (!imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                _context9.next = 98;\n                break;\n              }\n              _context9.next = 104;\n              break;\n            case 98:\n              // Transform IPFS link to gateway\n              ipfs = imageUrl.match(matcherIpfs);\n              if (!(ipfs == null)) {\n                _context9.next = 102;\n                break;\n              }\n              linkage.push({\n                type: \"!imageUrl-ipfs\",\n                value: imageUrl\n              });\n              return _context9.abrupt(\"return\", {\n                url: null,\n                linkage: linkage\n              });\n            case 102:\n              linkage.push({\n                type: \"imageUrl-ipfs\",\n                value: imageUrl\n              });\n              imageUrl = getIpfsLink(imageUrl);\n            case 104:\n              linkage.push({\n                type: \"url\",\n                value: imageUrl\n              });\n              return _context9.abrupt(\"return\", {\n                linkage: linkage,\n                url: imageUrl\n              });\n            case 106:\n              i++;\n              _context9.next = 10;\n              break;\n            case 109:\n              _context9.next = 113;\n              break;\n            case 111:\n              _context9.prev = 111;\n              _context9.t3 = _context9[\"catch\"](1);\n            case 113:\n              return _context9.abrupt(\"return\", {\n                linkage: linkage,\n                url: null\n              });\n            case 114:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[1, 111], [71, 75], [77, 81]]);\n      }));\n      function _getAvatar() {\n        return _getAvatar3.apply(this, arguments);\n      }\n      return _getAvatar;\n    }()\n  }], [{\n    key: \"getEnsAddress\",\n    value: function () {\n      var _getEnsAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider) {\n        var network, ensPlugin;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return provider.getNetwork();\n            case 2:\n              network = _context10.sent;\n              ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\"); // No ENS...\n              (0, index_js_5.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getEnsAddress\",\n                info: {\n                  network: network\n                }\n              });\n              return _context10.abrupt(\"return\", ensPlugin.address);\n            case 6:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10);\n      }));\n      function getEnsAddress(_x7) {\n        return _getEnsAddress.apply(this, arguments);\n      }\n      return getEnsAddress;\n    }()\n  }, {\n    key: \"fromName\",\n    value:\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    function () {\n      var _fromName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(provider, name) {\n        var currentName, addr, resolver;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              currentName = name;\n            case 1:\n              if (!true) {\n                _context11.next = 22;\n                break;\n              }\n              if (!(currentName === \"\" || currentName === \".\")) {\n                _context11.next = 4;\n                break;\n              }\n              return _context11.abrupt(\"return\", null);\n            case 4:\n              if (!(name !== \"eth\" && currentName === \"eth\")) {\n                _context11.next = 6;\n                break;\n              }\n              return _context11.abrupt(\"return\", null);\n            case 6:\n              _context11.next = 8;\n              return _classStaticPrivateMethodGet(EnsResolver, EnsResolver, _getResolver).call(EnsResolver, provider, currentName);\n            case 8:\n              addr = _context11.sent;\n              if (!(addr != null)) {\n                _context11.next = 19;\n                break;\n              }\n              resolver = new EnsResolver(provider, addr, name); // Legacy resolver found, using EIP-2544 so it isn't safe to use\n              _context11.t0 = currentName !== name;\n              if (!_context11.t0) {\n                _context11.next = 16;\n                break;\n              }\n              _context11.next = 15;\n              return resolver.supportsWildcard();\n            case 15:\n              _context11.t0 = !_context11.sent;\n            case 16:\n              if (!_context11.t0) {\n                _context11.next = 18;\n                break;\n              }\n              return _context11.abrupt(\"return\", null);\n            case 18:\n              return _context11.abrupt(\"return\", resolver);\n            case 19:\n              // Get the parent node\n              currentName = currentName.split(\".\").slice(1).join(\".\");\n              _context11.next = 1;\n              break;\n            case 22:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11);\n      }));\n      function fromName(_x8, _x9) {\n        return _fromName.apply(this, arguments);\n      }\n      return fromName;\n    }()\n  }]);\n  return EnsResolver;\n}();\nfunction _fetch2(_x10, _x11) {\n  return _fetch3.apply(this, arguments);\n}\nfunction _fetch3() {\n  _fetch3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(funcName, params) {\n    var iface, fragment, _classPrivateFieldGet2, result;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) switch (_context12.prev = _context12.next) {\n        case 0:\n          params = (params || []).slice();\n          iface = _classPrivateFieldGet(this, _resolver).interface; // The first parameters is always the nodehash\n          params.unshift((0, index_js_4.namehash)(this.name));\n          fragment = null;\n          _context12.next = 6;\n          return this.supportsWildcard();\n        case 6:\n          if (!_context12.sent) {\n            _context12.next = 11;\n            break;\n          }\n          fragment = iface.getFunction(funcName);\n          (0, index_js_5.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n            info: {\n              funcName: funcName\n            }\n          });\n          params = [(0, index_js_4.dnsEncode)(this.name), iface.encodeFunctionData(fragment, params)];\n          funcName = \"resolve(bytes,bytes)\";\n        case 11:\n          params.push({\n            ccipReadEnable: true\n          });\n          _context12.prev = 12;\n          _context12.next = 15;\n          return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _resolver))[funcName].apply(_classPrivateFieldGet2, _toConsumableArray(params));\n        case 15:\n          result = _context12.sent;\n          if (!fragment) {\n            _context12.next = 18;\n            break;\n          }\n          return _context12.abrupt(\"return\", iface.decodeFunctionResult(fragment, result)[0]);\n        case 18:\n          return _context12.abrupt(\"return\", result);\n        case 21:\n          _context12.prev = 21;\n          _context12.t0 = _context12[\"catch\"](12);\n          if ((0, index_js_5.isError)(_context12.t0, \"CALL_EXCEPTION\")) {\n            _context12.next = 25;\n            break;\n          }\n          throw _context12.t0;\n        case 25:\n          return _context12.abrupt(\"return\", null);\n        case 26:\n        case \"end\":\n          return _context12.stop();\n      }\n    }, _callee12, this, [[12, 21]]);\n  }));\n  return _fetch3.apply(this, arguments);\n}\nfunction _getResolver(_x12, _x13) {\n  return _getResolver3.apply(this, arguments);\n}\nfunction _getResolver3() {\n  _getResolver3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(provider, name) {\n    var ensAddr, contract, addr;\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) switch (_context13.prev = _context13.next) {\n        case 0:\n          _context13.next = 2;\n          return EnsResolver.getEnsAddress(provider);\n        case 2:\n          ensAddr = _context13.sent;\n          _context13.prev = 3;\n          contract = new index_js_3.Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], provider);\n          _context13.next = 7;\n          return contract.resolver((0, index_js_4.namehash)(name), {\n            enableCcipRead: true\n          });\n        case 7:\n          addr = _context13.sent;\n          if (!(addr === index_js_2.ZeroAddress)) {\n            _context13.next = 10;\n            break;\n          }\n          return _context13.abrupt(\"return\", null);\n        case 10:\n          return _context13.abrupt(\"return\", addr);\n        case 13:\n          _context13.prev = 13;\n          _context13.t0 = _context13[\"catch\"](3);\n          throw _context13.t0;\n        case 16:\n          return _context13.abrupt(\"return\", null);\n        case 17:\n        case \"end\":\n          return _context13.stop();\n      }\n    }, _callee13, null, [[3, 13]]);\n  }));\n  return _getResolver3.apply(this, arguments);\n}\nexports.EnsResolver = EnsResolver;","map":{"version":3,"names":["_toConsumableArray","require","default","_createForOfIteratorHelper","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classStaticPrivateMethodGet","_classPrivateMethodGet","_classPrivateFieldGet","_classPrivateFieldSet","_inherits","_createSuper","_regeneratorRuntime","_asyncToGenerator","_classCallCheck","_createClass","_defineProperty","index_js_1","index_js_2","index_js_3","index_js_4","index_js_5","getIpfsLink","link","match","substring","assertArgument","concat","MulticoinProviderPlugin","name","defineProperties","key","value","connect","proivder","supportsCoinType","coinType","_encodeAddress","mark","_callee","address","wrap","_callee$","_context","prev","next","Error","stop","encodeAddress","_x","_x2","apply","arguments","_decodeAddress","_callee2","data","_callee2$","_context2","decodeAddress","_x3","_x4","exports","BasicMulticoinPluginId","BasicMulticoinProviderPlugin","_MulticoinProviderPlu","_super","call","matcherIpfs","RegExp","matchers","_supports","WeakMap","_resolver","_fetch","WeakSet","EnsResolver","provider","writable","Contract","_supportsWildcard","_callee4","_this","_callee4$","_context4","_callee3","_callee3$","_context3","supportsInterface","abrupt","sent","t0","isError","supportsWildcard","_getAddress","_callee5","result","ethCoinType","_data","coinPlugin","_iterator","_step","plugin","_callee5$","_context5","_fetch2","ZeroAddress","isHexString","getAddress","plugins","s","n","done","t1","e","f","finish","assert","operation","info","_x5","_getText","_callee6","_callee6$","_context6","getText","_x6","_getContentHash","_callee7","ipfs","scheme","length","swarm","_callee7$","_context7","parseInt","encodeBase58","getContentHash","_getAvatar2","_callee8","avatar","_callee8$","_context8","_getAvatar","url","getAvatar","_getAvatar3","_callee9","linkage","i","selector","owner","comps","tokenId","contract","tokenOwner","balance","metadataUrl","metadata","response","bytes","imageUrl","_callee9$","_context9","type","push","toLowerCase","split","ownerOf","balanceOf","toString","replace","toBeHex","FetchRequest","send","assertOk","bodyJson","bodyText","t2","body","hexlify","JSON","stringify","image","t3","_getEnsAddress","_callee10","network","ensPlugin","_callee10$","_context10","getNetwork","getPlugin","getEnsAddress","_x7","_fromName","_callee11","currentName","addr","resolver","_callee11$","_context11","_getResolver","slice","join","fromName","_x8","_x9","_x10","_x11","_fetch3","_callee12","funcName","params","iface","fragment","_classPrivateFieldGet2","_callee12$","_context12","interface","unshift","namehash","getFunction","dnsEncode","encodeFunctionData","ccipReadEnable","decodeFunctionResult","_x12","_x13","_getResolver3","_callee13","ensAddr","_callee13$","_context13","enableCcipRead"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/providers/ens-resolver.ts"],"sourcesContent":["/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\n\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { dnsEncode, namehash } from \"../hash/index.js\";\nimport {\n    hexlify, isHexString, toBeHex,\n    defineProperties, encodeBase58,\n    assert, assertArgument, isError,\n    FetchRequest\n} from \"../utils/index.js\";\n\nimport type { FunctionFragment } from \"../abi/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport type { AbstractProvider, AbstractProviderPlugin } from \"./abstract-provider.js\";\nimport type { EnsPlugin } from \"./plugins-network.js\";\nimport type { Provider } from \"./provider.js\";\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        assertArgument(false, \"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\n/**\n *  The type of data found during a steip during avatar resolution.\n */\nexport type AvatarLinkageType = \"name\" | \"avatar\" | \"!avatar\" | \"url\" | \"data\" | \"ipfs\" |\n    \"erc721\" | \"erc1155\" | \"!erc721-caip\" | \"!erc1155-caip\" |\n    \"!owner\" | \"owner\" | \"!balance\" | \"balance\" |\n    \"metadata-url-base\" | \"metadata-url-expanded\" | \"metadata-url\" | \"!metadata-url\" |\n    \"!metadata\" | \"metadata\" |\n    \"!imageUrl\" | \"imageUrl-ipfs\" | \"imageUrl\" | \"!imageUrl-ipfs\";\n\n/**\n *  An individual record for each step during avatar resolution.\n */\nexport interface AvatarLinkage {\n    /**\n     *  The type of linkage.\n     */\n    type: AvatarLinkageType;\n\n    /**\n     *  The linkage value.\n     */\n    value: string;\n};\n\n/**\n *  When resolving an avatar for an ENS name, there are many\n *  steps involved, fetching metadata, validating results, et cetera.\n *\n *  Some applications may wish to analyse this data, or use this data\n *  to diagnose promblems, so an **AvatarResult** provides details of\n *  each completed step during avatar resolution.\n */\nexport interface AvatarResult {\n    /**\n     *  How the [[url]] was arrived at, resolving the many steps required\n     *  for an avatar URL.\n     */\n    linkage: Array<AvatarLinkage>;\n\n    /**\n     *  The avatar URL or null if the avatar was not set, or there was\n     *  an issue during validation (such as the address not owning the\n     *  avatar or a metadata error).\n     */\n    url: null | string;\n};\n\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nexport abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    /**\n     *  The name.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name: string) {\n        defineProperties<MulticoinProviderPlugin>(this, { name });\n    }\n\n    connect(proivder: Provider): MulticoinProviderPlugin {\n        return this;\n    }\n\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n    supportsCoinType(coinType: number): boolean {\n        return false;\n    }\n\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */\n    async encodeAddress(coinType: number, address: string): Promise<string> {\n        throw new Error(\"unsupported coin\");\n    }\n\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */\n    async decodeAddress(coinType: number, data: BytesLike): Promise<string> {\n        throw new Error(\"unsupported coin\");\n    }\n}\n\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nexport class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nexport class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544: null | Promise<boolean>;\n\n    #resolver: Contract;\n\n    constructor(provider: AbstractProvider, address: string, name: string) {\n        defineProperties<EnsResolver>(this, { provider, address, name });\n        this.#supports2544 = null;\n\n        this.#resolver = new Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n\n    }\n\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard(): Promise<boolean> {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if (isError(error, \"CALL_EXCEPTION\")) { return false; }\n\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n\n                    throw error;\n                }\n            })();\n        }\n\n        return await this.#supports2544;\n    }\n\n    async #fetch(funcName: string, params?: Array<any>): Promise<null | any> {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n\n        // The first parameters is always the nodehash\n        params.unshift(namehash(this.name))\n\n        let fragment: null | FunctionFragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            assert(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n\n            params = [\n                dnsEncode(this.name),\n                iface.encodeFunctionData(fragment, params)\n            ];\n\n            funcName = \"resolve(bytes,bytes)\";\n        }\n\n        params.push({\n            ccipReadEnable: true\n        });\n\n        try {\n            const result = await this.#resolver[funcName](...params);\n\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n\n            return result;\n        } catch (error: any) {\n            if (!isError(error, \"CALL_EXCEPTION\")) { throw error; }\n        }\n\n        return null;\n    }\n\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType?: number): Promise<null | string> {\n        if (coinType == null) { coinType = 60; }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n\n                // No address\n                if (result == null || result === ZeroAddress) { return null; }\n\n                return result;\n            } catch (error: any) {\n                if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n                throw error;\n            }\n        }\n\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ ethCoinType ]);\n            if (isHexString(data, 20)) { return getAddress(data); }\n        }\n\n        let coinPlugin: null | MulticoinProviderPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) { continue; }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n\n        if (coinPlugin == null) { return null; }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [ coinType ]);\n\n        // No address\n        if (data == null || data === \"0x\") { return null; }\n\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n\n        if (address != null) { return address; }\n\n        assert(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${ coinType })`,\n            info: { coinType, data }\n        });\n    }\n\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key: string): Promise<null | string> {\n        const data = await this.#fetch(\"text(bytes32,string)\", [ key ]);\n        if (data == null || data === \"0x\") { return null; }\n        return data;\n    }\n\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash(): Promise<null | string> {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n\n        // No contenthash\n        if (data == null || data === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\": \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${ scheme }:/\\/${ encodeBase58(\"0x\" + ipfs[2])}`;\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${ swarm[1] }`;\n        }\n\n        assert(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar(): Promise<null | string> {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar(): Promise<AvatarResult> {\n        const linkage: Array<AvatarLinkage> = [ { type: \"name\", value: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\": \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: <any>`!${ scheme }caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n\n                        const tokenId = comps[1];\n\n                        const contract = new Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", toBeHex(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n\n                        // Get the token metadata\n                        let metadata: any = { };\n                        const response = await (new FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n\n                        try {\n                            metadata = response.bodyJson;\n                        } catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            } catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: hexlify(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", value: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return { linkage, url: null };\n    }\n\n    static async getEnsAddress(provider: Provider): Promise<string> {\n        const network = await provider.getNetwork();\n\n        const ensPlugin = network.getPlugin<EnsPlugin>(\"org.ethers.plugins.network.Ens\");\n\n        // No ENS...\n        assert(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network } });\n\n        return ensPlugin.address;\n    }\n\n    static async #getResolver(provider: Provider, name: string): Promise<null | string> {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n\n        try {\n            const contract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n\n            const addr = await contract.resolver(namehash(name), {\n                enableCcipRead: true\n            });\n\n            if (addr === ZeroAddress) { return null; }\n            return addr;\n\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n\n        return null;\n    }\n\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider: AbstractProvider, name: string): Promise<null | EnsResolver> {\n\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}