{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeOwlA = void 0;\nvar index_js_1 = require(\"../utils/index.js\");\nvar bit_reader_js_1 = require(\"./bit-reader.js\");\nvar decode_owl_js_1 = require(\"./decode-owl.js\");\n/**\n *  @_ignore\n */\nfunction decodeOwlA(data, accents) {\n  var words = (0, decode_owl_js_1.decodeOwl)(data).join(\",\");\n  // Inject the accents\n  accents.split(/,/g).forEach(function (accent) {\n    var match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\n    (0, index_js_1.assertArgument)(match !== null, \"internal error parsing accents\", \"accents\", accents);\n    var posOffset = 0;\n    var positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);\n    var charCode = parseInt(match[2]);\n    var regex = new RegExp(\"([\".concat(match[1], \"])\"), \"g\");\n    words = words.replace(regex, function (all, letter) {\n      var rem = --positions[posOffset];\n      if (rem === 0) {\n        letter = String.fromCharCode(letter.charCodeAt(0), charCode);\n        posOffset++;\n      }\n      return letter;\n    });\n  });\n  return words.split(\",\");\n}\nexports.decodeOwlA = decodeOwlA;","map":{"version":3,"names":["index_js_1","require","bit_reader_js_1","decode_owl_js_1","decodeOwlA","data","accents","words","decodeOwl","join","split","forEach","accent","match","assertArgument","posOffset","positions","decodeBits","parseInt","charCode","regex","RegExp","concat","replace","all","letter","rem","String","fromCharCode","charCodeAt","exports"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/wordlists/decode-owla.ts"],"sourcesContent":["import { assertArgument } from \"../utils/index.js\";\n\nimport { decodeBits } from \"./bit-reader.js\";\nimport { decodeOwl } from \"./decode-owl.js\";\n\n/**\n *  @_ignore\n */\nexport function decodeOwlA(data: string, accents: string): Array<string> {\n    let words = decodeOwl(data).join(\",\");\n\n    // Inject the accents\n    accents.split(/,/g).forEach((accent) => {\n\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\n        assertArgument(match !== null, \"internal error parsing accents\", \"accents\", accents);\n\n        let posOffset = 0;\n        const positions = decodeBits(parseInt(match[3]), match[4]);\n        const charCode = parseInt(match[2]);\n        const regex = new RegExp(`([${ match[1] }])`, \"g\");\n        words = words.replace(regex, (all, letter) => {\n            const rem = --positions[posOffset];\n            if (rem === 0) {\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode);\n                posOffset++;\n            }\n            return letter;\n        });\n    });\n\n    return words.split(\",\");\n}\n"],"mappings":";;;;;;AAAA,IAAAA,UAAA,GAAAC,OAAA;AAEA,IAAAC,eAAA,GAAAD,OAAA;AACA,IAAAE,eAAA,GAAAF,OAAA;AAEA;;;AAGA,SAAgBG,UAAUA,CAACC,IAAY,EAAEC,OAAe;EACpD,IAAIC,KAAK,GAAG,IAAAJ,eAAA,CAAAK,SAAS,EAACH,IAAI,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;EAErC;EACAH,OAAO,CAACI,KAAK,CAAC,IAAI,CAAC,CAACC,OAAO,CAAC,UAACC,MAAM,EAAI;IAEnC,IAAMC,KAAK,GAAGD,MAAM,CAACC,KAAK,CAAC,+BAA+B,CAAC;IAC3D,IAAAb,UAAA,CAAAc,cAAc,EAACD,KAAK,KAAK,IAAI,EAAE,gCAAgC,EAAE,SAAS,EAAEP,OAAO,CAAC;IAEpF,IAAIS,SAAS,GAAG,CAAC;IACjB,IAAMC,SAAS,GAAG,IAAAd,eAAA,CAAAe,UAAU,EAACC,QAAQ,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1D,IAAMM,QAAQ,GAAGD,QAAQ,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC;IACnC,IAAMO,KAAK,GAAG,IAAIC,MAAM,MAAAC,MAAA,CAAOT,KAAK,CAAC,CAAC,CAAE,SAAM,GAAG,CAAC;IAClDN,KAAK,GAAGA,KAAK,CAACgB,OAAO,CAACH,KAAK,EAAE,UAACI,GAAG,EAAEC,MAAM,EAAI;MACzC,IAAMC,GAAG,GAAG,EAAEV,SAAS,CAACD,SAAS,CAAC;MAClC,IAAIW,GAAG,KAAK,CAAC,EAAE;QACXD,MAAM,GAAGE,MAAM,CAACC,YAAY,CAACH,MAAM,CAACI,UAAU,CAAC,CAAC,CAAC,EAAEV,QAAQ,CAAC;QAC5DJ,SAAS,EAAE;;MAEf,OAAOU,MAAM;IACjB,CAAC,CAAC;EACN,CAAC,CAAC;EAEF,OAAOlB,KAAK,CAACG,KAAK,CAAC,GAAG,CAAC;AAC3B;AAxBAoB,OAAA,CAAA1B,UAAA,GAAAA,UAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}