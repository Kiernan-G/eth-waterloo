{"ast":null,"code":"\"use strict\";\n\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nvar _slicedToArray = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;\nvar index_js_1 = require(\"../crypto/index.js\");\nvar index_js_2 = require(\"../hash/index.js\");\nvar index_js_3 = require(\"../utils/index.js\");\nvar abi_coder_js_1 = require(\"./abi-coder.js\");\nvar abstract_coder_js_1 = require(\"./coders/abstract-coder.js\");\nObject.defineProperty(exports, \"checkResultErrors\", {\n  enumerable: true,\n  get: function get() {\n    return abstract_coder_js_1.checkResultErrors;\n  }\n});\nObject.defineProperty(exports, \"Result\", {\n  enumerable: true,\n  get: function get() {\n    return abstract_coder_js_1.Result;\n  }\n});\nvar fragments_js_1 = require(\"./fragments.js\");\nvar typed_js_1 = require(\"./typed.js\");\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nvar LogDescription = /*#__PURE__*/_createClass(\n/**\n *  @_ignore:\n */\nfunction LogDescription(fragment, topic, args) {\n  _classCallCheck(this, LogDescription);\n  /**\n   *  The matching fragment for the ``topic0``.\n   */\n  _defineProperty(this, \"fragment\", void 0);\n  /**\n   *  The name of the Event.\n   */\n  _defineProperty(this, \"name\", void 0);\n  /**\n   *  The full Event signature.\n   */\n  _defineProperty(this, \"signature\", void 0);\n  /**\n   *  The topic hash for the Event.\n   */\n  _defineProperty(this, \"topic\", void 0);\n  /**\n   *  The arguments passed into the Event with ``emit``.\n   */\n  _defineProperty(this, \"args\", void 0);\n  var name = fragment.name,\n    signature = fragment.format();\n  (0, index_js_3.defineProperties)(this, {\n    fragment: fragment,\n    name: name,\n    signature: signature,\n    topic: topic,\n    args: args\n  });\n});\nexports.LogDescription = LogDescription;\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nvar TransactionDescription = /*#__PURE__*/_createClass(\n/**\n *  @_ignore:\n */\nfunction TransactionDescription(fragment, selector, args, value) {\n  _classCallCheck(this, TransactionDescription);\n  /**\n   *  The matching fragment from the transaction ``data``.\n   */\n  _defineProperty(this, \"fragment\", void 0);\n  /**\n   *  The name of the Function from the transaction ``data``.\n   */\n  _defineProperty(this, \"name\", void 0);\n  /**\n   *  The arguments passed to the Function from the transaction ``data``.\n   */\n  _defineProperty(this, \"args\", void 0);\n  /**\n   *  The full Function signature from the transaction ``data``.\n   */\n  _defineProperty(this, \"signature\", void 0);\n  /**\n   *  The selector for the Function from the transaction ``data``.\n   */\n  _defineProperty(this, \"selector\", void 0);\n  /**\n   *  The ``value`` (in wei) from the transaction.\n   */\n  _defineProperty(this, \"value\", void 0);\n  var name = fragment.name,\n    signature = fragment.format();\n  (0, index_js_3.defineProperties)(this, {\n    fragment: fragment,\n    name: name,\n    args: args,\n    signature: signature,\n    selector: selector,\n    value: value\n  });\n});\nexports.TransactionDescription = TransactionDescription;\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nvar ErrorDescription = /*#__PURE__*/_createClass(\n/**\n *  @_ignore:\n */\nfunction ErrorDescription(fragment, selector, args) {\n  _classCallCheck(this, ErrorDescription);\n  /**\n   *  The matching fragment.\n   */\n  _defineProperty(this, \"fragment\", void 0);\n  /**\n   *  The name of the Error.\n   */\n  _defineProperty(this, \"name\", void 0);\n  /**\n   *  The arguments passed to the Error with ``revert``.\n   */\n  _defineProperty(this, \"args\", void 0);\n  /**\n   *  The full Error signature.\n   */\n  _defineProperty(this, \"signature\", void 0);\n  /**\n   *  The selector for the Error.\n   */\n  _defineProperty(this, \"selector\", void 0);\n  var name = fragment.name,\n    signature = fragment.format();\n  (0, index_js_3.defineProperties)(this, {\n    fragment: fragment,\n    name: name,\n    args: args,\n    signature: signature,\n    selector: selector\n  });\n});\nexports.ErrorDescription = ErrorDescription;\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nvar Indexed = /*#__PURE__*/function () {\n  /**\n   *  @_ignore:\n   */\n  function Indexed(hash) {\n    _classCallCheck(this, Indexed);\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    _defineProperty(this, \"hash\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"_isIndexed\", void 0);\n    (0, index_js_3.defineProperties)(this, {\n      hash: hash,\n      _isIndexed: true\n    });\n  }\n  _createClass(Indexed, null, [{\n    key: \"isIndexed\",\n    value:\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    function isIndexed(value) {\n      return !!(value && value._isIndexed);\n    }\n  }]);\n  return Indexed;\n}();\nexports.Indexed = Indexed;\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nvar PanicReasons = {\n  \"0\": \"generic panic\",\n  \"1\": \"assert(false)\",\n  \"17\": \"arithmetic overflow\",\n  \"18\": \"division or modulo by zero\",\n  \"33\": \"enum overflow\",\n  \"34\": \"invalid encoded storage byte array accessed\",\n  \"49\": \"out-of-bounds array access; popping on an empty array\",\n  \"50\": \"out-of-bounds access of an array or bytesN\",\n  \"65\": \"out of memory\",\n  \"81\": \"uninitialized function\"\n};\nvar BuiltinErrors = {\n  \"0x08c379a0\": {\n    signature: \"Error(string)\",\n    name: \"Error\",\n    inputs: [\"string\"],\n    reason: function reason(message) {\n      return \"reverted with reason string \".concat(JSON.stringify(message));\n    }\n  },\n  \"0x4e487b71\": {\n    signature: \"Panic(uint256)\",\n    name: \"Panic\",\n    inputs: [\"uint256\"],\n    reason: function reason(code) {\n      var reason = \"unknown panic code\";\n      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n        reason = PanicReasons[code.toString()];\n      }\n      return \"reverted with panic code 0x\".concat(code.toString(16), \" (\").concat(reason, \")\");\n    }\n  }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nvar _errors = /*#__PURE__*/new WeakMap();\nvar _events = /*#__PURE__*/new WeakMap();\nvar _functions = /*#__PURE__*/new WeakMap();\nvar _abiCoder = /*#__PURE__*/new WeakMap();\nvar _getFunction = /*#__PURE__*/new WeakSet();\nvar _getEvent = /*#__PURE__*/new WeakSet();\nvar Interface = /*#__PURE__*/function () {\n  /**\n   *  Create a new Interface for the %%fragments%%.\n   */\n  function Interface(fragments) {\n    var _this = this;\n    _classCallCheck(this, Interface);\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _getEvent);\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _getFunction);\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    _defineProperty(this, \"fragments\", void 0);\n    /**\n     *  The Contract constructor.\n     */\n    _defineProperty(this, \"deploy\", void 0);\n    /**\n     *  The Fallback method, if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    /**\n     *  If receiving ether is supported.\n     */\n    _defineProperty(this, \"receive\", void 0);\n    _classPrivateFieldInitSpec(this, _errors, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _events, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _functions, {\n      writable: true,\n      value: void 0\n    });\n    //    #structs: Map<string, StructFragment>;\n    _classPrivateFieldInitSpec(this, _abiCoder, {\n      writable: true,\n      value: void 0\n    });\n    var abi = [];\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n    _classPrivateFieldSet(this, _functions, new Map());\n    _classPrivateFieldSet(this, _errors, new Map());\n    _classPrivateFieldSet(this, _events, new Map());\n    //        this.#structs = new Map();\n    var frags = [];\n    var _iterator = _createForOfIteratorHelper(abi),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var a = _step.value;\n        try {\n          frags.push(fragments_js_1.Fragment.from(a));\n        } catch (error) {\n          console.log(\"EE\", error);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    (0, index_js_3.defineProperties)(this, {\n      fragments: Object.freeze(frags)\n    });\n    var fallback = null;\n    var receive = false;\n    _classPrivateFieldSet(this, _abiCoder, this.getAbiCoder());\n    // Add all fragments by their signature\n    this.fragments.forEach(function (fragment, index) {\n      var bucket;\n      switch (fragment.type) {\n        case \"constructor\":\n          if (_this.deploy) {\n            console.log(\"duplicate definition - constructor\");\n            return;\n          }\n          //checkNames(fragment, \"input\", fragment.inputs);\n          (0, index_js_3.defineProperties)(_this, {\n            deploy: fragment\n          });\n          return;\n        case \"fallback\":\n          if (fragment.inputs.length === 0) {\n            receive = true;\n          } else {\n            (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", \"fragments[\".concat(index, \"]\"), fragment);\n            fallback = fragment;\n            receive = fallback.payable;\n          }\n          return;\n        case \"function\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n          bucket = _classPrivateFieldGet(_this, _functions);\n          break;\n        case \"event\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          bucket = _classPrivateFieldGet(_this, _events);\n          break;\n        case \"error\":\n          bucket = _classPrivateFieldGet(_this, _errors);\n          break;\n        default:\n          return;\n      }\n      // Two identical entries; ignore it\n      var signature = fragment.format();\n      if (bucket.has(signature)) {\n        return;\n      }\n      bucket.set(signature, fragment);\n    });\n    // If we do not have a constructor add a default\n    if (!this.deploy) {\n      (0, index_js_3.defineProperties)(this, {\n        deploy: fragments_js_1.ConstructorFragment.from(\"constructor()\")\n      });\n    }\n    (0, index_js_3.defineProperties)(this, {\n      fallback: fallback,\n      receive: receive\n    });\n  }\n  /**\n   *  Returns the entire Human-Readable ABI, as an array of\n   *  signatures, optionally as %%minimal%% strings, which\n   *  removes parameter names and unneceesary spaces.\n   */\n  _createClass(Interface, [{\n    key: \"format\",\n    value: function format(minimal) {\n      var format = minimal ? \"minimal\" : \"full\";\n      var abi = this.fragments.map(function (f) {\n        return f.format(format);\n      });\n      return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n  }, {\n    key: \"formatJson\",\n    value: function formatJson() {\n      var abi = this.fragments.map(function (f) {\n        return f.format(\"json\");\n      });\n      // We need to re-bundle the JSON fragments a bit\n      return JSON.stringify(abi.map(function (j) {\n        return JSON.parse(j);\n      }));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n  }, {\n    key: \"getAbiCoder\",\n    value: function getAbiCoder() {\n      return abi_coder_js_1.AbiCoder.defaultAbiCoder();\n    }\n  }, {\n    key: \"getFunctionName\",\n    value:\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    function getFunctionName(key) {\n      var fragment = _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);\n      (0, index_js_3.assertArgument)(fragment, \"no matching function\", \"key\", key);\n      return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(key) {\n      return !!_classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(key, values) {\n      return _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n  }, {\n    key: \"forEachFunction\",\n    value: function forEachFunction(callback) {\n      var names = Array.from(_classPrivateFieldGet(this, _functions).keys());\n      names.sort(function (a, b) {\n        return a.localeCompare(b);\n      });\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        callback(_classPrivateFieldGet(this, _functions).get(name), i);\n      }\n    }\n  }, {\n    key: \"getEventName\",\n    value:\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    function getEventName(key) {\n      var fragment = _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);\n      (0, index_js_3.assertArgument)(fragment, \"no matching event\", \"key\", key);\n      return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n  }, {\n    key: \"hasEvent\",\n    value: function hasEvent(key) {\n      return !!_classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n  }, {\n    key: \"getEvent\",\n    value: function getEvent(key, values) {\n      return _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n  }, {\n    key: \"forEachEvent\",\n    value: function forEachEvent(callback) {\n      var names = Array.from(_classPrivateFieldGet(this, _events).keys());\n      names.sort(function (a, b) {\n        return a.localeCompare(b);\n      });\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        callback(_classPrivateFieldGet(this, _events).get(name), i);\n      }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n  }, {\n    key: \"getError\",\n    value: function getError(key, values) {\n      if ((0, index_js_3.isHexString)(key)) {\n        var selector = key.toLowerCase();\n        if (BuiltinErrors[selector]) {\n          return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);\n        }\n        var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _errors).values()),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var fragment = _step2.value;\n            if (selector === fragment.selector) {\n              return fragment;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        return null;\n      }\n      // It is a bare name, look up the function (will return null if ambiguous)\n      if (key.indexOf(\"(\") === -1) {\n        var matching = [];\n        var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _errors)),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n              name = _step3$value[0],\n              _fragment = _step3$value[1];\n            if (name.split(\"(\" /* fix:) */)[0] === key) {\n              matching.push(_fragment);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (matching.length === 0) {\n          if (key === \"Error\") {\n            return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n          }\n          if (key === \"Panic\") {\n            return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n          }\n          return null;\n        } else if (matching.length > 1) {\n          var matchStr = matching.map(function (m) {\n            return JSON.stringify(m.format());\n          }).join(\", \");\n          (0, index_js_3.assertArgument)(false, \"ambiguous error description (i.e. \".concat(matchStr, \")\"), \"name\", key);\n        }\n        return matching[0];\n      }\n      // Normalize the signature and lookup the function\n      key = fragments_js_1.ErrorFragment.from(key).format();\n      if (key === \"Error(string)\") {\n        return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n      }\n      if (key === \"Panic(uint256)\") {\n        return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n      }\n      var result = _classPrivateFieldGet(this, _errors).get(key);\n      if (result) {\n        return result;\n      }\n      return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n  }, {\n    key: \"forEachError\",\n    value: function forEachError(callback) {\n      var names = Array.from(_classPrivateFieldGet(this, _errors).keys());\n      names.sort(function (a, b) {\n        return a.localeCompare(b);\n      });\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        callback(_classPrivateFieldGet(this, _errors).get(name), i);\n      }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n         try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n         if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n         fragment = matches[0];\n    }\n     return dataSlice(id(fragment.format()), 0, 4);\n    }\n    */\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n  }, {\n    key: \"_decodeParams\",\n    value: function _decodeParams(params, data) {\n      return _classPrivateFieldGet(this, _abiCoder).decode(params, data);\n    }\n  }, {\n    key: \"_encodeParams\",\n    value: function _encodeParams(params, values) {\n      return _classPrivateFieldGet(this, _abiCoder).encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n  }, {\n    key: \"encodeDeploy\",\n    value: function encodeDeploy(values) {\n      return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n  }, {\n    key: \"decodeErrorResult\",\n    value: function decodeErrorResult(fragment, data) {\n      if (typeof fragment === \"string\") {\n        var f = this.getError(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n        fragment = f;\n      }\n      (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, \"data signature does not match error \".concat(fragment.name, \".\"), \"data\", data);\n      return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n  }, {\n    key: \"encodeErrorResult\",\n    value: function encodeErrorResult(fragment, values) {\n      if (typeof fragment === \"string\") {\n        var f = this.getError(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n        fragment = f;\n      }\n      return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n  }, {\n    key: \"decodeFunctionData\",\n    value: function decodeFunctionData(fragment, data) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, \"data signature does not match function \".concat(fragment.name, \".\"), \"data\", data);\n      return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n  }, {\n    key: \"encodeFunctionData\",\n    value: function encodeFunctionData(fragment, values) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n  }, {\n    key: \"decodeFunctionResult\",\n    value: function decodeFunctionResult(fragment, data) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      var message = \"invalid length for result data\";\n      var bytes = (0, index_js_3.getBytesCopy)(data);\n      if (bytes.length % 32 === 0) {\n        try {\n          return _classPrivateFieldGet(this, _abiCoder).decode(fragment.outputs, bytes);\n        } catch (error) {\n          message = \"could not decode result data\";\n        }\n      }\n      // Call returned data with no error, but the data is junk\n      (0, index_js_3.assert)(false, message, \"BAD_DATA\", {\n        value: (0, index_js_3.hexlify)(bytes),\n        info: {\n          method: fragment.name,\n          signature: fragment.format()\n        }\n      });\n    }\n  }, {\n    key: \"makeError\",\n    value: function makeError(_data, tx) {\n      var data = (0, index_js_3.getBytes)(_data, \"data\");\n      var error = abi_coder_js_1.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n      // Not a built-in error; try finding a custom error\n      var customPrefix = \"execution reverted (unknown custom error)\";\n      if (error.message.startsWith(customPrefix)) {\n        var selector = (0, index_js_3.hexlify)(data.slice(0, 4));\n        var ef = this.getError(selector);\n        if (ef) {\n          try {\n            var args = _classPrivateFieldGet(this, _abiCoder).decode(ef.inputs, data.slice(4));\n            error.revert = {\n              name: ef.name,\n              signature: ef.format(),\n              args: args\n            };\n            error.reason = error.revert.signature;\n            error.message = \"execution reverted: \".concat(error.reason);\n          } catch (e) {\n            error.message = \"execution reverted (coult not decode custom error)\";\n          }\n        }\n      }\n      // Add the invocation, if available\n      var parsed = this.parseTransaction(tx);\n      if (parsed) {\n        error.invocation = {\n          method: parsed.name,\n          signature: parsed.signature,\n          args: parsed.args\n        };\n      }\n      return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n  }, {\n    key: \"encodeFunctionResult\",\n    value: function encodeFunctionResult(fragment, values) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      return (0, index_js_3.hexlify)(_classPrivateFieldGet(this, _abiCoder).encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n  }, {\n    key: \"encodeFilterTopics\",\n    value: function encodeFilterTopics(fragment, values) {\n      var _this2 = this;\n      if (typeof fragment === \"string\") {\n        var f = this.getEvent(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n        fragment = f;\n      }\n      (0, index_js_3.assert)(values.length <= fragment.inputs.length, \"too many arguments for \".concat(fragment.format()), \"UNEXPECTED_ARGUMENT\", {\n        count: values.length,\n        expectedCount: fragment.inputs.length\n      });\n      var topics = [];\n      if (!fragment.anonymous) {\n        topics.push(fragment.topicHash);\n      }\n      // @TODO: Use the coders for this; to properly support tuples, etc.\n      var encodeTopic = function encodeTopic(param, value) {\n        if (param.type === \"string\") {\n          return (0, index_js_2.id)(value);\n        } else if (param.type === \"bytes\") {\n          return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));\n        }\n        if (param.type === \"bool\" && typeof value === \"boolean\") {\n          value = value ? \"0x01\" : \"0x00\";\n        }\n        if (param.type.match(/^u?int/)) {\n          value = (0, index_js_3.toBeHex)(value);\n        }\n        // Check addresses are valid\n        if (param.type === \"address\") {\n          _classPrivateFieldGet(_this2, _abiCoder).encode([\"address\"], [value]);\n        }\n        return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);\n        //@TOOD should probably be return toHex(value, 32)\n      };\n\n      values.forEach(function (value, index) {\n        var param = fragment.inputs[index];\n        if (!param.indexed) {\n          (0, index_js_3.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n          return;\n        }\n        if (value == null) {\n          topics.push(null);\n        } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n          (0, index_js_3.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n        } else if (Array.isArray(value)) {\n          topics.push(value.map(function (value) {\n            return encodeTopic(param, value);\n          }));\n        } else {\n          topics.push(encodeTopic(param, value));\n        }\n      });\n      // Trim off trailing nulls\n      while (topics.length && topics[topics.length - 1] === null) {\n        topics.pop();\n      }\n      return topics;\n    }\n  }, {\n    key: \"encodeEventLog\",\n    value: function encodeEventLog(fragment, values) {\n      var _this3 = this;\n      if (typeof fragment === \"string\") {\n        var f = this.getEvent(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n        fragment = f;\n      }\n      var topics = [];\n      var dataTypes = [];\n      var dataValues = [];\n      if (!fragment.anonymous) {\n        topics.push(fragment.topicHash);\n      }\n      (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n      fragment.inputs.forEach(function (param, index) {\n        var value = values[index];\n        if (param.indexed) {\n          if (param.type === \"string\") {\n            topics.push((0, index_js_2.id)(value));\n          } else if (param.type === \"bytes\") {\n            topics.push((0, index_js_1.keccak256)(value));\n          } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n            // @TODO\n            throw new Error(\"not implemented\");\n          } else {\n            topics.push(_classPrivateFieldGet(_this3, _abiCoder).encode([param.type], [value]));\n          }\n        } else {\n          dataTypes.push(param);\n          dataValues.push(value);\n        }\n      });\n      return {\n        data: _classPrivateFieldGet(this, _abiCoder).encode(dataTypes, dataValues),\n        topics: topics\n      };\n    }\n    // Decode a filter for the event and the search criteria\n  }, {\n    key: \"decodeEventLog\",\n    value: function decodeEventLog(fragment, data, topics) {\n      if (typeof fragment === \"string\") {\n        var f = this.getEvent(fragment);\n        (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n        fragment = f;\n      }\n      if (topics != null && !fragment.anonymous) {\n        var eventTopic = fragment.topicHash;\n        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n        topics = topics.slice(1);\n      }\n      var indexed = [];\n      var nonIndexed = [];\n      var dynamic = [];\n      fragment.inputs.forEach(function (param, index) {\n        if (param.indexed) {\n          if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n            indexed.push(fragments_js_1.ParamType.from({\n              type: \"bytes32\",\n              name: param.name\n            }));\n            dynamic.push(true);\n          } else {\n            indexed.push(param);\n            dynamic.push(false);\n          }\n        } else {\n          nonIndexed.push(param);\n          dynamic.push(false);\n        }\n      });\n      var resultIndexed = topics != null ? _classPrivateFieldGet(this, _abiCoder).decode(indexed, (0, index_js_3.concat)(topics)) : null;\n      var resultNonIndexed = _classPrivateFieldGet(this, _abiCoder).decode(nonIndexed, data, true);\n      //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n      var values = [];\n      var keys = [];\n      var nonIndexedIndex = 0,\n        indexedIndex = 0;\n      fragment.inputs.forEach(function (param, index) {\n        var value = null;\n        if (param.indexed) {\n          if (resultIndexed == null) {\n            value = new Indexed(null);\n          } else if (dynamic[index]) {\n            value = new Indexed(resultIndexed[indexedIndex++]);\n          } else {\n            try {\n              value = resultIndexed[indexedIndex++];\n            } catch (error) {\n              value = error;\n            }\n          }\n        } else {\n          try {\n            value = resultNonIndexed[nonIndexedIndex++];\n          } catch (error) {\n            value = error;\n          }\n        }\n        values.push(value);\n        keys.push(param.name || null);\n      });\n      return abstract_coder_js_1.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n  }, {\n    key: \"parseTransaction\",\n    value: function parseTransaction(tx) {\n      var data = (0, index_js_3.getBytes)(tx.data, \"tx.data\");\n      var value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n      var fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));\n      if (!fragment) {\n        return null;\n      }\n      var args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));\n      return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n  }, {\n    key: \"parseCallResult\",\n    value: function parseCallResult(data) {\n      throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n  }, {\n    key: \"parseLog\",\n    value: function parseLog(log) {\n      var fragment = this.getEvent(log.topics[0]);\n      if (!fragment || fragment.anonymous) {\n        return null;\n      }\n      // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n      //        Probably not, because just because it is the only event in the ABI does\n      //        not mean we have the full ABI; maybe just a fragment?\n      return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n  }, {\n    key: \"parseError\",\n    value: function parseError(data) {\n      var hexData = (0, index_js_3.hexlify)(data);\n      var fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));\n      if (!fragment) {\n        return null;\n      }\n      var args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));\n      return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      // Already an Interface, which is immutable\n      if (value instanceof Interface) {\n        return value;\n      }\n      // JSON\n      if (typeof value === \"string\") {\n        return new Interface(JSON.parse(value));\n      }\n      // Maybe an interface from an older version, or from a symlinked copy\n      if (typeof value.format === \"function\") {\n        return new Interface(value.format(\"json\"));\n      }\n      // Array of fragments\n      return new Interface(value);\n    }\n  }]);\n  return Interface;\n}();\nfunction _getFunction2(key, values, forceUnique) {\n  // Selector\n  if ((0, index_js_3.isHexString)(key)) {\n    var selector = key.toLowerCase();\n    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _functions).values()),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var fragment = _step4.value;\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    var matching = [];\n    var _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _functions)),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _step5$value = _slicedToArray(_step5.value, 2),\n          name = _step5$value[0],\n          _fragment2 = _step5$value[1];\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(_fragment2);\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    if (values) {\n      var lastValue = values.length > 0 ? values[values.length - 1] : null;\n      var valueLength = values.length;\n      var allowOptions = true;\n      if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n        allowOptions = false;\n        valueLength--;\n      }\n      // Remove all matches that don't have a compatible length. The args\n      // may contain an overrides, so the match may have n or n - 1 parameters\n      for (var i = matching.length - 1; i >= 0; i--) {\n        var inputs = matching[i].inputs.length;\n        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (var _i = matching.length - 1; _i >= 0; _i--) {\n        var _inputs = matching[_i].inputs;\n        for (var j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!typed_js_1.Typed.isTyped(values[j])) {\n            continue;\n          }\n          // We are past the inputs\n          if (j >= _inputs.length) {\n            if (values[j].type === \"overrides\") {\n              continue;\n            }\n            matching.splice(_i, 1);\n            break;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== _inputs[j].baseType) {\n            matching.splice(_i, 1);\n            break;\n          }\n        }\n      }\n    }\n    // We found a single matching signature with an overrides, but the\n    // last value is something that cannot possibly be an options\n    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n      var lastArg = values[values.length - 1];\n      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n        matching.splice(0, 1);\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      var matchStr = matching.map(function (m) {\n        return JSON.stringify(m.format());\n      }).join(\", \");\n      (0, index_js_3.assertArgument)(false, \"ambiguous function description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  var result = _classPrivateFieldGet(this, _functions).get(fragments_js_1.FunctionFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nfunction _getEvent2(key, values, forceUnique) {\n  // EventTopic\n  if ((0, index_js_3.isHexString)(key)) {\n    var eventTopic = key.toLowerCase();\n    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _events).values()),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var fragment = _step6.value;\n        if (eventTopic === fragment.topicHash) {\n          return fragment;\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    var matching = [];\n    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _events)),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 2),\n          name = _step7$value[0],\n          _fragment3 = _step7$value[1];\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(_fragment3);\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    if (values) {\n      // Remove all matches that don't have a compatible length.\n      for (var i = matching.length - 1; i >= 0; i--) {\n        if (matching[i].inputs.length < values.length) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (var _i2 = matching.length - 1; _i2 >= 0; _i2--) {\n        var inputs = matching[_i2].inputs;\n        for (var j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!typed_js_1.Typed.isTyped(values[j])) {\n            continue;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(_i2, 1);\n            break;\n          }\n        }\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      var matchStr = matching.map(function (m) {\n        return JSON.stringify(m.format());\n      }).join(\", \");\n      (0, index_js_3.assertArgument)(false, \"ambiguous event description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  var result = _classPrivateFieldGet(this, _events).get(fragments_js_1.EventFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nexports.Interface = Interface;","map":{"version":3,"names":["_slicedToArray","require","default","_createForOfIteratorHelper","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateMethodGet","_classPrivateFieldGet","_classPrivateFieldSet","_createClass","_classCallCheck","_defineProperty","index_js_1","index_js_2","index_js_3","abi_coder_js_1","abstract_coder_js_1","Object","defineProperty","exports","enumerable","get","checkResultErrors","Result","fragments_js_1","typed_js_1","LogDescription","fragment","topic","args","name","signature","format","defineProperties","TransactionDescription","selector","value","ErrorDescription","Indexed","hash","_isIndexed","key","isIndexed","PanicReasons","BuiltinErrors","inputs","reason","message","concat","JSON","stringify","code","toString","_errors","WeakMap","_events","_functions","_abiCoder","_getFunction","WeakSet","_getEvent","Interface","fragments","_this","writable","abi","parse","Map","frags","_iterator","_step","s","n","done","a","push","Fragment","from","error","console","log","err","e","f","freeze","fallback","receive","getAbiCoder","forEach","index","bucket","type","deploy","length","assertArgument","payable","has","set","ConstructorFragment","minimal","map","formatJson","j","AbiCoder","defaultAbiCoder","getFunctionName","_getFunction2","call","hasFunction","getFunction","values","forEachFunction","callback","names","Array","keys","sort","b","localeCompare","i","getEventName","_getEvent2","hasEvent","getEvent","forEachEvent","getError","isHexString","toLowerCase","ErrorFragment","_iterator2","_step2","indexOf","matching","_iterator3","_step3","_step3$value","split","matchStr","m","join","result","forEachError","_decodeParams","params","data","decode","_encodeParams","encode","encodeDeploy","decodeErrorResult","dataSlice","encodeErrorResult","decodeFunctionData","encodeFunctionData","decodeFunctionResult","bytes","getBytesCopy","outputs","assert","hexlify","info","method","makeError","_data","tx","getBytes","getBuiltinCallException","customPrefix","startsWith","slice","ef","revert","parsed","parseTransaction","invocation","encodeFunctionResult","encodeFilterTopics","_this2","count","expectedCount","topics","anonymous","topicHash","encodeTopic","param","id","keccak256","match","toBeHex","zeroPadValue","indexed","baseType","isArray","pop","encodeEventLog","_this3","dataTypes","dataValues","Error","decodeEventLog","eventTopic","nonIndexed","dynamic","ParamType","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","fromItems","getBigInt","parseCallResult","parseLog","parseError","hexData","forceUnique","_iterator4","_step4","_iterator5","_step5","_step5$value","lastValue","valueLength","allowOptions","Typed","isTyped","splice","lastArg","FunctionFragment","_iterator6","_step6","_iterator7","_step7","_step7$value","EventFragment"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/abi/interface.ts"],"sourcesContent":["/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\nimport { keccak256 } from \"../crypto/index.js\"\nimport { id } from \"../hash/index.js\"\nimport {\n    concat, dataSlice, getBigInt, getBytes, getBytesCopy,\n    hexlify, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex,\n    assert\n} from \"../utils/index.js\";\n\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport {\n    ConstructorFragment, ErrorFragment, EventFragment, FallbackFragment,\n    Fragment, FunctionFragment, ParamType\n} from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\n\nimport type { BigNumberish, BytesLike, CallExceptionError, CallExceptionTransaction } from \"../utils/index.js\";\n\nimport type { JsonFragment } from \"./fragments.js\";\n\n\nexport { checkResultErrors, Result };\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nexport class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The topic hash for the Event.\n     */\n    readonly topic!: string;\n\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    readonly args!: Result\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: EventFragment, topic: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<LogDescription>(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nexport class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    readonly args!: Result;\n\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    readonly selector!: string;\n\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    readonly value!: bigint;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: FunctionFragment, selector: string, args: Result, value: bigint) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<TransactionDescription>(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nexport class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n    /**\n     *  The full Error signature.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The selector for the Error.\n     */\n    readonly selector!: string;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: ErrorFragment, selector: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<ErrorDescription>(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nexport class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(hash: null | string) {\n        defineProperties<Indexed>(this, { hash, _isIndexed: true })\n    }\n}\n\ntype ErrorInfo = {\n    signature: string,\n    inputs: Array<string>,\n    name: string,\n    reason: (...args: Array<any>) => string;\n};\n\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons: Record<string, string> = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n}\n\nconst BuiltinErrors: Record<string, ErrorInfo> = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [ \"string\" ],\n        reason: (message: string) => {\n            return `reverted with reason string ${ JSON.stringify(message) }`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [ \"uint256\" ],\n        reason: (code: bigint) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${ code.toString(16) } (${ reason })`;\n        }\n    }\n}\n\n/*\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n*/\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\n\n/**\n *  An **InterfaceAbi** may be any supported ABI format.\n *\n *  A string is expected to be a JSON string, which will be parsed\n *  using ``JSON.parse``. This means that the value **must** be a valid\n *  JSON string, with no stray commas, etc.\n *\n *  An array may contain any combination of:\n *  - Human-Readable fragments\n *  - Parsed JSON fragment\n *  - [[Fragment]] instances\n *\n *  A **Human-Readable Fragment** is a string which resembles a Solidity\n *  signature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\n *  For example, ``function balanceOf(address) view returns (uint)``.\n *\n *  A **Parsed JSON Fragment** is a JavaScript Object desribed in the\n *  [Solidity documentation](link-solc-jsonabi).\n */\nexport type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;\n\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nexport class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if any.\n     */\n    readonly fallback!: null | FallbackFragment;\n\n    /**\n     *  If receiving ether is supported.\n     */\n    readonly receive!: boolean;\n\n    #errors: Map<string, ErrorFragment>;\n    #events: Map<string, EventFragment>;\n    #functions: Map<string, FunctionFragment>;\n//    #structs: Map<string, StructFragment>;\n\n    #abiCoder: AbiCoder;\n\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments: InterfaceAbi) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n//        this.#structs = new Map();\n\n\n        const frags: Array<Fragment> = [ ];\n        for (const a of abi) {\n            try {\n                frags.push(Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n\n        defineProperties<Interface>(this, {\n            fragments: Object.freeze(frags)\n        });\n\n        let fallback: null | FallbackFragment = null;\n        let receive = false;\n\n        this.#abiCoder = this.getAbiCoder();\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket: Map<string, Fragment>;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineProperties<Interface>(this, { deploy: <ConstructorFragment>fragment });\n                    return;\n\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        assertArgument(!fallback || (<FallbackFragment>fragment).payable !== fallback.payable,\n                            \"conflicting fallback fragments\", `fragments[${ index }]`, fragment);\n                        fallback = <FallbackFragment>fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n\n                default:\n                    return;\n            }\n\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) { return; }\n\n            bucket.set(signature, fragment);\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineProperties<Interface>(this, {\n                deploy: ConstructorFragment.from(\"constructor()\")\n            });\n        }\n\n        defineProperties<Interface>(this, { fallback, receive });\n    }\n\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal?: boolean): Array<string> {\n        const format = (minimal ? \"minimal\": \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson(): string {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder(): AbiCoder {\n        return AbiCoder.defaultAbiCoder();\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key: string, values: null | Array<any | Typed>, forceUnique: boolean): null | FunctionFragment {\n\n        // Selector\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<FunctionFragment> = [ ];\n            for (const [ name, fragment ] of this.#functions) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1]: null;\n\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") { continue; }\n                            matching.splice(i, 1);\n                            break;\n                        }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof(lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous function description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(FunctionFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key: string): string {\n        const fragment = this.#getFunction(key, null, false);\n        assertArgument(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key: string): boolean {\n        return !!this.#getFunction(key, null, false);\n    }\n\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key: string, values?: Array<any | Typed>): null | FunctionFragment {\n        return this.#getFunction(key, values || null, true);\n    }\n\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback: (func: FunctionFragment, index: number) => void): void {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<FunctionFragment>(this.#functions.get(name)), i);\n        }\n    }\n\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key: string, values: null | Array<null | any | Typed>, forceUnique: boolean): null | EventFragment {\n\n        // EventTopic\n        if (isHexString(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [ ];\n            for (const [ name, fragment ] of this.#events) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous event description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(EventFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key: string): string {\n        const fragment = this.#getEvent(key, null, false);\n        assertArgument(fragment, \"no matching event\", \"key\", key);\n\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key: string): boolean {\n        return !!this.#getEvent(key, null, false);\n    }\n\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key: string, values?: Array<any | Typed>): null | EventFragment {\n        return this.#getEvent(key, values || null, true)\n    }\n\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback: (func: EventFragment, index: number) => void): void {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<EventFragment>(this.#events.get(name)), i);\n        }\n    }\n\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key: string, values?: Array<any | Typed>): null | ErrorFragment {\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n\n            if (BuiltinErrors[selector]) {\n                return ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [ ];\n            for (const [ name, fragment ] of this.#errors) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (matching.length === 0) {\n                if (key === \"Error\") { return ErrorFragment.from(\"error Error(string)\"); }\n                if (key === \"Panic\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous error description (i.e. ${ matchStr })`, \"name\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        key = ErrorFragment.from(key).format()\n        if (key === \"Error(string)\") { return ErrorFragment.from(\"error Error(string)\"); }\n        if (key === \"Panic(uint256)\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n\n        const result = this.#errors.get(key);\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback: (func: ErrorFragment, index: number) => void): void {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<ErrorFragment>(this.#errors.get(name)), i);\n        }\n    }\n\n    // Get the 4-byte selector used by Solidity to identify a function\n        /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n        if (typeof(fragment) === \"string\") {\n            const matches: Array<Fragment> = [ ];\n\n            try { matches.push(this.getFunction(fragment)); } catch (error) { }\n            try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n            if (matches.length === 0) {\n                logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n            } else if (matches.length > 1) {\n                logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n            }\n\n            fragment = matches[0];\n        }\n\n        return dataSlice(id(fragment.format()), 0, 4);\n    }\n        */\n\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this.#abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this.#abiCoder.encode(params, values)\n    }\n\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match error ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match function ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        let message = \"invalid length for result data\";\n\n        const bytes = getBytesCopy(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n\n        // Call returned data with no error, but the data is junk\n        assert(false, message, \"BAD_DATA\", {\n            value: hexlify(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n\n    makeError(_data: BytesLike, tx: CallExceptionTransaction): CallExceptionError {\n        const data = getBytes(_data, \"data\");\n\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = hexlify(data.slice(0, 4));\n\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${ error.reason }`\n                 } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`\n                }\n            }\n        }\n\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n\n        return error;\n    }\n\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || [ ]));\n    }\n/*\n    spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n        const promises: Array<Promise<>> = [ ];\n        const process = function(type: ParamType, value: any): any {\n            if (type.baseType === \"array\") {\n                return descend(type.child\n            }\n            if (type. === \"address\") {\n            }\n        };\n\n        const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n            if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n            \n        };\n\n        const result: Array<any> = [ ];\n        values.forEach((value, index) => {\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n    }\n*/\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment: EventFragment | string, values: ReadonlyArray<any>): Array<null | string | Array<string>> {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        assert(values.length <= fragment.inputs.length, `too many arguments for ${ fragment.format() }`,\n            \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length })\n\n        const topics: Array<null | string | Array<string>> = [];\n        if (!fragment.anonymous) { topics.push(fragment.topicHash); }\n\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = toBeHex(value);\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this.#abiCoder.encode( [ \"address\" ], [ value ]); }\n            return zeroPadValue(hexlify(value), 32);\n            //@TOOD should probably be return toHex(value, 32)\n        };\n\n        values.forEach((value, index) => {\n\n            const param = (<EventFragment>fragment).inputs[index];\n\n            if (!param.indexed) {\n                assertArgument(value == null,\n                    \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                assertArgument(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(fragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n\n        assertArgument(values.length === fragment.inputs.length,\n            \"event arguments/values mismatch\", \"values\", values);\n\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this.#abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic,\n                \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n\n        const indexed: Array<ParamType> = [];\n        const nonIndexed: Array<ParamType> = [];\n        const dynamic: Array<boolean> = [];\n\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)): null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values: Array<any> = [ ];\n        const keys: Array<null | string> = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n\n            values.push(value);\n            keys.push(param.name || null);\n        });\n\n        return Result.fromItems(values, keys);\n    }\n\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx: { data: string, value?: BigNumberish }): null | TransactionDescription {\n        const data = getBytes(tx.data, \"tx.data\");\n        const value = getBigInt((tx.value != null) ? tx.value: 0, \"tx.value\");\n\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n\n    parseCallResult(data: BytesLike): Result {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log: { topics: Array<string>, data: string}): null | LogDescription {\n        const fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseError(data: BytesLike): null | ErrorDescription {\n        const hexData = hexlify(data);\n\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value: InterfaceAbi | Interface): Interface {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) { return value; }\n\n        // JSON\n        if (typeof(value) === \"string\") { return new Interface(JSON.parse(value)); }\n\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof((<any>value).format) === \"function\") {\n            return new Interface((<any>value).format(\"json\"));\n        }\n\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}