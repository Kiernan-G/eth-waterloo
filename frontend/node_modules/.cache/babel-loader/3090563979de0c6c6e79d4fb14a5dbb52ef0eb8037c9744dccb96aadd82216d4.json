{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _get = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NonceManager = void 0;\nvar index_js_1 = require(\"../utils/index.js\");\nvar abstract_signer_js_1 = require(\"./abstract-signer.js\");\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nvar _noncePromise = /*#__PURE__*/new WeakMap();\nvar _delta = /*#__PURE__*/new WeakMap();\nvar NonceManager = /*#__PURE__*/function (_abstract_signer_js_) {\n  _inherits(NonceManager, _abstract_signer_js_);\n  var _super = _createSuper(NonceManager);\n  /**\n   *  Creates a new **NonceManager** to manage %%signer%%.\n   */\n  function NonceManager(signer) {\n    var _this;\n    _classCallCheck(this, NonceManager);\n    _this = _super.call(this, signer.provider);\n    /**\n     *  The Signer being managed.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"signer\", void 0);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _noncePromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _delta, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_1.defineProperties)(_assertThisInitialized(_this), {\n      signer: signer\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this), _noncePromise, null);\n    _classPrivateFieldSet(_assertThisInitialized(_this), _delta, 0);\n    return _this;\n  }\n  _createClass(NonceManager, [{\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.signer.getAddress());\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n  }, {\n    key: \"connect\",\n    value: function connect(provider) {\n      return new NonceManager(this.signer.connect(provider));\n    }\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockTag) {\n        var delta;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(blockTag === \"pending\")) {\n                _context2.next = 8;\n                break;\n              }\n              if (_classPrivateFieldGet(this, _noncePromise) == null) {\n                _classPrivateFieldSet(this, _noncePromise, _get(_getPrototypeOf(NonceManager.prototype), \"getNonce\", this).call(this, \"pending\"));\n              }\n              delta = _classPrivateFieldGet(this, _delta);\n              _context2.next = 5;\n              return _classPrivateFieldGet(this, _noncePromise);\n            case 5:\n              _context2.t0 = _context2.sent;\n              _context2.t1 = delta;\n              return _context2.abrupt(\"return\", _context2.t0 + _context2.t1);\n            case 8:\n              return _context2.abrupt(\"return\", _get(_getPrototypeOf(NonceManager.prototype), \"getNonce\", this).call(this, blockTag));\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getNonce(_x) {\n        return _getNonce.apply(this, arguments);\n      }\n      return getNonce;\n    }()\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n  }, {\n    key: \"increment\",\n    value: function increment() {\n      var _this$delta, _this$delta2;\n      _classPrivateFieldSet(this, _delta, (_this$delta = _classPrivateFieldGet(this, _delta), _this$delta2 = _this$delta++, _this$delta)), _this$delta2;\n    }\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _classPrivateFieldSet(this, _delta, 0);\n      _classPrivateFieldSet(this, _noncePromise, null);\n    }\n  }, {\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx) {\n        var noncePromise;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              noncePromise = this.getNonce(\"pending\");\n              this.increment();\n              _context3.next = 4;\n              return this.signer.populateTransaction(tx);\n            case 4:\n              tx = _context3.sent;\n              _context3.next = 7;\n              return noncePromise;\n            case 7:\n              tx.nonce = _context3.sent;\n              _context3.next = 10;\n              return this.signer.sendTransaction(tx);\n            case 10:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 11:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function sendTransaction(_x2) {\n        return _sendTransaction.apply(this, arguments);\n      }\n      return sendTransaction;\n    }()\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(tx) {\n      return this.signer.signTransaction(tx);\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message) {\n      return this.signer.signMessage(message);\n    }\n  }, {\n    key: \"signTypedData\",\n    value: function signTypedData(domain, types, value) {\n      return this.signer.signTypedData(domain, types, value);\n    }\n  }]);\n  return NonceManager;\n}(abstract_signer_js_1.AbstractSigner);\nexports.NonceManager = NonceManager;","map":{"version":3,"names":["index_js_1","require","abstract_signer_js_1","_noncePromise","WeakMap","_delta","NonceManager","_abstract_signer_js_","_inherits","_super","_createSuper","signer","_this","_classCallCheck","call","provider","_defineProperty","_assertThisInitialized","_classPrivateFieldInitSpec","writable","value","defineProperties","_classPrivateFieldSet","_createClass","key","_getAddress","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","getAddress","stop","apply","arguments","connect","_getNonce","_callee2","blockTag","delta","_callee2$","_context2","_classPrivateFieldGet","_get","_getPrototypeOf","prototype","t0","sent","t1","getNonce","_x","increment","_this$delta","_this$delta2","reset","_sendTransaction","_callee3","tx","noncePromise","_callee3$","_context3","populateTransaction","nonce","sendTransaction","_x2","signTransaction","signMessage","message","signTypedData","domain","types","AbstractSigner","exports"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/providers/signer-noncemanager.ts"],"sourcesContent":["import { defineProperties } from \"../utils/index.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\n\nimport type { TypedDataDomain, TypedDataField } from \"../hash/index.js\";\n\nimport type {\n    BlockTag, Provider, TransactionRequest, TransactionResponse\n} from \"./provider.js\";\nimport type { Signer } from \"./signer.js\";\n\n\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nexport class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer!: Signer;\n\n    #noncePromise: null | Promise<number>;\n    #delta: number;\n\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer: Signer) {\n        super(signer.provider);\n        defineProperties<NonceManager>(this, { signer });\n\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n\n    async getAddress(): Promise<string> {\n        return this.signer.getAddress();\n    }\n\n    connect(provider: null | Provider): NonceManager {\n        return new NonceManager(this.signer.connect(provider));\n    }\n\n    async getNonce(blockTag?: BlockTag): Promise<number> {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n\n            const delta = this.#delta;\n            return (await this.#noncePromise) + delta;\n        }\n\n        return super.getNonce(blockTag);\n    }\n\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n    increment(): void {\n        this.#delta++;\n    }\n\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n    reset(): void {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n\n    async sendTransaction(tx: TransactionRequest): Promise<TransactionResponse> {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n\n    signTransaction(tx: TransactionRequest): Promise<string> {\n        return this.signer.signTransaction(tx);\n    }\n\n    signMessage(message: string | Uint8Array): Promise<string> {\n        return this.signer.signMessage(message);\n    }\n\n    signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}