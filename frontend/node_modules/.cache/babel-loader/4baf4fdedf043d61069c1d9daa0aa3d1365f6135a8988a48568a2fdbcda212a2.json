{"ast":null,"code":"\"use strict\";\n\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _get = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _objectSpread = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nvar index_js_1 = require(\"../abi/index.js\");\nvar index_js_2 = require(\"../address/index.js\");\nvar index_js_3 = require(\"../hash/index.js\");\nvar index_js_4 = require(\"../transaction/index.js\");\nvar index_js_5 = require(\"../utils/index.js\");\nvar abstract_provider_js_1 = require(\"./abstract-provider.js\");\nvar abstract_signer_js_1 = require(\"./abstract-signer.js\");\nvar network_js_1 = require(\"./network.js\");\nvar subscriber_filterid_js_1 = require(\"./subscriber-filterid.js\");\nvar subscriber_polling_js_1 = require(\"./subscriber-polling.js\");\nvar Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n  if (value == null || Primitive.indexOf(typeof value) >= 0) {\n    return value;\n  }\n  // Keep any Addressable\n  if (typeof value.getAddress === \"function\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(deepCopy);\n  }\n  if (typeof value === \"object\") {\n    return Object.keys(value).reduce(function (accum, key) {\n      accum[key] = value[key];\n      return accum;\n    }, {});\n  }\n  throw new Error(\"should not happen: \".concat(value, \" (\").concat(typeof value, \")\"));\n}\nfunction stall(duration) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getLowerCase(value) {\n  if (value) {\n    return value.toLowerCase();\n  }\n  return value;\n}\nfunction isPollable(value) {\n  return value && typeof value.pollingInterval === \"number\";\n}\nvar defaultOptions = {\n  polling: false,\n  staticNetwork: null,\n  batchStallTime: 10,\n  batchMaxSize: 1 << 20,\n  batchMaxCount: 100,\n  cacheTimeout: 250\n};\n// @TODO: Unchecked Signers\nvar JsonRpcSigner = /*#__PURE__*/function (_abstract_signer_js_) {\n  _inherits(JsonRpcSigner, _abstract_signer_js_);\n  var _super = _createSuper(JsonRpcSigner);\n  function JsonRpcSigner(provider, address) {\n    var _this;\n    _classCallCheck(this, JsonRpcSigner);\n    _this = _super.call(this, provider);\n    _defineProperty(_assertThisInitialized(_this), \"address\", void 0);\n    address = (0, index_js_2.getAddress)(address);\n    (0, index_js_5.defineProperties)(_assertThisInitialized(_this), {\n      address: address\n    });\n    return _this;\n  }\n  _createClass(JsonRpcSigner, [{\n    key: \"connect\",\n    value: function connect(provider) {\n      (0, index_js_5.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"signer.connect\"\n      });\n    }\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.address);\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }() // JSON-RPC will automatially fill in nonce, etc. so we just check from\n  }, {\n    key: \"populateTransaction\",\n    value: function () {\n      var _populateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.populateCall(tx);\n            case 2:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function populateTransaction(_x) {\n        return _populateTransaction.apply(this, arguments);\n      }\n      return populateTransaction;\n    }() // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n  }, {\n    key: \"sendUncheckedTransaction\",\n    value: function () {\n      var _sendUncheckedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_tx) {\n        var _this2 = this;\n        var tx, promises, _from, _to, hexTx;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              tx = deepCopy(_tx);\n              promises = []; // Make sure the from matches the sender\n              if (tx.from) {\n                _from = tx.from;\n                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var from;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return (0, index_js_2.resolveAddress)(_from, _this2.provider);\n                      case 2:\n                        from = _context3.sent;\n                        (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === _this2.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                        tx.from = from;\n                      case 5:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }))());\n              } else {\n                tx.from = this.address;\n              }\n              // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n              // wishes to use this, it is easy to specify explicitly, otherwise\n              // we look it up for them.\n              if (tx.gasLimit == null) {\n                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.next = 2;\n                        return _this2.provider.estimateGas(_objectSpread(_objectSpread({}, tx), {}, {\n                          from: _this2.address\n                        }));\n                      case 2:\n                        tx.gasLimit = _context4.sent;\n                      case 3:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4);\n                }))());\n              }\n              // The address may be an ENS name or Addressable\n              if (tx.to != null) {\n                _to = tx.to;\n                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                    while (1) switch (_context5.prev = _context5.next) {\n                      case 0:\n                        _context5.next = 2;\n                        return (0, index_js_2.resolveAddress)(_to, _this2.provider);\n                      case 2:\n                        tx.to = _context5.sent;\n                      case 3:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }, _callee5);\n                }))());\n              }\n              // Wait until all of our properties are filled in\n              if (!promises.length) {\n                _context6.next = 8;\n                break;\n              }\n              _context6.next = 8;\n              return Promise.all(promises);\n            case 8:\n              hexTx = this.provider.getRpcTransaction(tx);\n              return _context6.abrupt(\"return\", this.provider.send(\"eth_sendTransaction\", [hexTx]));\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function sendUncheckedTransaction(_x2) {\n        return _sendUncheckedTransaction.apply(this, arguments);\n      }\n      return sendUncheckedTransaction;\n    }()\n  }, {\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(tx) {\n        var _this3 = this;\n        var blockNumber, hash;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return this.provider.getBlockNumber();\n            case 2:\n              blockNumber = _context8.sent;\n              _context8.next = 5;\n              return this.sendUncheckedTransaction(tx);\n            case 5:\n              hash = _context8.sent;\n              _context8.next = 8;\n              return new Promise(function (resolve, reject) {\n                var timeouts = [1000, 100];\n                var checkTx = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                    var tx;\n                    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                      while (1) switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _context7.next = 2;\n                          return _this3.provider.getTransaction(hash);\n                        case 2:\n                          tx = _context7.sent;\n                          if (!(tx != null)) {\n                            _context7.next = 6;\n                            break;\n                          }\n                          resolve(tx.replaceableTransaction(blockNumber));\n                          return _context7.abrupt(\"return\");\n                        case 6:\n                          // Wait another 4 seconds\n                          _this3.provider._setTimeout(function () {\n                            checkTx();\n                          }, timeouts.pop() || 4000);\n                        case 7:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }, _callee7);\n                  }));\n                  return function checkTx() {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n                checkTx();\n              });\n            case 8:\n              return _context8.abrupt(\"return\", _context8.sent);\n            case 9:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function sendTransaction(_x3) {\n        return _sendTransaction.apply(this, arguments);\n      }\n      return sendTransaction;\n    }()\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_tx) {\n        var tx, from, hexTx;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              tx = deepCopy(_tx); // Make sure the from matches the sender\n              if (!tx.from) {\n                _context9.next = 9;\n                break;\n              }\n              _context9.next = 4;\n              return (0, index_js_2.resolveAddress)(tx.from, this.provider);\n            case 4:\n              from = _context9.sent;\n              (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n              tx.from = from;\n              _context9.next = 10;\n              break;\n            case 9:\n              tx.from = this.address;\n            case 10:\n              hexTx = this.provider.getRpcTransaction(tx);\n              _context9.next = 13;\n              return this.provider.send(\"eth_signTransaction\", [hexTx]);\n            case 13:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 14:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function signTransaction(_x4) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signMessage\",\n    value: function () {\n      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_message) {\n        var message;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              message = typeof _message === \"string\" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;\n              _context10.next = 3;\n              return this.provider.send(\"personal_sign\", [(0, index_js_5.hexlify)(message), this.address.toLowerCase()]);\n            case 3:\n              return _context10.abrupt(\"return\", _context10.sent);\n            case 4:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function signMessage(_x5) {\n        return _signMessage.apply(this, arguments);\n      }\n      return signMessage;\n    }()\n  }, {\n    key: \"signTypedData\",\n    value: function () {\n      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(domain, types, _value) {\n        var value, populated;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              value = deepCopy(_value); // Populate any ENS names (in-place)\n              _context12.next = 3;\n              return index_js_3.TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {\n                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(value) {\n                  var address;\n                  return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n                    while (1) switch (_context11.prev = _context11.next) {\n                      case 0:\n                        _context11.next = 2;\n                        return (0, index_js_2.resolveAddress)(value);\n                      case 2:\n                        address = _context11.sent;\n                        (0, index_js_5.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n                        return _context11.abrupt(\"return\", address);\n                      case 5:\n                      case \"end\":\n                        return _context11.stop();\n                    }\n                  }, _callee11);\n                }));\n                return function (_x9) {\n                  return _ref5.apply(this, arguments);\n                };\n              }());\n            case 3:\n              populated = _context12.sent;\n              _context12.next = 6;\n              return this.provider.send(\"eth_signTypedData_v4\", [this.address.toLowerCase(), JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);\n            case 6:\n              return _context12.abrupt(\"return\", _context12.sent);\n            case 7:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function signTypedData(_x6, _x7, _x8) {\n        return _signTypedData.apply(this, arguments);\n      }\n      return signTypedData;\n    }()\n  }, {\n    key: \"unlock\",\n    value: function () {\n      var _unlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(password) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              return _context13.abrupt(\"return\", this.provider.send(\"personal_unlockAccount\", [this.address.toLowerCase(), password, null]));\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function unlock(_x10) {\n        return _unlock.apply(this, arguments);\n      }\n      return unlock;\n    }() // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n  }, {\n    key: \"_legacySignMessage\",\n    value: function () {\n      var _legacySignMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_message) {\n        var message;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              message = typeof _message === \"string\" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;\n              _context14.next = 3;\n              return this.provider.send(\"eth_sign\", [this.address.toLowerCase(), (0, index_js_5.hexlify)(message)]);\n            case 3:\n              return _context14.abrupt(\"return\", _context14.sent);\n            case 4:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function _legacySignMessage(_x11) {\n        return _legacySignMessage2.apply(this, arguments);\n      }\n      return _legacySignMessage;\n    }()\n  }]);\n  return JsonRpcSigner;\n}(abstract_signer_js_1.AbstractSigner);\nexports.JsonRpcSigner = JsonRpcSigner;\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nvar _options = /*#__PURE__*/new WeakMap();\nvar _nextId = /*#__PURE__*/new WeakMap();\nvar _payloads = /*#__PURE__*/new WeakMap();\nvar _drainTimer = /*#__PURE__*/new WeakMap();\nvar _notReady = /*#__PURE__*/new WeakMap();\nvar _network = /*#__PURE__*/new WeakMap();\nvar _scheduleDrain = /*#__PURE__*/new WeakSet();\nvar JsonRpcApiProvider = /*#__PURE__*/function (_abstract_provider_js) {\n  _inherits(JsonRpcApiProvider, _abstract_provider_js);\n  var _super2 = _createSuper(JsonRpcApiProvider);\n  function JsonRpcApiProvider(network, options) {\n    var _this4;\n    _classCallCheck(this, JsonRpcApiProvider);\n    var superOptions = {};\n    if (options && options.cacheTimeout != null) {\n      superOptions.cacheTimeout = options.cacheTimeout;\n    }\n    _this4 = _super2.call(this, network, superOptions);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this4), _scheduleDrain);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _options, {\n      writable: true,\n      value: void 0\n    });\n    // The next ID to use for the JSON-RPC ID field\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _nextId, {\n      writable: true,\n      value: void 0\n    });\n    // Payloads are queued and triggered in batches using the drainTimer\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _payloads, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _drainTimer, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _notReady, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _network, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _nextId, 1);\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _options, Object.assign({}, defaultOptions, options || {}));\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _payloads, []);\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _drainTimer, null);\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _network, null);\n    {\n      var resolve = null;\n      var promise = new Promise(function (_resolve) {\n        resolve = _resolve;\n      });\n      _classPrivateFieldSet(_assertThisInitialized(_this4), _notReady, {\n        promise: promise,\n        resolve: resolve\n      });\n    }\n    // Make sure any static network is compatbile with the provided netwrok\n    var staticNetwork = _this4._getOption(\"staticNetwork\");\n    if (staticNetwork) {\n      (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n      _classPrivateFieldSet(_assertThisInitialized(_this4), _network, staticNetwork);\n    }\n    return _this4;\n  }\n  /**\n   *  Returns the value associated with the option %%key%%.\n   *\n   *  Sub-classes can use this to inquire about configuration options.\n   */\n  _createClass(JsonRpcApiProvider, [{\n    key: \"_getOption\",\n    value: function _getOption(key) {\n      return _classPrivateFieldGet(this, _options)[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n  }, {\n    key: \"_network\",\n    get: function get() {\n      (0, index_js_5.assert)(_classPrivateFieldGet(this, _network), \"network is not available yet\", \"NETWORK_ERROR\");\n      return _classPrivateFieldGet(this, _network);\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n  }, {\n    key: \"_perform\",\n    value: function () {\n      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(req) {\n        var tx, feeData, request;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!(req.method === \"call\" || req.method === \"estimateGas\")) {\n                _context15.next = 8;\n                break;\n              }\n              tx = req.transaction;\n              if (!(tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type))) {\n                _context15.next = 8;\n                break;\n              }\n              if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) {\n                _context15.next = 8;\n                break;\n              }\n              _context15.next = 6;\n              return this.getFeeData();\n            case 6:\n              feeData = _context15.sent;\n              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                // Network doesn't know about EIP-1559 (and hence type)\n                req = Object.assign({}, req, {\n                  transaction: Object.assign({}, tx, {\n                    type: undefined\n                  })\n                });\n              }\n            case 8:\n              request = this.getRpcRequest(req);\n              if (!(request != null)) {\n                _context15.next = 13;\n                break;\n              }\n              _context15.next = 12;\n              return this.send(request.method, request.args);\n            case 12:\n              return _context15.abrupt(\"return\", _context15.sent);\n            case 13:\n              return _context15.abrupt(\"return\", _get(_getPrototypeOf(JsonRpcApiProvider.prototype), \"_perform\", this).call(this, req));\n            case 14:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function _perform(_x12) {\n        return _perform2.apply(this, arguments);\n      }\n      return _perform;\n    }()\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n  }, {\n    key: \"_detectNetwork\",\n    value: function () {\n      var _detectNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this$nextId, _this$nextId2;\n        var network, payload, result;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              network = this._getOption(\"staticNetwork\");\n              if (!network) {\n                _context16.next = 3;\n                break;\n              }\n              return _context16.abrupt(\"return\", network);\n            case 3:\n              if (!this.ready) {\n                _context16.next = 11;\n                break;\n              }\n              _context16.t0 = network_js_1.Network;\n              _context16.t1 = (0, index_js_5.getBigInt);\n              _context16.next = 8;\n              return this.send(\"eth_chainId\", []);\n            case 8:\n              _context16.t2 = _context16.sent;\n              _context16.t3 = (0, _context16.t1)(_context16.t2);\n              return _context16.abrupt(\"return\", _context16.t0.from.call(_context16.t0, _context16.t3));\n            case 11:\n              // We are not ready yet; use the primitive _send\n              payload = {\n                id: (_classPrivateFieldSet(this, _nextId, (_this$nextId = _classPrivateFieldGet(this, _nextId), _this$nextId2 = _this$nextId++, _this$nextId)), _this$nextId2),\n                method: \"eth_chainId\",\n                params: [],\n                jsonrpc: \"2.0\"\n              };\n              this.emit(\"debug\", {\n                action: \"sendRpcPayload\",\n                payload: payload\n              });\n              _context16.prev = 13;\n              _context16.next = 16;\n              return this._send(payload);\n            case 16:\n              result = _context16.sent[0];\n              _context16.next = 23;\n              break;\n            case 19:\n              _context16.prev = 19;\n              _context16.t4 = _context16[\"catch\"](13);\n              this.emit(\"debug\", {\n                action: \"receiveRpcError\",\n                error: _context16.t4\n              });\n              throw _context16.t4;\n            case 23:\n              this.emit(\"debug\", {\n                action: \"receiveRpcResult\",\n                result: result\n              });\n              if (!(\"result\" in result)) {\n                _context16.next = 26;\n                break;\n              }\n              return _context16.abrupt(\"return\", network_js_1.Network.from((0, index_js_5.getBigInt)(result.result)));\n            case 26:\n              throw this.getRpcError(payload, result);\n            case 27:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this, [[13, 19]]);\n      }));\n      function _detectNetwork() {\n        return _detectNetwork2.apply(this, arguments);\n      }\n      return _detectNetwork;\n    }()\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      var _this5 = this;\n      if (_classPrivateFieldGet(this, _notReady) == null || _classPrivateFieldGet(this, _notReady).resolve == null) {\n        return;\n      }\n      _classPrivateFieldGet(this, _notReady).resolve();\n      _classPrivateFieldSet(this, _notReady, null);\n      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!(_classPrivateFieldGet(_this5, _network) == null && !_this5.destroyed)) {\n                _context17.next = 19;\n                break;\n              }\n              _context17.prev = 1;\n              _context17.t0 = _classPrivateFieldSet;\n              _context17.t1 = _this5;\n              _context17.t2 = _network;\n              _context17.next = 7;\n              return _this5._detectNetwork();\n            case 7:\n              _context17.t3 = _context17.sent;\n              (0, _context17.t0)(_context17.t1, _context17.t2, _context17.t3);\n              _context17.next = 17;\n              break;\n            case 11:\n              _context17.prev = 11;\n              _context17.t4 = _context17[\"catch\"](1);\n              console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n              _this5.emit(\"error\", (0, index_js_5.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                event: \"initial-network-discovery\",\n                info: {\n                  error: _context17.t4\n                }\n              }));\n              _context17.next = 17;\n              return stall(1000);\n            case 17:\n              _context17.next = 0;\n              break;\n            case 19:\n              // Start dispatching requests\n              _classPrivateMethodGet(_this5, _scheduleDrain, _scheduleDrain2).call(_this5);\n            case 20:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, null, [[1, 11]]);\n      }))();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n  }, {\n    key: \"_waitUntilReady\",\n    value: function () {\n      var _waitUntilReady2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              if (!(_classPrivateFieldGet(this, _notReady) == null)) {\n                _context18.next = 2;\n                break;\n              }\n              return _context18.abrupt(\"return\");\n            case 2:\n              _context18.next = 4;\n              return _classPrivateFieldGet(this, _notReady).promise;\n            case 4:\n              return _context18.abrupt(\"return\", _context18.sent);\n            case 5:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function _waitUntilReady() {\n        return _waitUntilReady2.apply(this, arguments);\n      }\n      return _waitUntilReady;\n    }()\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n  }, {\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      // Pending Filters aren't availble via polling\n      if (sub.type === \"pending\") {\n        return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);\n      }\n      if (sub.type === \"event\") {\n        if (this._getOption(\"polling\")) {\n          return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);\n        }\n        return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);\n      }\n      // Orphaned Logs are handled automatically, by the filter, since\n      // logs with removed are emitted by it\n      if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n        return new abstract_provider_js_1.UnmanagedSubscriber(\"orphan\");\n      }\n      return _get(_getPrototypeOf(JsonRpcApiProvider.prototype), \"_getSubscriber\", this).call(this, sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n  }, {\n    key: \"ready\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _notReady) == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n  }, {\n    key: \"getRpcTransaction\",\n    value: function getRpcTransaction(tx) {\n      var result = {};\n      // JSON-RPC now requires numeric values to be \"quantity\" values\n      [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n        if (tx[key] == null) {\n          return;\n        }\n        var dstKey = key;\n        if (key === \"gasLimit\") {\n          dstKey = \"gas\";\n        }\n        result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], \"tx.\".concat(key)));\n      });\n      // Make sure addresses and data are lowercase\n      [\"from\", \"to\", \"data\"].forEach(function (key) {\n        if (tx[key] == null) {\n          return;\n        }\n        result[key] = (0, index_js_5.hexlify)(tx[key]);\n      });\n      // Normalize the access list object\n      if (tx.accessList) {\n        result[\"accessList\"] = (0, index_js_4.accessListify)(tx.accessList);\n      }\n      return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n  }, {\n    key: \"getRpcRequest\",\n    value: function getRpcRequest(req) {\n      switch (req.method) {\n        case \"chainId\":\n          return {\n            method: \"eth_chainId\",\n            args: []\n          };\n        case \"getBlockNumber\":\n          return {\n            method: \"eth_blockNumber\",\n            args: []\n          };\n        case \"getGasPrice\":\n          return {\n            method: \"eth_gasPrice\",\n            args: []\n          };\n        case \"getBalance\":\n          return {\n            method: \"eth_getBalance\",\n            args: [getLowerCase(req.address), req.blockTag]\n          };\n        case \"getTransactionCount\":\n          return {\n            method: \"eth_getTransactionCount\",\n            args: [getLowerCase(req.address), req.blockTag]\n          };\n        case \"getCode\":\n          return {\n            method: \"eth_getCode\",\n            args: [getLowerCase(req.address), req.blockTag]\n          };\n        case \"getStorage\":\n          return {\n            method: \"eth_getStorageAt\",\n            args: [getLowerCase(req.address), \"0x\" + req.position.toString(16), req.blockTag]\n          };\n        case \"broadcastTransaction\":\n          return {\n            method: \"eth_sendRawTransaction\",\n            args: [req.signedTransaction]\n          };\n        case \"getBlock\":\n          if (\"blockTag\" in req) {\n            return {\n              method: \"eth_getBlockByNumber\",\n              args: [req.blockTag, !!req.includeTransactions]\n            };\n          } else if (\"blockHash\" in req) {\n            return {\n              method: \"eth_getBlockByHash\",\n              args: [req.blockHash, !!req.includeTransactions]\n            };\n          }\n          break;\n        case \"getTransaction\":\n          return {\n            method: \"eth_getTransactionByHash\",\n            args: [req.hash]\n          };\n        case \"getTransactionReceipt\":\n          return {\n            method: \"eth_getTransactionReceipt\",\n            args: [req.hash]\n          };\n        case \"call\":\n          return {\n            method: \"eth_call\",\n            args: [this.getRpcTransaction(req.transaction), req.blockTag]\n          };\n        case \"estimateGas\":\n          {\n            return {\n              method: \"eth_estimateGas\",\n              args: [this.getRpcTransaction(req.transaction)]\n            };\n          }\n        case \"getLogs\":\n          if (req.filter && req.filter.address != null) {\n            if (Array.isArray(req.filter.address)) {\n              req.filter.address = req.filter.address.map(getLowerCase);\n            } else {\n              req.filter.address = getLowerCase(req.filter.address);\n            }\n          }\n          return {\n            method: \"eth_getLogs\",\n            args: [req.filter]\n          };\n      }\n      return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n  }, {\n    key: \"getRpcError\",\n    value: function getRpcError(payload, _error) {\n      var method = payload.method;\n      var error = _error.error;\n      if (method === \"eth_estimateGas\" && error.message) {\n        var msg = error.message;\n        if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n          return (0, index_js_5.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n            transaction: payload.params[0],\n            info: {\n              payload: payload,\n              error: error\n            }\n          });\n        }\n      }\n      if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n        var result = spelunkData(error);\n        var e = index_js_1.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n        e.info = {\n          error: error,\n          payload: payload\n        };\n        return e;\n      }\n      // Only estimateGas and call can return arbitrary contract-defined text, so now we\n      // we can process text safely.\n      var message = JSON.stringify(spelunkMessage(error));\n      if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n        var actionMap = {\n          eth_sign: \"signMessage\",\n          personal_sign: \"signMessage\",\n          eth_signTypedData_v4: \"signTypedData\",\n          eth_signTransaction: \"signTransaction\",\n          eth_sendTransaction: \"sendTransaction\",\n          eth_requestAccounts: \"requestAccess\",\n          wallet_requestAccounts: \"requestAccess\"\n        };\n        return (0, index_js_5.makeError)(\"user rejected action\", \"ACTION_REJECTED\", {\n          action: actionMap[method] || \"unknown\",\n          reason: \"rejected\",\n          info: {\n            payload: payload,\n            error: error\n          }\n        });\n      }\n      if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n        var transaction = payload.params[0];\n        if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n          return (0, index_js_5.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n            transaction: transaction,\n            info: {\n              error: error\n            }\n          });\n        }\n        if (message.match(/nonce/i) && message.match(/too low/i)) {\n          return (0, index_js_5.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n            transaction: transaction,\n            info: {\n              error: error\n            }\n          });\n        }\n        // \"replacement transaction underpriced\"\n        if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n          return (0, index_js_5.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n            transaction: transaction,\n            info: {\n              error: error\n            }\n          });\n        }\n        if (message.match(/only replay-protected/i)) {\n          return (0, index_js_5.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n            operation: method,\n            info: {\n              transaction: transaction,\n              info: {\n                error: error\n              }\n            }\n          });\n        }\n      }\n      if (message.match(/the method .* does not exist/i)) {\n        return (0, index_js_5.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n          operation: payload.method,\n          info: {\n            error: error\n          }\n        });\n      }\n      return (0, index_js_5.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n        error: error\n      });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n  }, {\n    key: \"send\",\n    value: function send(method, params) {\n      var _this$nextId3,\n        _this$nextId4,\n        _this6 = this;\n      // @TODO: cache chainId?? purge on switch_networks\n      // We have been destroyed; no operations are supported anymore\n      if (this.destroyed) {\n        return Promise.reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n          operation: method\n        }));\n      }\n      var id = (_classPrivateFieldSet(this, _nextId, (_this$nextId3 = _classPrivateFieldGet(this, _nextId), _this$nextId4 = _this$nextId3++, _this$nextId3)), _this$nextId4);\n      var promise = new Promise(function (resolve, reject) {\n        _classPrivateFieldGet(_this6, _payloads).push({\n          resolve: resolve,\n          reject: reject,\n          payload: {\n            method: method,\n            params: params,\n            id: id,\n            jsonrpc: \"2.0\"\n          }\n        });\n      });\n      // If there is not a pending drainTimer, set one\n      _classPrivateMethodGet(this, _scheduleDrain, _scheduleDrain2).call(this);\n      return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n  }, {\n    key: \"getSigner\",\n    value: function () {\n      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(address) {\n        var accountsPromise, _accounts, _yield, accounts, _iterator, _step, account;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              if (address == null) {\n                address = 0;\n              }\n              accountsPromise = this.send(\"eth_accounts\", []); // Account index\n              if (!(typeof address === \"number\")) {\n                _context19.next = 9;\n                break;\n              }\n              _context19.next = 5;\n              return accountsPromise;\n            case 5:\n              _accounts = _context19.sent;\n              if (!(address >= _accounts.length)) {\n                _context19.next = 8;\n                break;\n              }\n              throw new Error(\"no such account\");\n            case 8:\n              return _context19.abrupt(\"return\", new JsonRpcSigner(this, _accounts[address]));\n            case 9:\n              _context19.next = 11;\n              return (0, index_js_5.resolveProperties)({\n                network: this.getNetwork(),\n                accounts: accountsPromise\n              });\n            case 11:\n              _yield = _context19.sent;\n              accounts = _yield.accounts;\n              // Account address\n              address = (0, index_js_2.getAddress)(address);\n              _iterator = _createForOfIteratorHelper(accounts);\n              _context19.prev = 15;\n              _iterator.s();\n            case 17:\n              if ((_step = _iterator.n()).done) {\n                _context19.next = 23;\n                break;\n              }\n              account = _step.value;\n              if (!((0, index_js_2.getAddress)(account) === address)) {\n                _context19.next = 21;\n                break;\n              }\n              return _context19.abrupt(\"return\", new JsonRpcSigner(this, address));\n            case 21:\n              _context19.next = 17;\n              break;\n            case 23:\n              _context19.next = 28;\n              break;\n            case 25:\n              _context19.prev = 25;\n              _context19.t0 = _context19[\"catch\"](15);\n              _iterator.e(_context19.t0);\n            case 28:\n              _context19.prev = 28;\n              _iterator.f();\n              return _context19.finish(28);\n            case 31:\n              throw new Error(\"invalid account\");\n            case 32:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this, [[15, 25, 28, 31]]);\n      }));\n      function getSigner(_x13) {\n        return _getSigner.apply(this, arguments);\n      }\n      return getSigner;\n    }()\n  }, {\n    key: \"listAccounts\",\n    value: function () {\n      var _listAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        var _this7 = this;\n        var accounts;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return this.send(\"eth_accounts\", []);\n            case 2:\n              accounts = _context20.sent;\n              return _context20.abrupt(\"return\", accounts.map(function (a) {\n                return new JsonRpcSigner(_this7, a);\n              }));\n            case 4:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function listAccounts() {\n        return _listAccounts.apply(this, arguments);\n      }\n      return listAccounts;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // Stop processing requests\n      if (_classPrivateFieldGet(this, _drainTimer)) {\n        clearTimeout(_classPrivateFieldGet(this, _drainTimer));\n        _classPrivateFieldSet(this, _drainTimer, null);\n      }\n      // Cancel all pending requests\n      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _payloads)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n            payload = _step2$value.payload,\n            reject = _step2$value.reject;\n          reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n            operation: payload.method\n          }));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      _classPrivateFieldSet(this, _payloads, []);\n      // Parent clean-up\n      _get(_getPrototypeOf(JsonRpcApiProvider.prototype), \"destroy\", this).call(this);\n    }\n  }]);\n  return JsonRpcApiProvider;\n}(abstract_provider_js_1.AbstractProvider);\nfunction _scheduleDrain2() {\n  var _this11 = this;\n  if (_classPrivateFieldGet(this, _drainTimer)) {\n    return;\n  }\n  // If we aren't using batching, no hard in sending it immeidately\n  var stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n  _classPrivateFieldSet(this, _drainTimer, setTimeout(function () {\n    _classPrivateFieldSet(_this11, _drainTimer, null);\n    var payloads = _classPrivateFieldGet(_this11, _payloads);\n    _classPrivateFieldSet(_this11, _payloads, []);\n    var _loop = function _loop() {\n      // Create payload batches that satisfy our batch constraints\n      var batch = [payloads.shift()];\n      while (payloads.length) {\n        if (batch.length === _classPrivateFieldGet(_this11, _options).batchMaxCount) {\n          break;\n        }\n        batch.push(payloads.shift());\n        var bytes = JSON.stringify(batch.map(function (p) {\n          return p.payload;\n        }));\n        if (bytes.length > _classPrivateFieldGet(_this11, _options).batchMaxSize) {\n          payloads.unshift(batch.pop());\n          break;\n        }\n      }\n      // Process the result to each payload\n      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var payload, result, _loop2, _i, _batch, _ret, _i2, _batch2, reject;\n        return _regeneratorRuntime().wrap(function _callee23$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              payload = batch.length === 1 ? batch[0].payload : batch.map(function (p) {\n                return p.payload;\n              });\n              _this11.emit(\"debug\", {\n                action: \"sendRpcPayload\",\n                payload: payload\n              });\n              _context24.prev = 2;\n              _context24.next = 5;\n              return _this11._send(payload);\n            case 5:\n              result = _context24.sent;\n              _this11.emit(\"debug\", {\n                action: \"receiveRpcResult\",\n                result: result\n              });\n              // Process results in batch order\n              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n                var _batch$_i, resolve, reject, payload, resp, error;\n                return _regeneratorRuntime().wrap(function _loop2$(_context23) {\n                  while (1) switch (_context23.prev = _context23.next) {\n                    case 0:\n                      _batch$_i = _batch[_i], resolve = _batch$_i.resolve, reject = _batch$_i.reject, payload = _batch$_i.payload;\n                      if (!_this11.destroyed) {\n                        _context23.next = 4;\n                        break;\n                      }\n                      reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                        operation: payload.method\n                      }));\n                      return _context23.abrupt(\"return\", \"continue\");\n                    case 4:\n                      // Find the matching result\n                      resp = result.filter(function (r) {\n                        return r.id === payload.id;\n                      })[0]; // No result; the node failed us in unexpected ways\n                      if (!(resp == null)) {\n                        _context23.next = 10;\n                        break;\n                      }\n                      error = (0, index_js_5.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                        value: result,\n                        info: {\n                          payload: payload\n                        }\n                      });\n                      _this11.emit(\"error\", error);\n                      reject(error);\n                      return _context23.abrupt(\"return\", \"continue\");\n                    case 10:\n                      if (!(\"error\" in resp)) {\n                        _context23.next = 13;\n                        break;\n                      }\n                      reject(_this11.getRpcError(payload, resp));\n                      return _context23.abrupt(\"return\", \"continue\");\n                    case 13:\n                      // All good; send the result\n                      resolve(resp.result);\n                    case 14:\n                    case \"end\":\n                      return _context23.stop();\n                  }\n                }, _loop2);\n              });\n              _i = 0, _batch = batch;\n            case 9:\n              if (!(_i < _batch.length)) {\n                _context24.next = 17;\n                break;\n              }\n              return _context24.delegateYield(_loop2(), \"t0\", 11);\n            case 11:\n              _ret = _context24.t0;\n              if (!(_ret === \"continue\")) {\n                _context24.next = 14;\n                break;\n              }\n              return _context24.abrupt(\"continue\", 14);\n            case 14:\n              _i++;\n              _context24.next = 9;\n              break;\n            case 17:\n              _context24.next = 23;\n              break;\n            case 19:\n              _context24.prev = 19;\n              _context24.t1 = _context24[\"catch\"](2);\n              _this11.emit(\"debug\", {\n                action: \"receiveRpcError\",\n                error: _context24.t1\n              });\n              for (_i2 = 0, _batch2 = batch; _i2 < _batch2.length; _i2++) {\n                reject = _batch2[_i2].reject;\n                // @TODO: augment the error with the payload\n                reject(_context24.t1);\n              }\n            case 23:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee23, null, [[2, 19]]);\n      }))();\n    };\n    while (payloads.length) {\n      _loop();\n    }\n  }, stallTime));\n}\nexports.JsonRpcApiProvider = JsonRpcApiProvider;\nvar _pollingInterval = /*#__PURE__*/new WeakMap();\nvar JsonRpcApiPollingProvider = /*#__PURE__*/function (_JsonRpcApiProvider) {\n  _inherits(JsonRpcApiPollingProvider, _JsonRpcApiProvider);\n  var _super3 = _createSuper(JsonRpcApiPollingProvider);\n  function JsonRpcApiPollingProvider(network, options) {\n    var _this8;\n    _classCallCheck(this, JsonRpcApiPollingProvider);\n    _this8 = _super3.call(this, network, options);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this8), _pollingInterval, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this8), _pollingInterval, 4000);\n    return _this8;\n  }\n  _createClass(JsonRpcApiPollingProvider, [{\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      var subscriber = _get(_getPrototypeOf(JsonRpcApiPollingProvider.prototype), \"_getSubscriber\", this).call(this, sub);\n      if (isPollable(subscriber)) {\n        subscriber.pollingInterval = _classPrivateFieldGet(this, _pollingInterval);\n      }\n      return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n  }, {\n    key: \"pollingInterval\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _pollingInterval);\n    },\n    set: function set(value) {\n      var _this9 = this;\n      if (!Number.isInteger(value) || value < 0) {\n        throw new Error(\"invalid interval\");\n      }\n      _classPrivateFieldSet(this, _pollingInterval, value);\n      this._forEachSubscriber(function (sub) {\n        if (isPollable(sub)) {\n          sub.pollingInterval = _classPrivateFieldGet(_this9, _pollingInterval);\n        }\n      });\n    }\n  }]);\n  return JsonRpcApiPollingProvider;\n}(JsonRpcApiProvider);\nexports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nvar _connect = /*#__PURE__*/new WeakMap();\nvar JsonRpcProvider = /*#__PURE__*/function (_JsonRpcApiPollingPro) {\n  _inherits(JsonRpcProvider, _JsonRpcApiPollingPro);\n  var _super4 = _createSuper(JsonRpcProvider);\n  function JsonRpcProvider(url, network, options) {\n    var _this10;\n    _classCallCheck(this, JsonRpcProvider);\n    if (url == null) {\n      url = \"http:/\\/localhost:8545\";\n    }\n    _this10 = _super4.call(this, network, options);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this10), _connect, {\n      writable: true,\n      value: void 0\n    });\n    if (typeof url === \"string\") {\n      _classPrivateFieldSet(_assertThisInitialized(_this10), _connect, new index_js_5.FetchRequest(url));\n    } else {\n      _classPrivateFieldSet(_assertThisInitialized(_this10), _connect, url.clone());\n    }\n    return _this10;\n  }\n  _createClass(JsonRpcProvider, [{\n    key: \"_getConnection\",\n    value: function _getConnection() {\n      return _classPrivateFieldGet(this, _connect).clone();\n    }\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(method, params) {\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this._start();\n            case 2:\n              _context21.next = 4;\n              return _get(_getPrototypeOf(JsonRpcProvider.prototype), \"send\", this).call(this, method, params);\n            case 4:\n              return _context21.abrupt(\"return\", _context21.sent);\n            case 5:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function send(_x14, _x15) {\n        return _send2.apply(this, arguments);\n      }\n      return send;\n    }()\n  }, {\n    key: \"_send\",\n    value: function () {\n      var _send3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(payload) {\n        var request, response, resp;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              // Configure a POST connection for the requested method\n              request = this._getConnection();\n              request.body = JSON.stringify(payload);\n              request.setHeader(\"content-type\", \"application/json\");\n              _context22.next = 5;\n              return request.send();\n            case 5:\n              response = _context22.sent;\n              response.assertOk();\n              resp = response.bodyJson;\n              if (!Array.isArray(resp)) {\n                resp = [resp];\n              }\n              return _context22.abrupt(\"return\", resp);\n            case 10:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function _send(_x16) {\n        return _send3.apply(this, arguments);\n      }\n      return _send;\n    }()\n  }]);\n  return JsonRpcProvider;\n}(JsonRpcApiPollingProvider);\nexports.JsonRpcProvider = JsonRpcProvider;\nfunction spelunkData(value) {\n  if (value == null) {\n    return null;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\" && value.message.match(\"reverted\") && (0, index_js_5.isHexString)(value.data)) {\n    return {\n      message: value.message,\n      data: value.data\n    };\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (var key in value) {\n      var result = spelunkData(value[key]);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return spelunkData(JSON.parse(value));\n    } catch (error) {}\n  }\n  return null;\n}\nfunction _spelunkMessage(value, result) {\n  if (value == null) {\n    return;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\") {\n    result.push(value.message);\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (var key in value) {\n      _spelunkMessage(value[key], result);\n    }\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return _spelunkMessage(JSON.parse(value), result);\n    } catch (error) {}\n  }\n}\nfunction spelunkMessage(value) {\n  var result = [];\n  _spelunkMessage(value, result);\n  return result;\n}","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_get","_getPrototypeOf","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateMethodGet","_classPrivateFieldSet","_classPrivateFieldGet","_objectSpread","_regeneratorRuntime","_asyncToGenerator","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_createSuper","_defineProperty","index_js_1","index_js_2","index_js_3","index_js_4","index_js_5","abstract_provider_js_1","abstract_signer_js_1","network_js_1","subscriber_filterid_js_1","subscriber_polling_js_1","Primitive","split","deepCopy","value","indexOf","getAddress","Array","isArray","map","Object","keys","reduce","accum","key","Error","concat","stall","duration","Promise","resolve","setTimeout","getLowerCase","toLowerCase","isPollable","pollingInterval","defaultOptions","polling","staticNetwork","batchStallTime","batchMaxSize","batchMaxCount","cacheTimeout","JsonRpcSigner","_abstract_signer_js_","_super","provider","address","_this","call","defineProperties","connect","assert","operation","_getAddress","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","stop","apply","arguments","_populateTransaction","_callee2","tx","_callee2$","_context2","populateCall","sent","populateTransaction","_x","_sendUncheckedTransaction","_callee6","_tx","_this2","promises","_from","_to","hexTx","_callee6$","_context6","from","push","_callee3","_callee3$","_context3","resolveAddress","assertArgument","gasLimit","_callee4","_callee4$","_context4","estimateGas","to","_callee5","_callee5$","_context5","length","all","getRpcTransaction","send","sendUncheckedTransaction","_x2","_sendTransaction","_callee8","_this3","blockNumber","hash","_callee8$","_context8","getBlockNumber","reject","timeouts","checkTx","_ref4","_callee7","_callee7$","_context7","getTransaction","replaceableTransaction","_setTimeout","pop","sendTransaction","_x3","_signTransaction","_callee9","_callee9$","_context9","signTransaction","_x4","_signMessage","_callee10","_message","message","_callee10$","_context10","toUtf8Bytes","hexlify","signMessage","_x5","_signTypedData","_callee12","domain","types","_value","populated","_callee12$","_context12","TypedDataEncoder","resolveNames","_ref5","_callee11","_callee11$","_context11","_x9","JSON","stringify","getPayload","signTypedData","_x6","_x7","_x8","_unlock","_callee13","password","_callee13$","_context13","unlock","_x10","_legacySignMessage2","_callee14","_callee14$","_context14","_legacySignMessage","_x11","AbstractSigner","exports","_options","WeakMap","_nextId","_payloads","_drainTimer","_notReady","_network","_scheduleDrain","WeakSet","JsonRpcApiProvider","_abstract_provider_js","_super2","network","options","_this4","superOptions","writable","assign","promise","_resolve","_getOption","matches","get","_perform2","_callee15","req","feeData","request","_callee15$","_context15","method","transaction","type","getBigInt","maxFeePerGas","maxPriorityFeePerGas","getFeeData","undefined","getRpcRequest","args","prototype","_perform","_x12","_detectNetwork2","_callee16","_this$nextId","_this$nextId2","payload","result","_callee16$","_context16","ready","t0","Network","t1","t2","t3","id","params","jsonrpc","emit","action","_send","t4","error","getRpcError","_detectNetwork","_start","_this5","_callee17","_callee17$","_context17","destroyed","console","log","makeError","event","info","_scheduleDrain2","_waitUntilReady2","_callee18","_callee18$","_context18","_waitUntilReady","_getSubscriber","sub","FilterIdPendingSubscriber","PollingEventSubscriber","filter","FilterIdEventSubscriber","orphan","UnmanagedSubscriber","forEach","dstKey","toQuantity","accessList","accessListify","blockTag","position","toString","signedTransaction","includeTransactions","blockHash","_error","msg","match","spelunkData","e","AbiCoder","getBuiltinCallException","data","spelunkMessage","actionMap","eth_sign","personal_sign","eth_signTypedData_v4","eth_signTransaction","eth_sendTransaction","eth_requestAccounts","wallet_requestAccounts","reason","_this$nextId3","_this$nextId4","_this6","_getSigner","_callee19","accountsPromise","_accounts","_yield","accounts","_iterator","_step","account","_callee19$","_context19","resolveProperties","getNetwork","s","n","done","f","finish","getSigner","_x13","_listAccounts","_callee20","_this7","_callee20$","_context20","a","listAccounts","destroy","clearTimeout","_iterator2","_step2","_step2$value","err","AbstractProvider","_this11","stallTime","payloads","_loop","batch","shift","bytes","p","unshift","_callee23","_loop2","_i","_batch","_ret","_i2","_batch2","_callee23$","_context24","_batch$_i","resp","_loop2$","_context23","r","delegateYield","_pollingInterval","JsonRpcApiPollingProvider","_JsonRpcApiProvider","_super3","_this8","subscriber","set","_this9","Number","isInteger","_forEachSubscriber","_connect","JsonRpcProvider","_JsonRpcApiPollingPro","_super4","url","_this10","FetchRequest","clone","_getConnection","_send2","_callee21","_callee21$","_context21","_x14","_x15","_send3","_callee22","response","_callee22$","_context22","body","setHeader","assertOk","bodyJson","_x16","isHexString","parse","_spelunkMessage"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/providers/provider-jsonrpc.ts"],"sourcesContent":["/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n\n// @TODO:\n// - Add the batching API\n\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\nimport { AbiCoder } from \"../abi/index.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { TypedDataEncoder } from \"../hash/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nimport {\n    defineProperties, getBigInt, hexlify, isHexString, toQuantity, toUtf8Bytes,\n    makeError, assert, assertArgument,\n    FetchRequest, resolveProperties\n} from \"../utils/index.js\";\n\nimport { AbstractProvider, UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\nimport { Network } from \"./network.js\";\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \"./subscriber-filterid.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\n\nimport type { TypedDataDomain, TypedDataField } from \"../hash/index.js\";\nimport type { TransactionLike } from \"../transaction/index.js\";\n\nimport type { AbstractProviderOptions, PerformActionRequest, Subscriber, Subscription } from \"./abstract-provider.js\";\nimport type { Networkish } from \"./network.js\";\nimport type { Provider, TransactionRequest, TransactionResponse } from \"./provider.js\";\nimport type { Signer } from \"./signer.js\";\n\ntype Timer = ReturnType<typeof setTimeout>;\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy<T = any>(value: T): T {\n    if (value == null || Primitive.indexOf(typeof(value)) >= 0) {\n        return value;\n    }\n\n    // Keep any Addressable\n    if (typeof((<any>value).getAddress) === \"function\") {\n        return value;\n    }\n\n    if (Array.isArray(value)) { return <any>(value.map(deepCopy)); }\n\n    if (typeof(value) === \"object\") {\n        return Object.keys(value).reduce((accum, key) => {\n            accum[key] = (<any>value)[key];\n            return accum;\n        }, <any>{ });\n    }\n\n    throw new Error(`should not happen: ${ value } (${ typeof(value) })`);\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\ninterface Pollable {\n    pollingInterval: number;\n}\n\nfunction isPollable(value: any): value is Pollable {\n    return (value && typeof(value.pollingInterval) === \"number\");\n}\n\n/**\n *  A JSON-RPC payload, which are sent to a JSON-RPC server.\n */\nexport type JsonRpcPayload = {\n    /**\n     *  The JSON-RPC request ID.\n     */\n    id: number;\n\n    /**\n     *  The JSON-RPC request method.\n     */\n    method: string;\n\n    /**\n     *  The JSON-RPC request parameters.\n     */\n    params: Array<any> | Record<string, any>;\n\n    /**\n     *  A required constant in the JSON-RPC specification.\n     */\n    jsonrpc: \"2.0\";\n};\n\n/**\n *  A JSON-RPC result, which are returned on success from a JSON-RPC server.\n */\nexport type JsonRpcResult = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response result.\n     */\n    result: any;\n};\n\n/**\n *  A JSON-RPC error, which are returned on failure from a JSON-RPC server.\n */\nexport type JsonRpcError = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response error.\n     */\n    error: {\n        code: number;\n        message?: string;\n        data?: any;\n    }\n};\n\n/**\n *  When subscribing to the ``\"debug\"`` event, the [[Listener]] will\n *  receive this object as the first parameter.\n */\nexport type DebugEventJsonRpcApiProvider = {\n    action: \"sendRpcPayload\",\n    payload: JsonRpcPayload | Array<JsonRpcPayload>\n} | {\n    action: \"receiveRpcResult\",\n    result: Array<JsonRpcResult | JsonRpcError>\n} | {\n    action: \"receiveRpcError\",\n    error: Error\n};\n\n/**\n *  Options for configuring a [[JsonRpcApiProvider]]. Much of this\n *  is targetted towards sub-classes, which often will not expose\n *  any of these options to their consumers.\n *\n *  **``polling``** - use the polling strategy is used immediately\n *  for events; otherwise, attempt to use filters and fall back onto\n *  polling (default: ``false``)\n *\n *  **``staticNetwork``** - do not request chain ID on requests to\n *  validate the underlying chain has not changed (default: ``null``)\n *\n *  This should **ONLY** be used if it is **certain** that the network\n *  cannot change, such as when using INFURA (since the URL dictates the\n *  network). If the network is assumed static and it does change, this\n *  can have tragic consequences. For example, this **CANNOT** be used\n *  with MetaMask, since the used can select a new network from the\n *  drop-down at any time.\n *\n *  **``batchStallTime``** - how long (ms) to aggregate requests into a\n *  single batch. ``0`` indicates batching will only encompass the current\n *  event loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)\n *\n *  **``batchMaxSize``** - target maximum size (bytes) to allow per batch\n *  request (default: 1Mb)\n *\n *  **``batchMaxCount``** - maximum number of requests to allow in a batch.\n *  If ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)\n *\n *  **``cacheTimeout``** - passed as [[AbstractProviderOptions]].\n */\nexport type JsonRpcApiProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | Network;\n    batchStallTime?: number;\n    batchMaxSize?: number;\n    batchMaxCount?: number;\n\n    cacheTimeout?: number;\n};\n\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n\n    batchStallTime: 10,      // 10ms\n    batchMaxSize: (1 << 20), // 1Mb\n    batchMaxCount: 100,      // 100 requests\n\n    cacheTimeout: 250\n}\n\n/**\n *  A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC\n *  Ethereum API specification.\n */\nexport interface JsonRpcTransactionRequest {\n     /**\n      *  The sender address to use when signing.\n      */\n     from?: string;\n\n     /**\n      *  The target address.\n      */\n     to?: string;\n\n     /**\n      *  The transaction data.\n      */\n     data?: string;\n\n     /**\n      *  The chain ID the transaction is valid on.\n      */\n     chainId?: string;\n\n     /**\n      *  The [[link-eip-2718]] transaction type.\n      */\n     type?: string;\n\n     /**\n      *  The maximum amount of gas to allow a transaction to consume.\n      *\n      *  In most other places in ethers, this is called ``gasLimit`` which\n      *  differs from the JSON-RPC Ethereum API specification.\n      */\n     gas?: string;\n\n     /**\n      *  The gas price per wei for transactions prior to [[link-eip-1559]].\n      */\n     gasPrice?: string;\n\n     /**\n      *  The maximum fee per gas for [[link-eip-1559]] transactions.\n      */\n     maxFeePerGas?: string;\n\n     /**\n      *  The maximum priority fee per gas for [[link-eip-1559]] transactions.\n      */\n     maxPriorityFeePerGas?: string;\n\n     /**\n      *  The nonce for the transaction.\n      */\n     nonce?: string;\n\n     /**\n      *  The transaction value (in wei).\n      */\n     value?: string;\n\n     /**\n      *  The transaction access list.\n      */\n     accessList?: Array<{ address: string, storageKeys: Array<string> }>;\n}\n\n// @TODO: Unchecked Signers\n\nexport class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {\n    address!: string;\n\n    constructor(provider: JsonRpcApiProvider, address: string) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties<JsonRpcSigner>(this, { address });\n    }\n\n    connect(provider: null | Provider): Signer {\n        assert(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n\n    async getAddress(): Promise<string> {\n        return this.address;\n    }\n\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx: TransactionRequest): Promise<TransactionLike<string>> {\n        return await this.populateCall(tx);\n    }\n\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx: TransactionRequest): Promise<string> {\n        const tx = deepCopy(_tx);\n\n        const promises: Array<Promise<void>> = [];\n\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async () => {\n                const from = await resolveAddress(_from, this.provider);\n                assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(),\n                    \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async () => {\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address});\n            })());\n        }\n\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async () => {\n                tx.to = await resolveAddress(_to, this.provider);\n            })());\n        }\n\n        // Wait until all of our properties are filled in\n        if (promises.length) { await Promise.all(promises); }\n\n        const hexTx = this.provider.getRpcTransaction(tx);\n\n        return this.provider.send(\"eth_sendTransaction\", [ hexTx ]);\n    }\n\n    async sendTransaction(tx: TransactionRequest): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await (new Promise((resolve, reject) => {\n            const timeouts = [ 1000, 100 ];\n            const checkTx = async () => {\n                // Try getting the transaction\n                const tx = await this.provider.getTransaction(hash);\n                if (tx != null) {\n                    resolve(tx.replaceableTransaction(blockNumber));\n                    return;\n                }\n\n                // Wait another 4 seconds\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        }));\n    }\n\n    async signTransaction(_tx: TransactionRequest): Promise<string> {\n        const tx = deepCopy(_tx);\n\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await resolveAddress(tx.from, this.provider);\n            assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(),\n                \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [ hexTx ]);\n    }\n\n\n    async signMessage(_message: string | Uint8Array): Promise<string> {\n        const message = ((typeof(_message) === \"string\") ? toUtf8Bytes(_message): _message);\n        return await this.provider.send(\"personal_sign\", [\n            hexlify(message), this.address.toLowerCase() ]);\n    }\n\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, _value: Record<string, any>): Promise<string> {\n        const value = deepCopy(_value);\n\n        // Populate any ENS names (in-place)\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value: string) => {\n            const address = await resolveAddress(value);\n            assertArgument(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(), password, null ]);\n    }\n\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message: string | Uint8Array): Promise<string> {\n        const message = ((typeof(_message) === \"string\") ? toUtf8Bytes(_message): _message);\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(), hexlify(message) ]);\n    }\n}\n\ntype ResolveFunc = (result: JsonRpcResult) => void;\ntype RejectFunc = (error: Error) => void;\n\ntype Payload = { payload: JsonRpcPayload, resolve: ResolveFunc, reject: RejectFunc };\n\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nexport abstract class JsonRpcApiProvider extends AbstractProvider {\n\n    #options: Required<JsonRpcApiProviderOptions>;\n\n    // The next ID to use for the JSON-RPC ID field\n    #nextId: number;\n\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads: Array<Payload>;\n    #drainTimer: null | Timer;\n\n    #notReady: null | {\n        promise: Promise<void>,\n        resolve: null | ((v: void) => void)\n    };\n\n    #network: null | Network;\n\n    #scheduleDrain(): void {\n        if (this.#drainTimer) { return; }\n\n        // If we aren't using batching, no hard in sending it immeidately\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0: this._getOption(\"batchStallTime\");\n\n        this.#drainTimer = setTimeout(() => {\n            this.#drainTimer = null;\n\n            const payloads = this.#payloads;\n            this.#payloads = [ ];\n\n            while (payloads.length) {\n\n                // Create payload batches that satisfy our batch constraints\n                const batch = [ <Payload>(payloads.shift()) ];\n                while (payloads.length) {\n                    if (batch.length === this.#options.batchMaxCount) { break; }\n                    batch.push(<Payload>(payloads.shift()));\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(<Payload>(batch.pop()));\n                        break;\n                    }\n                }\n\n                // Process the result to each payload\n                (async () => {\n                    const payload = ((batch.length === 1) ? batch[0].payload: batch.map((p) => p.payload));\n\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch) {\n\n                            if (this.destroyed) {\n                                reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n                                continue;\n                            }\n\n                            // Find the matching result\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\n\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = makeError(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result, info: { payload }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n\n                    } catch (error: any) {\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\n\n                        for (const { reject } of batch) {\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n\n    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        const superOptions: AbstractProviderOptions = { };\n        if (options && options.cacheTimeout != null) {\n            superOptions.cacheTimeout = options.cacheTimeout;\n        }\n        super(network, superOptions);\n\n        this.#nextId = 1;\n        this.#options = Object.assign({ }, defaultOptions, options || { });\n\n        this.#payloads = [ ];\n        this.#drainTimer = null;\n\n        this.#network = null;\n\n        {\n            let resolve: null | ((value: void) => void) = null;\n            const promise = new Promise((_resolve: (value: void) => void) => {\n                resolve = _resolve;\n            });\n            this.#notReady = { promise, resolve };\n        }\n\n        // Make sure any static network is compatbile with the provided netwrok\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (staticNetwork) {\n            assertArgument(network == null || staticNetwork.matches(network),\n                \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */\n    _getOption<K extends keyof JsonRpcApiProviderOptions>(key: K): JsonRpcApiProviderOptions[K] {\n        return this.#options[key];\n    }\n\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n    get _network(): Network {\n        assert (this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n\n    /**\n     *  Sends a JSON-RPC %%payload%% (or a batch) to the underlying channel.\n     *\n     *  Sub-classes **MUST** override this.\n     */\n    abstract _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>>;\n\n\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n    async _perform(req: PerformActionRequest): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && getBigInt(tx.type)) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({ }, req, {\n                            transaction: Object.assign({ }, tx, { type: undefined })\n                        });\n                    }\n                }\n            }\n        }\n\n        const request = this.getRpcRequest(req);\n\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n\n        return super._perform(req);\n    }\n\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n    async _detectNetwork(): Promise<Network> {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) { return network; }\n\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            return Network.from(getBigInt(await this.send(\"eth_chainId\", [ ])));\n        }\n\n        // We are not ready yet; use the primitive _send\n\n        const payload: JsonRpcPayload = {\n            id: this.#nextId++, method: \"eth_chainId\", params: [ ], jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n\n        let result: JsonRpcResult | JsonRpcError;\n        try {\n            result = (await this._send(payload))[0];\n        } catch (error) {\n            this.emit(\"debug\", { action: \"receiveRpcError\", error });\n            throw error;\n        }\n\n        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n\n        if (\"result\" in result) {\n            return Network.from(getBigInt(result.result));\n        }\n\n        throw this.getRpcError(payload, result);\n    }\n\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n    _start(): void {\n        if (this.#notReady == null || this.#notReady.resolve == null) { return; }\n\n        this.#notReady.resolve();\n        this.#notReady = null;\n\n        (async () => {\n\n            // Bootstrap the network\n            while (this.#network == null && !this.destroyed) {\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", makeError(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\n                    await stall(1000);\n                }\n            }\n\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n    async _waitUntilReady(): Promise<void> {\n        if (this.#notReady == null) { return; }\n        return await this.#notReady.promise;\n    }\n\n\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n    _getSubscriber(sub: Subscription): Subscriber {\n\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") { return new FilterIdPendingSubscriber(this); }\n\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new PollingEventSubscriber(this, sub.filter);\n            }\n            return new FilterIdEventSubscriber(this, sub.filter);\n        }\n\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new UnmanagedSubscriber(\"orphan\");\n        }\n\n        return super._getSubscriber(sub);\n    }\n\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n    get ready(): boolean { return this.#notReady == null; }\n\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n    getRpcTransaction(tx: TransactionRequest): JsonRpcTransactionRequest {\n        const result: JsonRpcTransactionRequest = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            let dstKey = key;\n            if (key === \"gasLimit\") { dstKey = \"gas\"; }\n            (<any>result)[dstKey] = toQuantity(getBigInt((<any>tx)[key], `tx.${ key }`));\n        });\n\n        // Make sure addresses and data are lowercase\n        [\"from\", \"to\", \"data\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            (<any>result)[key] = hexlify((<any>tx)[key]);\n        });\n\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = accessListify(tx.accessList);\n        }\n\n        return result;\n    }\n\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n    getRpcRequest(req: PerformActionRequest): null | { method: string, args: Array<any> } {\n        switch (req.method) {\n            case \"chainId\":\n                return { method: \"eth_chainId\", args: [ ] };\n\n            case \"getBlockNumber\":\n                return { method: \"eth_blockNumber\", args: [ ] };\n\n            case \"getGasPrice\":\n                return { method: \"eth_gasPrice\", args: [] };\n\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [ getLowerCase(req.address), req.blockTag ]\n                };\n\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [ getLowerCase(req.address), req.blockTag ]\n                };\n\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [ getLowerCase(req.address), req.blockTag ]\n                };\n\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        (\"0x\" + req.position.toString(16)),\n                        req.blockTag\n                    ]\n                };\n\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [ req.signedTransaction ]\n                };\n\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [ req.blockTag, !!req.includeTransactions ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [ req.blockHash, !!req.includeTransactions ]\n                    };\n                }\n                break;\n\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [ req.hash ]\n                };\n\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [ req.hash ]\n                };\n\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [ this.getRpcTransaction(req.transaction), req.blockTag ]\n                };\n\n            case \"estimateGas\": {\n                return {\n                    method: \"eth_estimateGas\",\n                    args: [ this.getRpcTransaction(req.transaction) ]\n                };\n            }\n\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return { method: \"eth_getLogs\", args: [ req.filter ] };\n        }\n\n        return null;\n    }\n\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n    getRpcError(payload: JsonRpcPayload, _error: JsonRpcError): Error {\n        const { method } = payload;\n        const { error } = _error;\n\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: ((<any>payload).params[0]),\n                    info: { payload, error }\n                });\n            }\n        }\n\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n\n            const e = AbiCoder.getBuiltinCallException(\n                (method === \"eth_call\") ? \"call\": \"estimateGas\",\n                ((<any>payload).params[0]),\n                (result ? result.data: null)\n            );\n            e.info = { error, payload };\n            return e;\n        }\n\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n\n        const message = JSON.stringify(spelunkMessage(error));\n\n        if (typeof(error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap: Record<string, \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\"> = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\",\n            };\n\n            return makeError(`user rejected action`, \"ACTION_REJECTED\", {\n                action: (actionMap[method] || \"unknown\") ,\n                reason: \"rejected\",\n                info: { payload, error }\n            });\n        }\n\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = <TransactionLike<string>>((<any>payload).params[0]);\n\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return makeError(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction, info: { error }\n                });\n            }\n\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\n            }\n\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return makeError(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\n            }\n\n            if (message.match(/only replay-protected/i)) {\n                return makeError(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method, info: { transaction, info: { error } }\n                });\n            }\n        }\n\n        if (message.match(/the method .* does not exist/i)) {\n            return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method, info: { error }\n            });\n        }\n\n        return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error });\n    }\n\n\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n    send(method: string, params: Array<any> | Record<string, any>): Promise<any> {\n        // @TODO: cache chainId?? purge on switch_networks\n\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\n        }\n\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject) => {\n            this.#payloads.push({\n                resolve, reject,\n                payload: { method, params, id, jsonrpc: \"2.0\" }\n            });\n        });\n\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n\n        return <Promise<JsonRpcResult>>promise;\n    }\n\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n    async getSigner(address?: number | string): Promise<JsonRpcSigner> {\n        if (address == null) { address = 0; }\n\n        const accountsPromise = this.send(\"eth_accounts\", [ ]);\n\n        // Account index\n        if (typeof(address) === \"number\") {\n            const accounts = <Array<string>>(await accountsPromise);\n            if (address >= accounts.length) { throw new Error(\"no such account\"); }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n\n        const { accounts } = await resolveProperties({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n\n        // Account address\n        address = getAddress(address);\n        for (const account of accounts) {\n            if (getAddress(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n\n        throw new Error(\"invalid account\");\n    }\n\n    async listAccounts(): Promise<Array<JsonRpcSigner>> {\n        const accounts: Array<string> = await this.send(\"eth_accounts\", [ ]);\n        return accounts.map((a) => new JsonRpcSigner(this, a));\n    }\n\n    destroy(): void {\n\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads) {\n            reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n        }\n\n        this.#payloads = [ ];\n\n        // Parent clean-up\n        super.destroy();\n\n    }\n}\n\nexport abstract class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval: number;\n    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n\n        this.#pollingInterval = 4000;\n    }\n\n    _getSubscriber(sub: Subscription): Subscriber {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n    get pollingInterval(): number { return this.#pollingInterval; }\n    set pollingInterval(value: number) {\n        if (!Number.isInteger(value) || value < 0) { throw new Error(\"invalid interval\"); }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub) => {\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nexport class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect: FetchRequest;\n\n    constructor(url?: string | FetchRequest, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        if (url == null) { url = \"http:/\\/localhost:8545\"; }\n        super(network, options);\n\n        if (typeof(url) === \"string\") {\n            this.#connect = new FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n\n    _getConnection(): FetchRequest {\n        return this.#connect.clone();\n    }\n\n    async send(method: string, params: Array<any> | Record<string, any>): Promise<any> {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n\n        return await super.send(method, params);\n    }\n\n    async _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult>> {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n\n        const response = await request.send();\n        response.assertOk();\n\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) { resp = [ resp ]; }\n\n        return resp;\n    }\n}\n\nfunction spelunkData(value: any): null | { message: string, data: string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\") && isHexString(value.data)) {\n        return { message: value.message, data: value.data };\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunkData(value[key]);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction _spelunkMessage(value: any, result: Array<string>): void {\n    if (value == null) { return; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\") {\n        result.push(value.message);\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            _spelunkMessage(value[key], result);\n        }\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) { }\n    }\n}\n\nfunction spelunkMessage(value: any): Array<string> {\n    const result: Array<string> = [ ];\n    _spelunkMessage(value, result);\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}