{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyTypedData = exports.TypedDataEncoder = void 0;\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nvar index_js_1 = require(\"../address/index.js\");\nvar index_js_2 = require(\"../crypto/index.js\");\nvar index_js_3 = require(\"../transaction/index.js\");\nvar index_js_4 = require(\"../utils/index.js\");\nvar id_js_1 = require(\"./id.js\");\nvar padding = new Uint8Array(32);\npadding.fill(0);\nvar BN__1 = BigInt(-1);\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\nvar BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n  var bytes = (0, index_js_4.getBytes)(value);\n  var padOffset = bytes.length % 32;\n  if (padOffset) {\n    return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);\n  }\n  return (0, index_js_4.hexlify)(bytes);\n}\nvar hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);\nvar hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);\nvar domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nvar domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    (0, index_js_4.assertArgument)(typeof value === \"string\", \"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    return value;\n  };\n}\nvar domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function chainId(_value) {\n    var value = (0, index_js_4.getBigInt)(_value, \"domain.chainId\");\n    (0, index_js_4.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n    if (Number.isSafeInteger(value)) {\n      return Number(value);\n    }\n    return (0, index_js_4.toQuantity)(value);\n  },\n  verifyingContract: function verifyingContract(value) {\n    try {\n      return (0, index_js_1.getAddress)(value).toLowerCase();\n    } catch (error) {}\n    (0, index_js_4.assertArgument)(false, \"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function salt(value) {\n    var bytes = (0, index_js_4.getBytes)(value, \"domain.salt\");\n    (0, index_js_4.assertArgument)(bytes.length === 32, \"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n    return (0, index_js_4.hexlify)(bytes);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    var match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      var signed = match[1] === \"\";\n      var width = parseInt(match[2] || \"256\");\n      (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n      var boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n      var boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        var value = (0, index_js_4.getBigInt)(_value, \"value\");\n        (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, \"value out-of-bounds for \".concat(type), \"value\", value);\n        return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    var _match = type.match(/^bytes(\\d+)$/);\n    if (_match) {\n      var _width = parseInt(_match[1]);\n      (0, index_js_4.assertArgument)(_width !== 0 && _width <= 32 && _match[1] === String(_width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        var bytes = (0, index_js_4.getBytes)(value);\n        (0, index_js_4.assertArgument)(bytes.length === _width, \"invalid length for \".concat(type), \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return (0, index_js_2.keccak256)(value);\n      };\n    case \"string\":\n      return function (value) {\n        return (0, id_js_1.id)(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(function (_ref) {\n    var name = _ref.name,\n      type = _ref.type;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nvar _types = /*#__PURE__*/new WeakMap();\nvar _fullTypes = /*#__PURE__*/new WeakMap();\nvar _encoderCache = /*#__PURE__*/new WeakMap();\nvar _getEncoder = /*#__PURE__*/new WeakSet();\nvar TypedDataEncoder = /*#__PURE__*/function () {\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   *\n   *  This performs all necessary checking that types are valid and\n   *  do not violate the [[link-eip-712]] structural constraints as\n   *  well as computes the [[primaryType]].\n   */\n  function TypedDataEncoder(types) {\n    _classCallCheck(this, TypedDataEncoder);\n    _classPrivateMethodInitSpec(this, _getEncoder);\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    _defineProperty(this, \"primaryType\", void 0);\n    _classPrivateFieldInitSpec(this, _types, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fullTypes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _encoderCache, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _types, JSON.stringify(types));\n    _classPrivateFieldSet(this, _fullTypes, new Map());\n    _classPrivateFieldSet(this, _encoderCache, new Map());\n    // Link struct types to their direct child structs\n    var links = new Map();\n    // Link structs to structs which contain them as a child\n    var parents = new Map();\n    // Link all subtypes within a given struct\n    var subtypes = new Map();\n    Object.keys(types).forEach(function (type) {\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n    for (var name in types) {\n      var uniqueNames = new Set();\n      var _iterator = _createForOfIteratorHelper(types[name]),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          // Check each field has a unique name\n          (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), \"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n          uniqueNames.add(field.name);\n          // Get the base type (drop any array specifiers)\n          var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n          (0, index_js_4.assertArgument)(baseType !== name, \"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n          // Is this a base encoding type?\n          var encoder = getBaseEncoder(baseType);\n          if (encoder) {\n            continue;\n          }\n          (0, index_js_4.assertArgument)(parents.has(baseType), \"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n          // Add linkage\n          parents.get(baseType).push(name);\n          links.get(name).add(baseType);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    // Deduce the primary type\n    var primaryTypes = Array.from(parents.keys()).filter(function (n) {\n      return parents.get(n).length === 0;\n    });\n    (0, index_js_4.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n    (0, index_js_4.assertArgument)(primaryTypes.length === 1, \"ambiguous primary types or unused types: \".concat(primaryTypes.map(function (t) {\n      return JSON.stringify(t);\n    }).join(\", \")), \"types\", types);\n    (0, index_js_4.defineProperties)(this, {\n      primaryType: primaryTypes[0]\n    });\n    // Check for circular type references\n    function checkCircular(type, found) {\n      (0, index_js_4.assertArgument)(!found.has(type), \"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      found.add(type);\n      var _iterator2 = _createForOfIteratorHelper(links.get(type)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          if (!parents.has(child)) {\n            continue;\n          }\n          // Recursively check children\n          checkCircular(child, found);\n          // Mark all ancestors as having this decendant\n          var _iterator3 = _createForOfIteratorHelper(found),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var subtype = _step3.value;\n              subtypes.get(subtype).add(child);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      found.delete(type);\n    }\n    checkCircular(this.primaryType, new Set());\n    // Compute each fully describe type\n    var _iterator4 = _createForOfIteratorHelper(subtypes),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n          _name = _step4$value[0],\n          set = _step4$value[1];\n        var st = Array.from(set);\n        st.sort();\n        _classPrivateFieldGet(this, _fullTypes).set(_name, encodeType(_name, types[_name]) + st.map(function (t) {\n          return encodeType(t, types[t]);\n        }).join(\"\"));\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  /**\n   *  Returnthe encoder for the specific %%type%%.\n   */\n  _createClass(TypedDataEncoder, [{\n    key: \"types\",\n    get:\n    /**\n     *  The types.\n     */\n    function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _types));\n    }\n  }, {\n    key: \"getEncoder\",\n    value: function getEncoder(type) {\n      var encoder = _classPrivateFieldGet(this, _encoderCache).get(type);\n      if (!encoder) {\n        encoder = _classPrivateMethodGet(this, _getEncoder, _getEncoder2).call(this, type);\n        _classPrivateFieldGet(this, _encoderCache).set(type, encoder);\n      }\n      return encoder;\n    }\n  }, {\n    key: \"encodeType\",\n    value:\n    /**\n     *  Return the full type for %%name%%.\n     */\n    function encodeType(name) {\n      var result = _classPrivateFieldGet(this, _fullTypes).get(name);\n      (0, index_js_4.assertArgument)(result, \"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n      return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n  }, {\n    key: \"encodeData\",\n    value: function encodeData(type, value) {\n      return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, value) {\n      return (0, index_js_2.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n  }, {\n    key: \"hash\",\n    value: function hash(value) {\n      return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */\n  }, {\n    key: \"_visit\",\n    value: function _visit(type, value, callback) {\n      var _this = this;\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n        if (encoder) {\n          return callback(type, value);\n        }\n      }\n      // Array\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n      if (match) {\n        (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, \"array length mismatch; expected length \".concat(parseInt(match[3])), \"value\", value);\n        return value.map(function (v) {\n          return _this._visit(match[1], v, callback);\n        });\n      }\n      // Struct\n      var fields = this.types[type];\n      if (fields) {\n        return fields.reduce(function (accum, _ref2) {\n          var name = _ref2.name,\n            type = _ref2.type;\n          accum[name] = _this._visit(type, value[name], callback);\n          return accum;\n        }, {});\n      }\n      (0, index_js_4.assertArgument)(false, \"unknown type: \".concat(type), \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n  }, {\n    key: \"visit\",\n    value: function visit(value, callback) {\n      return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(types) {\n      return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */\n  }, {\n    key: \"getPrimaryType\",\n    value: function getPrimaryType(types) {\n      return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, types, value) {\n      return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n  }, {\n    key: \"hashDomain\",\n    value: function hashDomain(domain) {\n      var domainFields = [];\n      for (var name in domain) {\n        if (domain[name] == null) {\n          continue;\n        }\n        var type = domainFieldTypes[name];\n        (0, index_js_4.assertArgument)(type, \"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n        domainFields.push({\n          name: name,\n          type: type\n        });\n      }\n      domainFields.sort(function (a, b) {\n        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n      });\n      return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n        EIP712Domain: domainFields\n      }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n  }, {\n    key: \"encode\",\n    value: function encode(domain, types, value) {\n      return (0, index_js_4.concat)([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n  }, {\n    key: \"hash\",\n    value: function hash(domain, types, value) {\n      return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n  }, {\n    key: \"resolveNames\",\n    value: function () {\n      var _resolveNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(domain, types, value, resolveName) {\n        var key, ensCache, encoder, name;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // Make a copy to isolate it from the object passed in\n              domain = Object.assign({}, domain);\n              // Allow passing null to ignore value\n              for (key in domain) {\n                if (domain[key] == null) {\n                  delete domain[key];\n                }\n              }\n              // Look up all ENS names\n              ensCache = {}; // Do we need to look up the domain's verifyingContract?\n              if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n              }\n              // We are going to use the encoder to visit all the base values\n              encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n              encoder.visit(value, function (type, value) {\n                if (type === \"address\" && !(0, index_js_4.isHexString)(value, 20)) {\n                  ensCache[value] = \"0x\";\n                }\n                return value;\n              });\n              // Lookup each name\n              _context.t0 = _regeneratorRuntime().keys(ensCache);\n            case 7:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 14;\n                break;\n              }\n              name = _context.t1.value;\n              _context.next = 11;\n              return resolveName(name);\n            case 11:\n              ensCache[name] = _context.sent;\n              _context.next = 7;\n              break;\n            case 14:\n              // Replace the domain verifyingContract if needed\n              if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n              }\n              // Replace all ENS names with their address\n              value = encoder.visit(value, function (type, value) {\n                if (type === \"address\" && ensCache[value]) {\n                  return ensCache[value];\n                }\n                return value;\n              });\n              return _context.abrupt(\"return\", {\n                domain: domain,\n                value: value\n              });\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function resolveNames(_x, _x2, _x3, _x4) {\n        return _resolveNames.apply(this, arguments);\n      }\n      return resolveNames;\n    }()\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n  }, {\n    key: \"getPayload\",\n    value: function getPayload(domain, types, value) {\n      // Validate the domain fields\n      TypedDataEncoder.hashDomain(domain);\n      // Derive the EIP712Domain Struct reference type\n      var domainValues = {};\n      var domainTypes = [];\n      domainFieldNames.forEach(function (name) {\n        var value = domain[name];\n        if (value == null) {\n          return;\n        }\n        domainValues[name] = domainChecks[name](value);\n        domainTypes.push({\n          name: name,\n          type: domainFieldTypes[name]\n        });\n      });\n      var encoder = TypedDataEncoder.from(types);\n      var typesWithDomain = Object.assign({}, types);\n      (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n      typesWithDomain.EIP712Domain = domainTypes;\n      // Validate the data structures and types\n      encoder.encode(value);\n      return {\n        types: typesWithDomain,\n        domain: domainValues,\n        primaryType: encoder.primaryType,\n        message: encoder.visit(value, function (type, value) {\n          // bytes\n          if (type.match(/^bytes(\\d*)/)) {\n            return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));\n          }\n          // uint or int\n          if (type.match(/^u?int/)) {\n            return (0, index_js_4.getBigInt)(value).toString();\n          }\n          switch (type) {\n            case \"address\":\n              return value.toLowerCase();\n            case \"bool\":\n              return !!value;\n            case \"string\":\n              (0, index_js_4.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n              return value;\n          }\n          (0, index_js_4.assertArgument)(false, \"unsupported type\", \"type\", type);\n        })\n      };\n    }\n  }]);\n  return TypedDataEncoder;\n}();\nfunction _getEncoder2(type) {\n  var _this2 = this;\n  // Basic encoder type (address, bool, uint256, etc)\n  {\n    var encoder = getBaseEncoder(type);\n    if (encoder) {\n      return encoder;\n    }\n  }\n  // Array\n  var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n  if (match) {\n    var subtype = match[1];\n    var subEncoder = this.getEncoder(subtype);\n    return function (value) {\n      (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, \"array length mismatch; expected length \".concat(parseInt(match[3])), \"value\", value);\n      var result = value.map(subEncoder);\n      if (_classPrivateFieldGet(_this2, _fullTypes).has(subtype)) {\n        result = result.map(index_js_2.keccak256);\n      }\n      return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));\n    };\n  }\n  // Struct\n  var fields = this.types[type];\n  if (fields) {\n    var encodedType = (0, id_js_1.id)(_classPrivateFieldGet(this, _fullTypes).get(type));\n    return function (value) {\n      var values = fields.map(function (_ref3) {\n        var name = _ref3.name,\n          type = _ref3.type;\n        var result = _this2.getEncoder(type)(value[name]);\n        if (_classPrivateFieldGet(_this2, _fullTypes).has(type)) {\n          return (0, index_js_2.keccak256)(result);\n        }\n        return result;\n      });\n      values.unshift(encodedType);\n      return (0, index_js_4.concat)(values);\n    };\n  }\n  (0, index_js_4.assertArgument)(false, \"unknown type: \".concat(type), \"type\", type);\n}\nexports.TypedDataEncoder = TypedDataEncoder;\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction verifyTypedData(domain, types, value, signature) {\n  return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n}\nexports.verifyTypedData = verifyTypedData;","map":{"version":3,"names":["index_js_1","require","index_js_2","index_js_3","index_js_4","id_js_1","padding","Uint8Array","fill","BN__1","BigInt","BN_0","BN_1","BN_MAX_UINT256","hexPadRight","value","bytes","getBytes","padOffset","length","concat","slice","hexlify","hexTrue","toBeHex","hexFalse","domainFieldTypes","name","version","chainId","verifyingContract","salt","domainFieldNames","checkString","key","assertArgument","JSON","stringify","domainChecks","_value","getBigInt","Number","isSafeInteger","toQuantity","getAddress","toLowerCase","error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","toTwos","zeroPadValue","keccak256","id","encodeType","fields","map","_ref","join","_types","WeakMap","_fullTypes","_encoderCache","_getEncoder","WeakSet","TypedDataEncoder","types","_classCallCheck","_classPrivateMethodInitSpec","_defineProperty","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","Map","links","parents","subtypes","Object","keys","forEach","set","Set","uniqueNames","_iterator","_createForOfIteratorHelper","_step","s","n","done","field","has","add","baseType","encoder","get","push","err","e","f","primaryTypes","Array","from","filter","t","defineProperties","primaryType","checkCircular","found","_iterator2","_step2","child","_iterator3","_step3","subtype","delete","_iterator4","_step4","_step4$value","_slicedToArray","st","sort","_classPrivateFieldGet","_createClass","parse","getEncoder","_classPrivateMethodGet","_getEncoder2","call","result","encodeData","hashStruct","encode","hash","_visit","callback","_this","v","reduce","accum","_ref2","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","_resolveNames","_asyncToGenerator","_regeneratorRuntime","mark","_callee","resolveName","ensCache","wrap","_callee$","_context","prev","next","assign","isHexString","t0","t1","sent","abrupt","stop","resolveNames","_x","_x2","_x3","_x4","apply","arguments","getPayload","domainValues","domainTypes","typesWithDomain","message","toString","_this2","subEncoder","encodedType","values","_ref3","unshift","exports","verifyTypedData","signature","recoverAddress"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/hash/typed-data.ts"],"sourcesContent":["//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport {\n    concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue,\n    assertArgument\n} from \"../utils/index.js\";\n\nimport { id } from \"./id.js\";\n\nimport type { SignatureLike } from \"../crypto/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n// @TODO: in v7, verifyingContract should be an AddressLike and use resolveAddress\n\n/**\n *  The domain for an [[link-eip-712]] payload.\n */\nexport interface TypedDataDomain {\n    /**\n     *  The human-readable name of the signing domain.\n     */\n    name?: null | string;\n\n    /**\n     *  The major version of the signing domain.\n     */\n    version?: null | string;\n\n    /**\n     *  The chain ID of the signing domain.\n     */\n    chainId?: null | BigNumberish;\n\n    /**\n     *  The the address of the contract that will verify the signature.\n     */\n    verifyingContract?: null | string;\n\n    /**\n     *  A salt used for purposes decided by the specific domain.\n     */\n    salt?: null | BytesLike;\n};\n\n/**\n *  A specific field of a structured [[link-eip-712]] type.\n */\nexport interface TypedDataField {\n    /**\n     *  The field name.\n     */\n    name: string;\n\n    /**\n     *  The type of the field.\n     */\n    type: string;\n};\n\nfunction hexPadRight(value: BytesLike): string {\n    const bytes = getBytes(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return concat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        assertArgument(typeof(value) === \"string\", `invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value: any) {\n        const value = getBigInt(_value, \"domain.chainId\");\n        assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) { return Number(value); }\n        return toQuantity(value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        const bytes = getBytes(value, \"domain.salt\");\n        assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return hexlify(bytes);\n    }\n}\n\nfunction getBaseEncoder(type: string): null | ((value: any) => string) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1): width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1): BN_0;\n\n            return function(_value: BigNumberish) {\n                const value = getBigInt(_value, \"value\");\n\n                assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${ type }`, \"value\", value);\n\n                return toBeHex(signed ? toTwos(value, 256): value, 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n\n            return function(value: BytesLike) {\n                const bytes = getBytes(value);\n                assertArgument(bytes.length === width, `invalid length for ${ type }`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return zeroPadValue(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nexport class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    readonly primaryType!: string;\n\n    readonly #types: string;\n\n    /**\n     *  The types.\n     */\n    get types(): Record<string, Array<TypedDataField>> {\n        return JSON.parse(this.#types);\n    }\n\n    readonly #fullTypes: Map<string, string>\n\n    readonly #encoderCache: Map<string, (value: any) => string>;\n\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n\n        // Link struct types to their direct child structs\n        const links: Map<string, Set<string>> = new Map();\n\n        // Link structs to structs which contain them as a child\n        const parents: Map<string, Array<string>> = new Map();\n\n        // Link all subtypes within a given struct\n        const subtypes: Map<string, Set<string>> = new Map();\n\n        Object.keys(types).forEach((type) => {\n            links.set(type, new Set());\n            parents.set(type, [ ]);\n            subtypes.set(type, new Set());\n        });\n\n        for (const name in types) {\n            const uniqueNames: Set<string> = new Set();\n\n            for (const field of types[name]) {\n\n                // Check each field has a unique name\n                assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                uniqueNames.add(field.name);\n\n                // Get the base type (drop any array specifiers)\n                const baseType = (<any>(field.type.match(/^([^\\x5b]*)(\\x5b|$)/)))[1] || null;\n                assertArgument(baseType !== name, `circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { continue; }\n\n                assertArgument(parents.has(baseType), `unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n\n                // Add linkage\n                (parents.get(baseType) as Array<string>).push(name);\n                (links.get(name) as Set<string>).add(baseType);\n            }\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => ((parents.get(n) as Array<string>).length === 0));\n        assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n\n        defineProperties<TypedDataEncoder>(this, { primaryType: primaryTypes[0] });\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Set<string>) {\n            assertArgument(!found.has(type), `circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n\n            found.add(type);\n\n            for (const child of (links.get(type) as Set<string>)) {\n                if (!parents.has(child)) { continue; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    (subtypes.get(subtype) as Set<string>).add(child);\n                }\n            }\n\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n\n        // Compute each fully describe type\n        for (const [ name, set ] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n\n    #getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value: Array<any>) => {\n                assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${ parseInt(match[3]) }`, \"value\", value);\n\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(concat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this.#fullTypes.get(type) as string);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return concat(values);\n            }\n        }\n\n        assertArgument(false, `unknown type: ${ type }`, \"type\", type);\n    }\n\n    /**\n     *  Return the full type for %%name%%.\n     */\n    encodeType(name: string): string {\n        const result = this.#fullTypes.get(name);\n        assertArgument(result, `unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        return result;\n    }\n\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${ parseInt(match[3]) }`, \"value\", value);\n            return value.map((v: any) => this._visit(match[1], v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        assertArgument(false, `unknown type: ${ type }`, \"type\", type);\n    }\n\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    /**\n     *  Return the primary type for %%types%%.\n     */\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            if ((<Record<string, any>>domain)[name] == null) { continue; }\n            const type = domainFieldTypes[name];\n            assertArgument(type, `invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return concat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({ }, domain);\n\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if ((<Record<string, any>>domain)[key] == null) {\n                delete (<Record<string, any>>domain)[key];\n            }\n        }\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = Object.assign({ }, types);\n        assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n\n        typesWithDomain.EIP712Domain = domainTypes;\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(getBytes(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return getBigInt(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        assertArgument(typeof(value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n\n                assertArgument(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}