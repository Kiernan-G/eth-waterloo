{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mnemonic = void 0;\nvar index_js_1 = require(\"../crypto/index.js\");\nvar index_js_2 = require(\"../utils/index.js\");\nvar lang_en_js_1 = require(\"../wordlists/lang-en.js\");\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1 & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  (0, index_js_2.assertNormalize)(\"NFKD\");\n  if (wordlist == null) {\n    wordlist = lang_en_js_1.LangEn.wordlist();\n  }\n  var words = wordlist.split(mnemonic);\n  (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n  var entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n  var offset = 0;\n  for (var i = 0; i < words.length; i++) {\n    var index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n    (0, index_js_2.assertArgument)(index >= 0, \"invalid mnemonic word at index \".concat(i), \"mnemonic\", \"[ REDACTED ]\");\n    for (var bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n      offset++;\n    }\n  }\n  var entropyBits = 32 * words.length / 3;\n  var checksumBits = words.length / 3;\n  var checksumMask = getUpperMask(checksumBits);\n  var checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n  return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n  (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n  if (wordlist == null) {\n    wordlist = lang_en_js_1.LangEn.wordlist();\n  }\n  var indices = [0];\n  var remainingBits = 11;\n  for (var i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  }\n  // Compute the checksum bits\n  var checksumBits = entropy.length / 4;\n  var checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(function (index) {\n    return wordlist.getWord(index);\n  }));\n}\nvar _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nvar Mnemonic = /*#__PURE__*/function () {\n  /**\n   *  @private\n   */\n  function Mnemonic(guard, entropy, phrase, password, wordlist) {\n    _classCallCheck(this, Mnemonic);\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    _defineProperty(this, \"phrase\", void 0);\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    _defineProperty(this, \"password\", void 0);\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    _defineProperty(this, \"wordlist\", void 0);\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    _defineProperty(this, \"entropy\", void 0);\n    if (password == null) {\n      password = \"\";\n    }\n    if (wordlist == null) {\n      wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    (0, index_js_2.assertPrivate)(guard, _guard, \"Mnemonic\");\n    (0, index_js_2.defineProperties)(this, {\n      phrase: phrase,\n      password: password,\n      wordlist: wordlist,\n      entropy: entropy\n    });\n  }\n  /**\n   *  Returns the seed for the mnemonic.\n   */\n  _createClass(Mnemonic, [{\n    key: \"computeSeed\",\n    value: function computeSeed() {\n      var salt = (0, index_js_2.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n      return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n  }], [{\n    key: \"fromPhrase\",\n    value: function fromPhrase(phrase, password, wordlist) {\n      // Normalize the case and space; throws if invalid\n      var entropy = mnemonicToEntropy(phrase, wordlist);\n      phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);\n      return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n  }, {\n    key: \"fromEntropy\",\n    value: function fromEntropy(_entropy, password, wordlist) {\n      var entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n      var phrase = entropyToMnemonic(entropy, wordlist);\n      return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n  }, {\n    key: \"entropyToPhrase\",\n    value: function entropyToPhrase(_entropy, wordlist) {\n      var entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n      return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n  }, {\n    key: \"phraseToEntropy\",\n    value: function phraseToEntropy(phrase, wordlist) {\n      return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n  }, {\n    key: \"isValidMnemonic\",\n    value: function isValidMnemonic(phrase, wordlist) {\n      try {\n        mnemonicToEntropy(phrase, wordlist);\n        return true;\n      } catch (error) {}\n      return false;\n    }\n  }]);\n  return Mnemonic;\n}();\nexports.Mnemonic = Mnemonic;","map":{"version":3,"names":["index_js_1","require","index_js_2","lang_en_js_1","getUpperMask","bits","getLowerMask","mnemonicToEntropy","mnemonic","wordlist","assertNormalize","LangEn","words","split","assertArgument","length","entropy","Uint8Array","Math","ceil","offset","i","index","getWordIndex","normalize","concat","bit","entropyBits","checksumBits","checksumMask","checksum","getBytes","sha256","slice","hexlify","entropyToMnemonic","indices","remainingBits","push","parseInt","substring","join","map","getWord","_guard","Mnemonic","guard","phrase","password","_classCallCheck","_defineProperty","assertPrivate","defineProperties","_createClass","key","value","computeSeed","salt","toUtf8Bytes","pbkdf2","fromPhrase","fromEntropy","_entropy","entropyToPhrase","phraseToEntropy","isValidMnemonic","error","exports"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/wallet/mnemonic.ts"],"sourcesContent":["import { pbkdf2, sha256 } from \"../crypto/index.js\";\nimport {\n    defineProperties, getBytes, hexlify, assertNormalize, assertPrivate, assertArgument, toUtf8Bytes\n} from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\nimport type { Wordlist } from \"../wordlists/index.js\";\n\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits) & 0xff;\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return ((1 << bits) - 1) & 0xff;\n}\n\n\nfunction mnemonicToEntropy(mnemonic: string, wordlist?: null | Wordlist): string {\n    assertNormalize(\"NFKD\");\n\n    if (wordlist == null) { wordlist = LangEn.wordlist(); }\n\n    const words = wordlist.split(mnemonic);\n    assertArgument((words.length % 3) === 0 && words.length >= 12 && words.length <= 24,\n        \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        assertArgument(index >= 0, `invalid mnemonic word at index ${ i }`, \"mnemonic\", \"[ REDACTED ]\");\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask),\n        \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nfunction entropyToMnemonic(entropy: Uint8Array, wordlist?: null | Wordlist): string {\n\n    assertArgument((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32,\n        \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n\n    if (wordlist == null) { wordlist = LangEn.wordlist(); }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nconst _guard = { };\n\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nexport class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    readonly phrase!: string;\n\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    readonly password!: string;\n\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    readonly wordlist!: Wordlist;\n\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    readonly entropy!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, entropy: string, phrase: string, password?: null | string, wordlist?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (wordlist == null) { wordlist = LangEn.wordlist(); }\n        assertPrivate(guard, _guard, \"Mnemonic\");\n        defineProperties<Mnemonic>(this, { phrase, password, wordlist, entropy });\n    }\n\n    /**\n     *  Returns the seed for the mnemonic.\n     */\n    computeSeed(): string {\n        const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\");\n        return pbkdf2(toUtf8Bytes(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromPhrase(phrase: string, password?: null | string, wordlist?: null | Wordlist): Mnemonic {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic(getBytes(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromEntropy(_entropy: BytesLike, password?: null | string, wordlist?: null | Wordlist): Mnemonic {\n        const entropy = getBytes(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\n    }\n\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n    static entropyToPhrase(_entropy: BytesLike, wordlist?: null | Wordlist): string {\n        const entropy = getBytes(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n    static phraseToEntropy(phrase: string, wordlist?: null | Wordlist): string {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n    static isValidMnemonic(phrase: string, wordlist?: null | Wordlist): boolean {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        } catch (error) { }\n        return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}