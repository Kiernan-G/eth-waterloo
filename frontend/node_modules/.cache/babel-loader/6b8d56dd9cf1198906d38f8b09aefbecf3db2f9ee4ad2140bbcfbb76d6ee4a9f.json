{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractFactory = void 0;\nconst index_js_1 = require(\"../abi/index.js\");\nconst index_js_2 = require(\"../address/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst contract_js_1 = require(\"./contract.js\");\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nclass ContractFactory {\n  /**\n   *  The Contract Interface.\n   */\n  interface;\n  /**\n   *  The Contract deployment bytecode. Often called the initcode.\n   */\n  bytecode;\n  /**\n   *  The ContractRunner to deploy the Contract as.\n   */\n  runner;\n  /**\n   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n   *  optionally connected to %%runner%%.\n   *\n   *  The %%bytecode%% may be the ``bytecode`` property within the\n   *  standard Solidity JSON output.\n   */\n  constructor(abi, bytecode, runner) {\n    const iface = index_js_1.Interface.from(abi);\n    // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n    if (bytecode instanceof Uint8Array) {\n      bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n    } else {\n      if (typeof bytecode === \"object\") {\n        bytecode = bytecode.object;\n      }\n      if (!bytecode.startsWith(\"0x\")) {\n        bytecode = \"0x\" + bytecode;\n      }\n      bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n    }\n    (0, index_js_3.defineProperties)(this, {\n      bytecode,\n      interface: iface,\n      runner: runner || null\n    });\n  }\n  attach(target) {\n    return new contract_js_1.BaseContract(target, this.interface, this.runner);\n  }\n  /**\n   *  Resolves to the transaction to deploy the contract, passing %%args%%\n   *  into the constructor.\n   */\n  async getDeployTransaction() {\n    let overrides = {};\n    const fragment = this.interface.deploy;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await (0, contract_js_1.copyOverrides)(args.pop());\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"incorrect number of arguments to constructor\");\n    }\n    const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);\n    const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n    return Object.assign({}, overrides, {\n      data\n    });\n  }\n  /**\n   *  Resolves to the Contract deployed by passing %%args%% into the\n   *  constructor.\n   *\n   *  This will resovle to the Contract before it has been deployed to the\n   *  network, so the [[BaseContract-waitForDeployment]] should be used before\n   *  sending any transactions to it.\n   */\n  async deploy() {\n    const tx = await this.getDeployTransaction(...arguments);\n    (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const sentTx = await this.runner.sendTransaction(tx);\n    const address = (0, index_js_2.getCreateAddress)(sentTx);\n    return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);\n  }\n  /**\n   *  Return a new **ContractFactory** with the same ABI and bytecode,\n   *  but connected to %%runner%%.\n   */\n  connect(runner) {\n    return new ContractFactory(this.interface, this.bytecode, runner);\n  }\n  /**\n   *  Create a new **ContractFactory** from the standard Solidity JSON output.\n   */\n  static fromSolidity(output, runner) {\n    (0, index_js_3.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n    if (typeof output === \"string\") {\n      output = JSON.parse(output);\n    }\n    const abi = output.abi;\n    let bytecode = \"\";\n    if (output.bytecode) {\n      bytecode = output.bytecode;\n    } else if (output.evm && output.evm.bytecode) {\n      bytecode = output.evm.bytecode;\n    }\n    return new this(abi, bytecode, runner);\n  }\n}\nexports.ContractFactory = ContractFactory;","map":{"version":3,"names":["index_js_1","require","index_js_2","index_js_3","contract_js_1","ContractFactory","interface","bytecode","runner","constructor","abi","iface","Interface","from","Uint8Array","hexlify","getBytes","object","startsWith","defineProperties","attach","target","BaseContract","getDeployTransaction","overrides","fragment","deploy","_len","arguments","length","args","Array","_key","inputs","copyOverrides","pop","Error","resolvedArgs","resolveArgs","data","concat","encodeDeploy","Object","assign","tx","assert","sendTransaction","operation","sentTx","address","getCreateAddress","connect","fromSolidity","output","assertArgument","JSON","parse","evm","exports"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/contract/factory.ts"],"sourcesContent":["\nimport { Interface } from \"../abi/index.js\";\nimport { getCreateAddress } from \"../address/index.js\";\nimport {\n    concat, defineProperties, getBytes, hexlify,\n    assert, assertArgument\n} from \"../utils/index.js\";\n\nimport { BaseContract, copyOverrides, resolveArgs } from \"./contract.js\";\n\nimport type { InterfaceAbi } from \"../abi/index.js\";\nimport type { Addressable } from \"../address/index.js\";\nimport type { ContractRunner } from \"../providers/index.js\";\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport type {\n    ContractInterface, ContractMethodArgs, ContractDeployTransaction,\n} from \"./types.js\";\nimport type { ContractTransactionResponse } from \"./wrappers.js\";\n\n\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nexport class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> {\n\n    /**\n     *  The Contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    readonly bytecode!: string;\n\n    /**\n     *  The ContractRunner to deploy the Contract as.\n     */\n    readonly runner!: null | ContractRunner;\n\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */\n    constructor(abi: Interface | InterfaceAbi, bytecode: BytesLike | { object: string }, runner?: null | ContractRunner) {\n        const iface = Interface.from(abi);\n\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = hexlify(getBytes(bytecode));\n        } else {\n            if (typeof(bytecode) === \"object\") { bytecode = bytecode.object; }\n            if (!bytecode.startsWith(\"0x\")) { bytecode = \"0x\" + bytecode; }\n            bytecode = hexlify(getBytes(bytecode));\n        }\n\n        defineProperties<ContractFactory>(this, {\n            bytecode, interface: iface, runner: (runner || null)\n        });\n    }\n\n    attach(target: string | Addressable): BaseContract & Omit<I, keyof BaseContract> {\n        return new (<any>BaseContract)(target, this.interface, this.runner);\n    }\n\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */\n    async getDeployTransaction(...args: ContractMethodArgs<A>): Promise<ContractDeployTransaction> {\n        let overrides: Omit<ContractDeployTransaction, \"data\"> = { };\n\n        const fragment = this.interface.deploy;\n\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n\n        const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);\n\n        const data = concat([ this.bytecode, this.interface.encodeDeploy(resolvedArgs) ]);\n        return Object.assign({ }, overrides, { data });\n    }\n\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resovle to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */\n    async deploy(...args: ContractMethodArgs<A>): Promise<BaseContract & { deploymentTransaction(): ContractTransactionResponse } & Omit<I, keyof BaseContract>> {\n        const tx = await this.getDeployTransaction(...args);\n\n        assert(this.runner && typeof(this.runner.sendTransaction) === \"function\",\n            \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\" });\n\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = getCreateAddress(sentTx);\n        return new (<any>BaseContract)(address, this.interface, this.runner, sentTx);\n    }\n\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */\n    connect(runner: null | ContractRunner): ContractFactory<A, I> {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */\n    static fromSolidity<A extends Array<any> = Array<any>, I = ContractInterface>(output: any, runner?: ContractRunner): ContractFactory<A, I> {\n        assertArgument(output != null, \"bad compiler output\", \"output\", output);\n\n        if (typeof(output) === \"string\") { output = JSON.parse(output); }\n\n        const abi = output.abi;\n\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        } else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, runner);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}