{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _Symbol$iterator, _Symbol$iterator2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction the each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retreive the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentcation, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nvar base64_js_1 = require(\"./base64.js\");\nvar data_js_1 = require(\"./data.js\");\nvar errors_js_1 = require(\"./errors.js\");\nvar properties_js_1 = require(\"./properties.js\");\nvar utf8_js_1 = require(\"./utf8.js\");\nvar geturl_js_1 = require(\"./geturl.js\");\nvar MAX_ATTEMPTS = 12;\nvar SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nvar getUrlFunc = geturl_js_1.getUrl;\nvar reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nvar reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nvar locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nfunction dataGatewayFunc(_x, _x2) {\n  return _dataGatewayFunc.apply(this, arguments);\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction _dataGatewayFunc() {\n  _dataGatewayFunc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, signal) {\n    var match;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          match = url.match(reData);\n          if (match) {\n            _context2.next = 4;\n            break;\n          }\n          throw new Error(\"invalid data\");\n        case 4:\n          return _context2.abrupt(\"return\", new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n          }, match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3])));\n        case 7:\n          _context2.prev = 7;\n          _context2.t0 = _context2[\"catch\"](0);\n          return _context2.abrupt(\"return\", new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url)));\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[0, 7]]);\n  }));\n  return _dataGatewayFunc.apply(this, arguments);\n}\nfunction getIpfsGatewayFunc(baseUrl) {\n  function gatewayIpfs(_x3, _x4) {\n    return _gatewayIpfs.apply(this, arguments);\n  }\n  function _gatewayIpfs() {\n    _gatewayIpfs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, signal) {\n      var match;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            match = url.match(reIpfs);\n            if (match) {\n              _context.next = 4;\n              break;\n            }\n            throw new Error(\"invalid link\");\n          case 4:\n            return _context.abrupt(\"return\", new FetchRequest(\"\".concat(baseUrl).concat(match[2])));\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url)));\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return _gatewayIpfs.apply(this, arguments);\n  }\n  return gatewayIpfs;\n}\nvar Gateways = {\n  \"data\": dataGatewayFunc,\n  \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nvar fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nvar _listeners = /*#__PURE__*/new WeakMap();\nvar _cancelled = /*#__PURE__*/new WeakMap();\nvar FetchCancelSignal = /*#__PURE__*/function () {\n  function FetchCancelSignal(request) {\n    var _this = this;\n    _classCallCheck(this, FetchCancelSignal);\n    _classPrivateFieldInitSpec(this, _listeners, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _cancelled, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _listeners, []);\n    _classPrivateFieldSet(this, _cancelled, false);\n    fetchSignals.set(request, function () {\n      if (_classPrivateFieldGet(_this, _cancelled)) {\n        return;\n      }\n      _classPrivateFieldSet(_this, _cancelled, true);\n      var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(_this, _listeners)),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var listener = _step.value;\n          setTimeout(function () {\n            listener();\n          }, 0);\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      _classPrivateFieldSet(_this, _listeners, []);\n    });\n  }\n  _createClass(FetchCancelSignal, [{\n    key: \"addListener\",\n    value: function addListener(listener) {\n      (0, errors_js_1.assert)(!_classPrivateFieldGet(this, _cancelled), \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fetchCancelSignal.addCancelListener\"\n      });\n      _classPrivateFieldGet(this, _listeners).push(listener);\n    }\n  }, {\n    key: \"cancelled\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _cancelled);\n    }\n  }, {\n    key: \"checkSignal\",\n    value: function checkSignal() {\n      (0, errors_js_1.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n  }]);\n  return FetchCancelSignal;\n}();\nexports.FetchCancelSignal = FetchCancelSignal;\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n  if (signal == null) {\n    throw new Error(\"missing signal; should not happen\");\n  }\n  signal.checkSignal();\n  return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nvar _allowInsecure = /*#__PURE__*/new WeakMap();\nvar _gzip = /*#__PURE__*/new WeakMap();\nvar _headers = /*#__PURE__*/new WeakMap();\nvar _method = /*#__PURE__*/new WeakMap();\nvar _timeout = /*#__PURE__*/new WeakMap();\nvar _url = /*#__PURE__*/new WeakMap();\nvar _body = /*#__PURE__*/new WeakMap();\nvar _bodyType = /*#__PURE__*/new WeakMap();\nvar _creds = /*#__PURE__*/new WeakMap();\nvar _preflight = /*#__PURE__*/new WeakMap();\nvar _process = /*#__PURE__*/new WeakMap();\nvar _retry = /*#__PURE__*/new WeakMap();\nvar _signal = /*#__PURE__*/new WeakMap();\nvar _throttle = /*#__PURE__*/new WeakMap();\nvar _send = /*#__PURE__*/new WeakSet();\n_Symbol$iterator = Symbol.iterator;\nvar FetchRequest = /*#__PURE__*/function () {\n  /**\n   *  Create a new FetchRequest instance with default values.\n   *\n   *  Once created, each property may be set before issuing a\n   *  ``.send()`` to make the request.\n   */\n  function FetchRequest(url) {\n    _classCallCheck(this, FetchRequest);\n    _classPrivateMethodInitSpec(this, _send);\n    _classPrivateFieldInitSpec(this, _allowInsecure, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _gzip, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _headers, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _method, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _timeout, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _url, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _body, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _bodyType, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _creds, {\n      writable: true,\n      value: void 0\n    });\n    // Hooks\n    _classPrivateFieldInitSpec(this, _preflight, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _process, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _retry, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _signal, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _throttle, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _url, String(url));\n    _classPrivateFieldSet(this, _allowInsecure, false);\n    _classPrivateFieldSet(this, _gzip, true);\n    _classPrivateFieldSet(this, _headers, {});\n    _classPrivateFieldSet(this, _method, \"\");\n    _classPrivateFieldSet(this, _timeout, 300000);\n    _classPrivateFieldSet(this, _throttle, {\n      slotInterval: SLOT_INTERVAL,\n      maxAttempts: MAX_ATTEMPTS\n    });\n  }\n  _createClass(FetchRequest, [{\n    key: \"url\",\n    get:\n    /**\n     *  The fetch URI to requrest.\n     */\n    function get() {\n      return _classPrivateFieldGet(this, _url);\n    },\n    set: function set(url) {\n      _classPrivateFieldSet(this, _url, String(url));\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``) and the .\n     *\n     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrincis ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n  }, {\n    key: \"body\",\n    get: function get() {\n      if (_classPrivateFieldGet(this, _body) == null) {\n        return null;\n      }\n      return new Uint8Array(_classPrivateFieldGet(this, _body));\n    },\n    set: function set(body) {\n      if (body == null) {\n        _classPrivateFieldSet(this, _body, undefined);\n        _classPrivateFieldSet(this, _bodyType, undefined);\n      } else if (typeof body === \"string\") {\n        _classPrivateFieldSet(this, _body, (0, utf8_js_1.toUtf8Bytes)(body));\n        _classPrivateFieldSet(this, _bodyType, \"text/plain\");\n      } else if (body instanceof Uint8Array) {\n        _classPrivateFieldSet(this, _body, body);\n        _classPrivateFieldSet(this, _bodyType, \"application/octet-stream\");\n      } else if (typeof body === \"object\") {\n        _classPrivateFieldSet(this, _body, (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body)));\n        _classPrivateFieldSet(this, _bodyType, \"application/json\");\n      } else {\n        throw new Error(\"invalid body\");\n      }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */\n  }, {\n    key: \"hasBody\",\n    value: function hasBody() {\n      return _classPrivateFieldGet(this, _body) != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n  }, {\n    key: \"method\",\n    get: function get() {\n      if (_classPrivateFieldGet(this, _method)) {\n        return _classPrivateFieldGet(this, _method);\n      }\n      if (this.hasBody()) {\n        return \"POST\";\n      }\n      return \"GET\";\n    },\n    set: function set(method) {\n      if (method == null) {\n        method = \"\";\n      }\n      _classPrivateFieldSet(this, _method, String(method).toUpperCase());\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any chnages will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n  }, {\n    key: \"headers\",\n    get: function get() {\n      var headers = Object.assign({}, _classPrivateFieldGet(this, _headers));\n      if (_classPrivateFieldGet(this, _creds)) {\n        headers[\"authorization\"] = \"Basic \".concat((0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(_classPrivateFieldGet(this, _creds))));\n      }\n      ;\n      if (this.allowGzip) {\n        headers[\"accept-encoding\"] = \"gzip\";\n      }\n      if (headers[\"content-type\"] == null && _classPrivateFieldGet(this, _bodyType)) {\n        headers[\"content-type\"] = _classPrivateFieldGet(this, _bodyType);\n      }\n      if (this.body) {\n        headers[\"content-length\"] = String(this.body.length);\n      }\n      return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(key) {\n      return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(key, value) {\n      _classPrivateFieldGet(this, _headers)[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n  }, {\n    key: \"clearHeaders\",\n    value: function clearHeaders() {\n      _classPrivateFieldSet(this, _headers, {});\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      var headers = this.headers;\n      var keys = Object.keys(headers);\n      var index = 0;\n      return {\n        next: function next() {\n          if (index < keys.length) {\n            var key = keys[index++];\n            return {\n              value: [key, headers[key]],\n              done: false\n            };\n          }\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n  }, {\n    key: \"credentials\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _creds) || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n  }, {\n    key: \"setCredentials\",\n    value: function setCredentials(username, password) {\n      (0, errors_js_1.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n      _classPrivateFieldSet(this, _creds, \"\".concat(username, \":\").concat(password));\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n  }, {\n    key: \"allowGzip\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _gzip);\n    }\n  }, {\n    key: \"allowGzip\",\n    set: function set(value) {\n      _classPrivateFieldSet(this, _gzip, !!value);\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n  }, {\n    key: \"allowInsecureAuthentication\",\n    get: function get() {\n      return !!_classPrivateFieldGet(this, _allowInsecure);\n    }\n  }, {\n    key: \"allowInsecureAuthentication\",\n    set: function set(value) {\n      _classPrivateFieldSet(this, _allowInsecure, !!value);\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complere response.\n     *  //(default: 5 minutes)//\n     */\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _timeout);\n    }\n  }, {\n    key: \"timeout\",\n    set: function set(timeout) {\n      (0, errors_js_1.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n      _classPrivateFieldSet(this, _timeout, timeout);\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n  }, {\n    key: \"preflightFunc\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _preflight) || null;\n    }\n  }, {\n    key: \"preflightFunc\",\n    set: function set(preflight) {\n      _classPrivateFieldSet(this, _preflight, preflight);\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n  }, {\n    key: \"processFunc\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _process) || null;\n    }\n  }, {\n    key: \"processFunc\",\n    set: function set(process) {\n      _classPrivateFieldSet(this, _process, process);\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */\n  }, {\n    key: \"retryFunc\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _retry) || null;\n    }\n  }, {\n    key: \"retryFunc\",\n    set: function set(retry) {\n      _classPrivateFieldSet(this, _retry, retry);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<FetchRequest method=\".concat(JSON.stringify(this.method), \" url=\").concat(JSON.stringify(this.url), \" headers=\").concat(JSON.stringify(this.headers), \" body=\").concat(_classPrivateFieldGet(this, _body) ? (0, data_js_1.hexlify)(_classPrivateFieldGet(this, _body)) : \"null\", \">\");\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n  }, {\n    key: \"setThrottleParams\",\n    value: function setThrottleParams(params) {\n      if (params.slotInterval != null) {\n        _classPrivateFieldGet(this, _throttle).slotInterval = params.slotInterval;\n      }\n      if (params.maxAttempts != null) {\n        _classPrivateFieldGet(this, _throttle).maxAttempts = params.maxAttempts;\n      }\n    }\n  }, {\n    key: \"send\",\n    value:\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    function send() {\n      (0, errors_js_1.assert)(_classPrivateFieldGet(this, _signal) == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fetchRequest.send\"\n      });\n      _classPrivateFieldSet(this, _signal, new FetchCancelSignal(this));\n      return _classPrivateMethodGet(this, _send, _send2).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      (0, errors_js_1.assert)(_classPrivateFieldGet(this, _signal) != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fetchRequest.cancel\"\n      });\n      var signal = fetchSignals.get(this);\n      if (!signal) {\n        throw new Error(\"missing signal; should not happen\");\n      }\n      signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n  }, {\n    key: \"redirect\",\n    value: function redirect(location) {\n      // Redirection; for now we only support absolute locataions\n      var current = this.url.split(\":\")[0].toLowerCase();\n      var target = location.split(\":\")[0].toLowerCase();\n      // Don't allow redirecting:\n      // - non-GET requests\n      // - downgrading the security (e.g. https => http)\n      // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n      (0, errors_js_1.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), \"unsupported redirect\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"redirect(\".concat(this.method, \" \").concat(JSON.stringify(this.url), \" => \").concat(JSON.stringify(location), \")\")\n      });\n      // Create a copy of this request, with a new URL\n      var req = new FetchRequest(location);\n      req.method = \"GET\";\n      req.allowGzip = this.allowGzip;\n      req.timeout = this.timeout;\n      _classPrivateFieldSet(req, _headers, Object.assign({}, _classPrivateFieldGet(this, _headers)));\n      if (_classPrivateFieldGet(this, _body)) {\n        _classPrivateFieldSet(req, _body, new Uint8Array(_classPrivateFieldGet(this, _body)));\n      }\n      _classPrivateFieldSet(req, _bodyType, _classPrivateFieldGet(this, _bodyType));\n      // Do not forward credentials unless on the same domain; only absolute\n      //req.allowInsecure = false;\n      // paths are currently supported; may want a way to specify to forward?\n      //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n      return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new FetchRequest(this.url);\n      // Preserve \"default method\" (i.e. null)\n      _classPrivateFieldSet(clone, _method, _classPrivateFieldGet(this, _method));\n      // Preserve \"default body\" with type, copying the Uint8Array is present\n      if (_classPrivateFieldGet(this, _body)) {\n        _classPrivateFieldSet(clone, _body, _classPrivateFieldGet(this, _body));\n      }\n      _classPrivateFieldSet(clone, _bodyType, _classPrivateFieldGet(this, _bodyType));\n      // Preserve \"default headers\"\n      _classPrivateFieldSet(clone, _headers, Object.assign({}, _classPrivateFieldGet(this, _headers)));\n      // Credentials is readonly, so we copy internally\n      _classPrivateFieldSet(clone, _creds, _classPrivateFieldGet(this, _creds));\n      if (this.allowGzip) {\n        clone.allowGzip = true;\n      }\n      clone.timeout = this.timeout;\n      if (this.allowInsecureAuthentication) {\n        clone.allowInsecureAuthentication = true;\n      }\n      _classPrivateFieldSet(clone, _preflight, _classPrivateFieldGet(this, _preflight));\n      _classPrivateFieldSet(clone, _process, _classPrivateFieldGet(this, _process));\n      _classPrivateFieldSet(clone, _retry, _classPrivateFieldGet(this, _retry));\n      return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n  }], [{\n    key: \"lockConfig\",\n    value: function lockConfig() {\n      locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n  }, {\n    key: \"getGateway\",\n    value: function getGateway(scheme) {\n      return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n  }, {\n    key: \"registerGateway\",\n    value: function registerGateway(scheme, func) {\n      scheme = scheme.toLowerCase();\n      if (scheme === \"http\" || scheme === \"https\") {\n        throw new Error(\"cannot intercept \".concat(scheme, \"; use registerGetUrl\"));\n      }\n      if (locked) {\n        throw new Error(\"gateways locked\");\n      }\n      Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n  }, {\n    key: \"registerGetUrl\",\n    value: function registerGetUrl(getUrl) {\n      if (locked) {\n        throw new Error(\"gateways locked\");\n      }\n      getUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n  }, {\n    key: \"createDataGateway\",\n    value: function createDataGateway() {\n      return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n  }, {\n    key: \"createIpfsGatewayFunc\",\n    value: function createIpfsGatewayFunc(baseUrl) {\n      return getIpfsGatewayFunc(baseUrl);\n    }\n  }]);\n  return FetchRequest;\n}();\nfunction _send2(_x5, _x6, _x7, _x8, _x9) {\n  return _send3.apply(this, arguments);\n}\nfunction _send3() {\n  _send3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(attempt, expires, delay, _request, _response) {\n    var req, scheme, result, _response2, resp, response, _req$redirect, location, _req$clone, retryAfter, _delay, _req$clone2, _delay2;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!(attempt >= _classPrivateFieldGet(this, _throttle).maxAttempts)) {\n            _context3.next = 2;\n            break;\n          }\n          return _context3.abrupt(\"return\", _response.makeServerError(\"exceeded maximum retry limit\"));\n        case 2:\n          (0, errors_js_1.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\",\n            reason: \"timeout\",\n            request: _request\n          });\n          if (!(delay > 0)) {\n            _context3.next = 6;\n            break;\n          }\n          _context3.next = 6;\n          return wait(delay);\n        case 6:\n          req = this.clone();\n          scheme = (req.url.split(\":\")[0] || \"\").toLowerCase(); // Process any Gateways\n          if (!(scheme in Gateways)) {\n            _context3.next = 27;\n            break;\n          }\n          _context3.next = 11;\n          return Gateways[scheme](req.url, checkSignal(_classPrivateFieldGet(_request, _signal)));\n        case 11:\n          result = _context3.sent;\n          if (!(result instanceof FetchResponse)) {\n            _context3.next = 26;\n            break;\n          }\n          _response2 = result;\n          if (!this.processFunc) {\n            _context3.next = 25;\n            break;\n          }\n          checkSignal(_classPrivateFieldGet(_request, _signal));\n          _context3.prev = 16;\n          _context3.next = 19;\n          return this.processFunc(req, _response2);\n        case 19:\n          _response2 = _context3.sent;\n          _context3.next = 25;\n          break;\n        case 22:\n          _context3.prev = 22;\n          _context3.t0 = _context3[\"catch\"](16);\n          // Something went wrong during processing; throw a 5xx server error\n          if (_context3.t0.throttle == null || typeof _context3.t0.stall !== \"number\") {\n            _response2.makeServerError(\"error in post-processing function\", _context3.t0).assertOk();\n          }\n          // Ignore throttling\n        case 25:\n          return _context3.abrupt(\"return\", _response2);\n        case 26:\n          req = result;\n        case 27:\n          if (!this.preflightFunc) {\n            _context3.next = 31;\n            break;\n          }\n          _context3.next = 30;\n          return this.preflightFunc(req);\n        case 30:\n          req = _context3.sent;\n        case 31:\n          _context3.next = 33;\n          return getUrlFunc(req, checkSignal(_classPrivateFieldGet(_request, _signal)));\n        case 33:\n          resp = _context3.sent;\n          response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n          if (!(response.statusCode === 301 || response.statusCode === 302)) {\n            _context3.next = 46;\n            break;\n          }\n          _context3.prev = 36;\n          location = response.headers.location || \"\";\n          return _context3.abrupt(\"return\", _classPrivateMethodGet(_req$redirect = req.redirect(location), _send, _send2).call(_req$redirect, attempt + 1, expires, 0, _request, response));\n        case 41:\n          _context3.prev = 41;\n          _context3.t1 = _context3[\"catch\"](36);\n        case 43:\n          return _context3.abrupt(\"return\", response);\n        case 46:\n          if (!(response.statusCode === 429)) {\n            _context3.next = 57;\n            break;\n          }\n          _context3.t2 = this.retryFunc == null;\n          if (_context3.t2) {\n            _context3.next = 52;\n            break;\n          }\n          _context3.next = 51;\n          return this.retryFunc(req, response, attempt);\n        case 51:\n          _context3.t2 = _context3.sent;\n        case 52:\n          if (!_context3.t2) {\n            _context3.next = 57;\n            break;\n          }\n          retryAfter = response.headers[\"retry-after\"];\n          _delay = _classPrivateFieldGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n          if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n            _delay = parseInt(retryAfter);\n          }\n          return _context3.abrupt(\"return\", _classPrivateMethodGet(_req$clone = req.clone(), _send, _send2).call(_req$clone, attempt + 1, expires, _delay, _request, response));\n        case 57:\n          if (!this.processFunc) {\n            _context3.next = 72;\n            break;\n          }\n          checkSignal(_classPrivateFieldGet(_request, _signal));\n          _context3.prev = 59;\n          _context3.next = 62;\n          return this.processFunc(req, response);\n        case 62:\n          response = _context3.sent;\n          _context3.next = 72;\n          break;\n        case 65:\n          _context3.prev = 65;\n          _context3.t3 = _context3[\"catch\"](59);\n          // Something went wrong during processing; throw a 5xx server error\n          if (_context3.t3.throttle == null || typeof _context3.t3.stall !== \"number\") {\n            response.makeServerError(\"error in post-processing function\", _context3.t3).assertOk();\n          }\n          // Throttle\n          _delay2 = _classPrivateFieldGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n          ;\n          if (_context3.t3.stall >= 0) {\n            _delay2 = _context3.t3.stall;\n          }\n          return _context3.abrupt(\"return\", _classPrivateMethodGet(_req$clone2 = req.clone(), _send, _send2).call(_req$clone2, attempt + 1, expires, _delay2, _request, response));\n        case 72:\n          return _context3.abrupt(\"return\", response);\n        case 73:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, this, [[16, 22], [36, 41], [59, 65]]);\n  }));\n  return _send3.apply(this, arguments);\n}\nexports.FetchRequest = FetchRequest;\n;\n/**\n *  The response for a FetchREquest.\n */\nvar _statusCode = /*#__PURE__*/new WeakMap();\nvar _statusMessage = /*#__PURE__*/new WeakMap();\nvar _headers2 = /*#__PURE__*/new WeakMap();\nvar _body2 = /*#__PURE__*/new WeakMap();\nvar _request2 = /*#__PURE__*/new WeakMap();\nvar _error = /*#__PURE__*/new WeakMap();\n_Symbol$iterator2 = Symbol.iterator;\nvar FetchResponse = /*#__PURE__*/function () {\n  function FetchResponse(statusCode, statusMessage, headers, body, request) {\n    _classCallCheck(this, FetchResponse);\n    _classPrivateFieldInitSpec(this, _statusCode, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _statusMessage, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _headers2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _body2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _request2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _error, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _statusCode, statusCode);\n    _classPrivateFieldSet(this, _statusMessage, statusMessage);\n    _classPrivateFieldSet(this, _headers2, Object.keys(headers).reduce(function (accum, k) {\n      accum[k.toLowerCase()] = String(headers[k]);\n      return accum;\n    }, {}));\n    _classPrivateFieldSet(this, _body2, body == null ? null : new Uint8Array(body));\n    _classPrivateFieldSet(this, _request2, request || null);\n    _classPrivateFieldSet(this, _error, {\n      message: \"\"\n    });\n  }\n  /**\n   *  Return a Response with matching headers and body, but with\n   *  an error status code (i.e. 599) and %%message%% with an\n   *  optional %%error%%.\n   */\n  _createClass(FetchResponse, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"<FetchResponse status=\".concat(this.statusCode, \" body=\").concat(_classPrivateFieldGet(this, _body2) ? (0, data_js_1.hexlify)(_classPrivateFieldGet(this, _body2)) : \"null\", \">\");\n    }\n    /**\n     *  The response status code.\n     */\n  }, {\n    key: \"statusCode\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _statusCode);\n    }\n    /**\n     *  The response status message.\n     */\n  }, {\n    key: \"statusMessage\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _statusMessage);\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n  }, {\n    key: \"headers\",\n    get: function get() {\n      return Object.assign({}, _classPrivateFieldGet(this, _headers2));\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n  }, {\n    key: \"body\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _body2) == null ? null : new Uint8Array(_classPrivateFieldGet(this, _body2));\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n  }, {\n    key: \"bodyText\",\n    get: function get() {\n      try {\n        return _classPrivateFieldGet(this, _body2) == null ? \"\" : (0, utf8_js_1.toUtf8String)(_classPrivateFieldGet(this, _body2));\n      } catch (error) {\n        (0, errors_js_1.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"bodyText\",\n          info: {\n            response: this\n          }\n        });\n      }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n  }, {\n    key: \"bodyJson\",\n    get: function get() {\n      try {\n        return JSON.parse(this.bodyText);\n      } catch (error) {\n        (0, errors_js_1.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"bodyJson\",\n          info: {\n            response: this\n          }\n        });\n      }\n    }\n  }, {\n    key: _Symbol$iterator2,\n    value: function value() {\n      var headers = this.headers;\n      var keys = Object.keys(headers);\n      var index = 0;\n      return {\n        next: function next() {\n          if (index < keys.length) {\n            var key = keys[index++];\n            return {\n              value: [key, headers[key]],\n              done: false\n            };\n          }\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      };\n    }\n  }, {\n    key: \"makeServerError\",\n    value: function makeServerError(message, error) {\n      var statusMessage;\n      if (!message) {\n        message = \"\".concat(this.statusCode, \" \").concat(this.statusMessage);\n        statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(message, \")\");\n      } else {\n        statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(this.statusCode, \" \").concat(this.statusMessage, \"; \").concat(message, \")\");\n      }\n      var response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldGet(this, _request2) || undefined);\n      _classPrivateFieldSet(response, _error, {\n        message: message,\n        error: error\n      });\n      return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n  }, {\n    key: \"throwThrottleError\",\n    value: function throwThrottleError(message, stall) {\n      if (stall == null) {\n        stall = -1;\n      } else {\n        (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n      }\n      var error = new Error(message || \"throttling requests\");\n      (0, properties_js_1.defineProperties)(error, {\n        stall: stall,\n        throttle: true\n      });\n      throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(key) {\n      return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true of the response has a body.\n     */\n  }, {\n    key: \"hasBody\",\n    value: function hasBody() {\n      return _classPrivateFieldGet(this, _body2) != null;\n    }\n    /**\n     *  The request made for this response.\n     */\n  }, {\n    key: \"request\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _request2);\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n  }, {\n    key: \"ok\",\n    value: function ok() {\n      return _classPrivateFieldGet(this, _error).message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n  }, {\n    key: \"assertOk\",\n    value: function assertOk() {\n      if (this.ok()) {\n        return;\n      }\n      var _classPrivateFieldGet2 = _classPrivateFieldGet(this, _error),\n        message = _classPrivateFieldGet2.message,\n        error = _classPrivateFieldGet2.error;\n      if (message === \"\") {\n        message = \"server response \".concat(this.statusCode, \" \").concat(this.statusMessage);\n      }\n      (0, errors_js_1.assert)(false, message, \"SERVER_ERROR\", {\n        request: this.request || \"unknown request\",\n        response: this,\n        error: error\n      });\n    }\n  }]);\n  return FetchResponse;\n}();\nexports.FetchResponse = FetchResponse;\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction unpercent(value) {\n  return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function (all, code) {\n    return String.fromCharCode(parseInt(code, 16));\n  }));\n}\nfunction wait(delay) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, delay);\n  });\n}","map":{"version":3,"names":["base64_js_1","require","data_js_1","errors_js_1","properties_js_1","utf8_js_1","geturl_js_1","MAX_ATTEMPTS","SLOT_INTERVAL","getUrlFunc","getUrl","reData","RegExp","reIpfs","locked","dataGatewayFunc","_x","_x2","_dataGatewayFunc","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","url","signal","match","wrap","_callee2$","_context2","prev","next","Error","abrupt","FetchResponse","decodeBase64","unpercent","t0","FetchRequest","stop","getIpfsGatewayFunc","baseUrl","gatewayIpfs","_x3","_x4","_gatewayIpfs","_callee","_callee$","_context","concat","Gateways","fetchSignals","WeakMap","_listeners","_cancelled","FetchCancelSignal","request","_this","_classCallCheck","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","set","_classPrivateFieldGet","_iterator","_createForOfIteratorHelper","_step","_loop","listener","setTimeout","s","n","done","err","e","f","_createClass","key","addListener","assert","operation","push","get","checkSignal","cancelled","exports","_allowInsecure","_gzip","_headers","_method","_timeout","_url","_body","_bodyType","_creds","_preflight","_process","_retry","_signal","_throttle","_send","WeakSet","_Symbol$iterator","Symbol","iterator","_classPrivateMethodInitSpec","String","slotInterval","maxAttempts","Uint8Array","body","undefined","toUtf8Bytes","JSON","stringify","hasBody","method","toUpperCase","headers","Object","assign","encodeBase64","allowGzip","length","getHeader","toLowerCase","setHeader","clearHeaders","keys","index","setCredentials","username","password","assertArgument","timeout","preflight","process","retry","toString","hexlify","setThrottleParams","params","send","_classPrivateMethodGet","_send2","call","getTime","cancel","redirect","location","current","split","target","req","clone","allowInsecureAuthentication","lockConfig","getGateway","scheme","registerGateway","func","registerGetUrl","createDataGateway","createIpfsGatewayFunc","_x5","_x6","_x7","_x8","_x9","_send3","_callee3","attempt","expires","delay","_request","_response","result","_response2","resp","response","_req$redirect","_req$clone","retryAfter","_delay","_req$clone2","_delay2","_callee3$","_context3","makeServerError","reason","wait","sent","processFunc","throttle","stall","assertOk","preflightFunc","statusCode","statusMessage","t1","t2","retryFunc","Math","trunc","random","pow","parseInt","t3","_statusCode","_statusMessage","_headers2","_body2","_request2","_error","_Symbol$iterator2","reduce","accum","k","message","toUtf8String","error","info","parse","bodyText","throwThrottleError","Number","isInteger","defineProperties","ok","_classPrivateFieldGet2","Date","replace","all","code","fromCharCode","Promise","resolve"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/utils/fetch.ts"],"sourcesContent":["/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction the each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retreive the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentcation, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\"\n\nimport { getUrl } from \"./geturl.js\";\n\n/**\n *  An environments implementation of ``getUrl`` must return this type.\n */\nexport type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};\n\n/**\n *  This can be used to control how throttling is handled in\n *  [[FetchRequest-setThrottleParams]].\n */\nexport type FetchThrottleParams = {\n    maxAttempts?: number;\n    slotInterval?: number;\n};\n\n/**\n *  Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.\n */\nexport type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;\n\n/**\n *  Called on the response, allowing client-based throttling logic or post-processing.\n */\nexport type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;\n\n/**\n *  Called prior to each retry; return true to retry, false to abort.\n */\nexport type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;\n\n/**\n *  Called on Gateway URLs.\n */\nexport type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;\n\n/**\n *  Used to perform a fetch; use this to override the underlying network\n *  fetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\n *  and in the browser ``fetch`` is used. If you wish to use Axios, this is\n *  how you would register it.\n */\nexport type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n\n// The global FetchGetUrlFunc implementation.\nlet getUrlFunc: FetchGetUrlFunc = getUrl;\n\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n\n// If locked, new Gateways cannot be added\nlet locked = false;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url: string, signal?: FetchCancelSignal): Promise<FetchResponse> {\n    try {\n        const match = url.match(reData);\n        if (!match) { throw new Error(\"invalid data\"); }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? decodeBase64(match[3]): unpercent(match[3])));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", { }, null, new FetchRequest(url));\n    }\n}\n\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc {\n    async function gatewayIpfs(url: string, signal?: FetchCancelSignal): Promise<FetchRequest | FetchResponse> {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) { throw new Error(\"invalid link\"); }\n            return new FetchRequest(`${ baseUrl }${ match[2] }`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", { }, null, new FetchRequest(url));\n        }\n    }\n\n    return gatewayIpfs;\n}\n\nconst Gateways: Record<string, FetchGatewayFunc> = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\n\nconst fetchSignals: WeakMap<FetchRequest, () => void> = new WeakMap();\n\n/**\n *  @_ignore\n */\nexport class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            this.#cancelled = true;\n\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [ ];\n        });\n    }\n\n    addListener(listener: () => void): void {\n        assert(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n\n    get cancelled(): boolean { return this.#cancelled; }\n\n    checkSignal(): void {\n        assert(!this.cancelled, \"cancelled\", \"CANCELLED\", { });\n    }\n}\n\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal?: FetchCancelSignal): FetchCancelSignal {\n    if (signal == null) { throw new Error(\"missing signal; should not happen\"); }\n    signal.checkSignal();\n    return signal;\n}\n\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nexport class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n    // Hooks\n    #preflight?: null | FetchPreflightFunc;\n    #process?: null | FetchProcessFunc;\n    #retry?: null | FetchRetryFunc;\n\n    #signal?: FetchCancelSignal;\n\n    #throttle: Required<FetchThrottleParams>;\n\n    /**\n     *  The fetch URI to requrest.\n     */\n    get url(): string { return this.#url; }\n    set url(url: string) {\n        this.#url = String(url);\n    }\n\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``) and the .\n     *\n     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrincis ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body(): null | Uint8Array {\n        if (this.#body == null) { return null; }\n        return new Uint8Array(this.#body);\n    }\n    set body(body: null | string | Readonly<object> | Readonly<Uint8Array>) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof(body) === \"string\") {\n            this.#body = toUtf8Bytes(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof(body) === \"object\") {\n            this.#body = toUtf8Bytes(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody(): this is (FetchRequest & { body: Uint8Array }) {\n        return (this.#body != null);\n    }\n\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method(): string {\n        if (this.#method) { return this.#method; }\n        if (this.hasBody()) { return \"POST\"; }\n        return \"GET\";\n    }\n    set method(method: null | string) {\n        if (method == null) { method = \"\"; }\n        this.#method = String(method).toUpperCase();\n    }\n\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any chnages will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers(): Record<string, string> {\n        const headers = Object.assign({ }, this.#headers);\n\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${ encodeBase64(toUtf8Bytes(this.#creds)) }`;\n        };\n\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) { headers[\"content-length\"] = String(this.body.length); }\n\n        return headers;\n    }\n\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key: string): string {\n        return this.headers[key.toLowerCase()];\n    }\n\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key: string, value: string | number): void {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders(): void {\n        this.#headers = { };\n    }\n\n    [Symbol.iterator](): Iterator<[ key: string, value: string ]> {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [ key, headers[key] ], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials(): null | string {\n        return this.#creds || null;\n    }\n\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username: string, password: string): void {\n        assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${ username }:${ password }`;\n    }\n\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip(): boolean {\n        return this.#gzip;\n    }\n    set allowGzip(value: boolean) {\n        this.#gzip = !!value;\n    }\n\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication(): boolean {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value: boolean) {\n        this.#allowInsecure = !!value;\n    }\n\n    /**\n     *  The timeout (in milliseconds) to wait for a complere response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout(): number { return this.#timeout; }\n    set timeout(timeout: number) {\n        assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc(): null | FetchPreflightFunc {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight: null | FetchPreflightFunc) {\n        this.#preflight = preflight;\n    }\n\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc(): null | FetchProcessFunc {\n        return this.#process || null;\n    }\n    set processFunc(process: null | FetchProcessFunc) {\n        this.#process = process;\n    }\n\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc(): null | FetchRetryFunc {\n        return this.#retry || null;\n    }\n    set retryFunc(retry: null | FetchRetryFunc) {\n        this.#retry = retry;\n    }\n\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url: string) {\n        this.#url = String(url);\n\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = { };\n        this.#method = \"\";\n        this.#timeout = 300000;\n\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n    }\n\n    toString(): string {\n        return `<FetchRequest method=${ JSON.stringify(this.method) } url=${ JSON.stringify(this.url) } headers=${ JSON.stringify(this.headers) } body=${ this.#body ? hexlify(this.#body): \"null\" }>`;\n    }\n\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params: FetchThrottleParams): void {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n\n    async #send(attempt: number, expires: number, delay: number, _request: FetchRequest, _response: FetchResponse): Promise<FetchResponse> {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n\n        assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n\n        if (delay > 0) { await wait(delay); }\n\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error: any) {\n\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof(error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n\n                        // Ignore throttling\n                    }\n                }\n\n                return response;\n            }\n            req = result;\n        }\n\n        // We have a preflight function; update the request\n        if (this.preflightFunc) { req = await this.preflightFunc(req); }\n\n        const resp = await getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n\n        if (response.statusCode === 301 || response.statusCode === 302) {\n\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) { }\n\n            // Things won't get any better on another attempt; abort\n            return response;\n\n        } else if (response.statusCode === 429) {\n\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error: any) {\n\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof(error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));;\n                if (error.stall >= 0) { delay = error.stall; }\n\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n\n        return response;\n    }\n\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send(): Promise<FetchResponse> {\n        assert(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", { }, null, this));\n    }\n\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel(): void {\n        assert(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) { throw new Error(\"missing signal; should not happen\"); }\n        signal();\n    }\n\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location: string): FetchRequest {\n        // Redirection; for now we only support absolute locataions\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${ this.method } ${ JSON.stringify(this.url) } => ${ JSON.stringify(location) })`\n        });\n\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({ }, this.#headers);\n        if (this.#body) { req.#body = new Uint8Array(this.#body); }\n        req.#bodyType = this.#bodyType;\n\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n\n        return req;\n    }\n\n    /**\n     *  Create a new copy of this request.\n     */\n    clone(): FetchRequest {\n        const clone = new FetchRequest(this.url);\n\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) { clone.#body = this.#body; }\n        clone.#bodyType = this.#bodyType;\n\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({ }, this.#headers);\n\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n\n        if (this.allowGzip) { clone.allowGzip = true; }\n\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) { clone.allowInsecureAuthentication = true; }\n\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n\n        return clone;\n    }\n\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig(): void {\n        locked = true;\n    }\n\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme: string): null | FetchGatewayFunc {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme: string, func: FetchGatewayFunc): void {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${ scheme }; use registerGetUrl`);\n        }\n        if (locked) { throw new Error(\"gateways locked\"); }\n        Gateways[scheme] = func;\n    }\n\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl: FetchGetUrlFunc): void {\n        if (locked) { throw new Error(\"gateways locked\"); }\n        getUrlFunc = getUrl;\n    }\n\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway(): FetchGatewayFunc {\n        return dataGatewayFunc;\n    }\n\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n\n\ninterface ThrottleError extends Error {\n    stall: number;\n    throttle: true;\n};\n\n/**\n *  The response for a FetchREquest.\n */\nexport class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n    toString(): string {\n        return `<FetchResponse status=${ this.statusCode } body=${ this.#body ? hexlify(this.#body): \"null\" }>`;\n    }\n\n    /**\n     *  The response status code.\n     */\n    get statusCode(): number { return this.#statusCode; }\n\n    /**\n     *  The response status message.\n     */\n    get statusMessage(): string { return this.#statusMessage; }\n\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers(): Record<string, string> { return Object.assign({ }, this.#headers); }\n\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body(): null | Readonly<Uint8Array> {\n        return (this.#body == null) ? null: new Uint8Array(this.#body);\n    }\n\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText(): string {\n        try {\n            return (this.#body == null) ? \"\": toUtf8String(this.#body);\n        } catch (error) {\n            assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson(): any {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n\n    [Symbol.iterator](): Iterator<[ key: string, value: string ]> {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [ key, headers[key] ], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    constructor(statusCode: number, statusMessage: string, headers: Readonly<Record<string, string>>, body: null | Uint8Array, request?: FetchRequest) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, <Record<string, string>>{ });\n        this.#body = ((body == null) ? null: new Uint8Array(body));\n        this.#request = (request || null);\n\n        this.#error = { message: \"\" };\n    }\n\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message?: string, error?: Error): FetchResponse {\n        let statusMessage: string;\n        if (!message) {\n            message = `${ this.statusCode } ${ this.statusMessage }`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${ message })`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${ this.statusCode } ${ this.statusMessage }; ${ message })`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers,\n            this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message?: string, stall?: number): never {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n\n        const error = new Error(message || \"throttling requests\");\n\n        defineProperties(<ThrottleError>error, { stall, throttle: true });\n\n        throw error;\n    }\n\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key: string): string {\n        return this.headers[key.toLowerCase()];\n    }\n\n    /**\n     *  Returns true of the response has a body.\n     */\n    hasBody(): this is (FetchResponse & { body: Uint8Array }) {\n        return (this.#body != null);\n    }\n\n    /**\n     *  The request made for this response.\n     */\n    get request(): null | FetchRequest { return this.#request; }\n\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok(): boolean {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk(): void {\n        if (this.ok()) { return; }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${ this.statusCode } ${ this.statusMessage }`;\n        }\n        assert(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error\n        });\n    }\n}\n\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\nfunction wait(delay: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}