{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;\nvar index_js_1 = require(\"../abi/index.js\");\nvar index_js_2 = require(\"../address/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nvar provider_js_1 = require(\"../providers/provider.js\");\nvar index_js_3 = require(\"../utils/index.js\");\nvar wrappers_js_1 = require(\"./wrappers.js\");\nvar BN_0 = BigInt(0);\nfunction canCall(value) {\n  return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n  return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n  return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n  return value && typeof value.sendTransaction === \"function\";\n}\nvar _filter = /*#__PURE__*/new WeakMap();\nvar PreparedTopicFilter = /*#__PURE__*/function () {\n  function PreparedTopicFilter(contract, fragment, args) {\n    _classCallCheck(this, PreparedTopicFilter);\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"fragment\", void 0);\n    (0, index_js_3.defineProperties)(this, {\n      fragment: fragment\n    });\n    if (fragment.inputs.length < args.length) {\n      throw new Error(\"too many arguments\");\n    }\n    // Recursively descend into args and resolve any addresses\n    var runner = getRunner(contract.runner, \"resolveName\");\n    var resolver = canResolve(runner) ? runner : null;\n    _classPrivateFieldSet(this, _filter, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var resolvedArgs;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.all(fragment.inputs.map(function (param, index) {\n              var arg = args[index];\n              if (arg == null) {\n                return null;\n              }\n              return param.walkAsync(args[index], function (type, value) {\n                if (type === \"address\") {\n                  return (0, index_js_2.resolveAddress)(value, resolver);\n                }\n                return value;\n              });\n            }));\n          case 2:\n            resolvedArgs = _context.sent;\n            return _context.abrupt(\"return\", contract.interface.encodeFilterTopics(fragment, resolvedArgs));\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))());\n  }\n  _createClass(PreparedTopicFilter, [{\n    key: \"getTopicFilter\",\n    value: function getTopicFilter() {\n      return _classPrivateFieldGet(this, _filter);\n    }\n  }]);\n  return PreparedTopicFilter;\n}(); // A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n  if (value == null) {\n    return null;\n  }\n  if (typeof value[feature] === \"function\") {\n    return value;\n  }\n  if (value.provider && typeof value.provider[feature] === \"function\") {\n    return value.provider;\n  }\n  return null;\n}\nfunction getProvider(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nfunction copyOverrides(_x, _x2) {\n  return _copyOverrides.apply(this, arguments);\n}\nfunction _copyOverrides() {\n  _copyOverrides = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(arg, allowed) {\n    var overrides;\n    return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n      while (1) switch (_context28.prev = _context28.next) {\n        case 0:\n          // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n          overrides = (0, provider_js_1.copyRequest)(index_js_1.Typed.dereference(arg, \"overrides\"));\n          (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n          (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n          // Resolve any from\n          if (!overrides.from) {\n            _context28.next = 7;\n            break;\n          }\n          _context28.next = 6;\n          return (0, index_js_2.resolveAddress)(overrides.from);\n        case 6:\n          overrides.from = _context28.sent;\n        case 7:\n          return _context28.abrupt(\"return\", overrides);\n        case 8:\n        case \"end\":\n          return _context28.stop();\n      }\n    }, _callee28);\n  }));\n  return _copyOverrides.apply(this, arguments);\n}\nexports.copyOverrides = copyOverrides;\n/**\n *  @_ignore:\n */\nfunction resolveArgs(_x3, _x4, _x5) {\n  return _resolveArgs.apply(this, arguments);\n}\nfunction _resolveArgs() {\n  _resolveArgs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(_runner, inputs, args) {\n    var runner, resolver;\n    return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n      while (1) switch (_context29.prev = _context29.next) {\n        case 0:\n          // Recursively descend into args and resolve any addresses\n          runner = getRunner(_runner, \"resolveName\");\n          resolver = canResolve(runner) ? runner : null;\n          _context29.next = 4;\n          return Promise.all(inputs.map(function (param, index) {\n            return param.walkAsync(args[index], function (type, value) {\n              value = index_js_1.Typed.dereference(value, type);\n              if (type === \"address\") {\n                return (0, index_js_2.resolveAddress)(value, resolver);\n              }\n              return value;\n            });\n          }));\n        case 4:\n          return _context29.abrupt(\"return\", _context29.sent);\n        case 5:\n        case \"end\":\n          return _context29.stop();\n      }\n    }, _callee29);\n  }));\n  return _resolveArgs.apply(this, arguments);\n}\nexports.resolveArgs = resolveArgs;\nfunction buildWrappedFallback(contract) {\n  var populateTransaction = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(overrides) {\n      var tx, iface, noValue, noData, payable;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return copyOverrides(overrides, [\"data\"]);\n          case 2:\n            tx = _context2.sent;\n            _context2.next = 5;\n            return contract.getAddress();\n          case 5:\n            tx.to = _context2.sent;\n            iface = contract.interface;\n            noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n            noData = (tx.data || \"0x\") === \"0x\";\n            if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n              (0, index_js_3.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n            }\n            (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n            // Only allow payable contracts to set non-zero value\n            payable = iface.receive || iface.fallback && iface.fallback.payable;\n            (0, index_js_3.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n            // Only allow fallback contracts to set non-empty data\n            (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n            return _context2.abrupt(\"return\", tx);\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function populateTransaction(_x6) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var staticCall = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(overrides) {\n      var runner, tx;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"call\");\n            (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"call\"\n            });\n            _context3.next = 4;\n            return populateTransaction(overrides);\n          case 4:\n            tx = _context3.sent;\n            _context3.prev = 5;\n            _context3.next = 8;\n            return runner.call(tx);\n          case 8:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 11:\n            _context3.prev = 11;\n            _context3.t0 = _context3[\"catch\"](5);\n            if (!((0, index_js_3.isCallException)(_context3.t0) && _context3.t0.data)) {\n              _context3.next = 15;\n              break;\n            }\n            throw contract.interface.makeError(_context3.t0.data, tx);\n          case 15:\n            throw _context3.t0;\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[5, 11]]);\n    }));\n    return function staticCall(_x7) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var send = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(overrides) {\n      var runner, tx, provider;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            runner = contract.runner;\n            (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"sendTransaction\"\n            });\n            _context4.t0 = runner;\n            _context4.next = 5;\n            return populateTransaction(overrides);\n          case 5:\n            _context4.t1 = _context4.sent;\n            _context4.next = 8;\n            return _context4.t0.sendTransaction.call(_context4.t0, _context4.t1);\n          case 8:\n            tx = _context4.sent;\n            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            return _context4.abrupt(\"return\", new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx));\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function send(_x8) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var estimateGas = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(overrides) {\n      var runner;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"estimateGas\");\n            (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"estimateGas\"\n            });\n            _context5.t0 = runner;\n            _context5.next = 5;\n            return populateTransaction(overrides);\n          case 5:\n            _context5.t1 = _context5.sent;\n            _context5.next = 8;\n            return _context5.t0.estimateGas.call(_context5.t0, _context5.t1);\n          case 8:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return function estimateGas(_x9) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var method = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(overrides) {\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return send(overrides);\n          case 2:\n            return _context6.abrupt(\"return\", _context6.sent);\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    return function method(_x10) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  (0, index_js_3.defineProperties)(method, {\n    _contract: contract,\n    estimateGas: estimateGas,\n    populateTransaction: populateTransaction,\n    send: send,\n    staticCall: staticCall\n  });\n  return method;\n}\nfunction buildWrappedMethod(contract, key) {\n  var getFragment = function getFragment() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var fragment = contract.interface.getFunction(key, args);\n    (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  var populateTransaction = /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var _len2,\n        args,\n        _key2,\n        fragment,\n        overrides,\n        resolvedArgs,\n        _args7 = arguments;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            for (_len2 = _args7.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = _args7[_key2];\n            }\n            fragment = getFragment.apply(void 0, args); // If an overrides was passed in, copy it and normalize the values\n            overrides = {};\n            if (!(fragment.inputs.length + 1 === args.length)) {\n              _context7.next = 7;\n              break;\n            }\n            _context7.next = 6;\n            return copyOverrides(args.pop());\n          case 6:\n            overrides = _context7.sent;\n          case 7:\n            if (!(fragment.inputs.length !== args.length)) {\n              _context7.next = 9;\n              break;\n            }\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n          case 9:\n            _context7.next = 11;\n            return resolveArgs(contract.runner, fragment.inputs, args);\n          case 11:\n            resolvedArgs = _context7.sent;\n            _context7.t0 = Object;\n            _context7.t1 = {};\n            _context7.t2 = overrides;\n            _context7.next = 17;\n            return (0, index_js_3.resolveProperties)({\n              to: contract.getAddress(),\n              data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n            });\n          case 17:\n            _context7.t3 = _context7.sent;\n            return _context7.abrupt(\"return\", _context7.t0.assign.call(_context7.t0, _context7.t1, _context7.t2, _context7.t3));\n          case 19:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return function populateTransaction() {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  var staticCall = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      var result,\n        _args8 = arguments;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return staticCallResult.apply(void 0, _args8);\n          case 2:\n            result = _context8.sent;\n            if (!(result.length === 1)) {\n              _context8.next = 5;\n              break;\n            }\n            return _context8.abrupt(\"return\", result[0]);\n          case 5:\n            return _context8.abrupt(\"return\", result);\n          case 6:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }));\n    return function staticCall() {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  var send = /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n      var runner,\n        tx,\n        provider,\n        _args9 = arguments;\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            runner = contract.runner;\n            (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"sendTransaction\"\n            });\n            _context9.t0 = runner;\n            _context9.next = 5;\n            return populateTransaction.apply(void 0, _args9);\n          case 5:\n            _context9.t1 = _context9.sent;\n            _context9.next = 8;\n            return _context9.t0.sendTransaction.call(_context9.t0, _context9.t1);\n          case 8:\n            tx = _context9.sent;\n            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            return _context9.abrupt(\"return\", new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx));\n          case 11:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }));\n    return function send() {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n  var estimateGas = /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n      var runner,\n        _args10 = arguments;\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"estimateGas\");\n            (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"estimateGas\"\n            });\n            _context10.t0 = runner;\n            _context10.next = 5;\n            return populateTransaction.apply(void 0, _args10);\n          case 5:\n            _context10.t1 = _context10.sent;\n            _context10.next = 8;\n            return _context10.t0.estimateGas.call(_context10.t0, _context10.t1);\n          case 8:\n            return _context10.abrupt(\"return\", _context10.sent);\n          case 9:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }));\n    return function estimateGas() {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n  var staticCallResult = /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n      var runner,\n        tx,\n        result,\n        fragment,\n        _args11 = arguments;\n      return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"call\");\n            (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"call\"\n            });\n            _context11.next = 4;\n            return populateTransaction.apply(void 0, _args11);\n          case 4:\n            tx = _context11.sent;\n            result = \"0x\";\n            _context11.prev = 6;\n            _context11.next = 9;\n            return runner.call(tx);\n          case 9:\n            result = _context11.sent;\n            _context11.next = 17;\n            break;\n          case 12:\n            _context11.prev = 12;\n            _context11.t0 = _context11[\"catch\"](6);\n            if (!((0, index_js_3.isCallException)(_context11.t0) && _context11.t0.data)) {\n              _context11.next = 16;\n              break;\n            }\n            throw contract.interface.makeError(_context11.t0.data, tx);\n          case 16:\n            throw _context11.t0;\n          case 17:\n            fragment = getFragment.apply(void 0, _args11);\n            return _context11.abrupt(\"return\", contract.interface.decodeFunctionResult(fragment, result));\n          case 19:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11, null, [[6, 12]]);\n    }));\n    return function staticCallResult() {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  var method = /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n      var fragment,\n        _args12 = arguments;\n      return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            fragment = getFragment.apply(void 0, _args12);\n            if (!fragment.constant) {\n              _context12.next = 5;\n              break;\n            }\n            _context12.next = 4;\n            return staticCall.apply(void 0, _args12);\n          case 4:\n            return _context12.abrupt(\"return\", _context12.sent);\n          case 5:\n            _context12.next = 7;\n            return send.apply(void 0, _args12);\n          case 7:\n            return _context12.abrupt(\"return\", _context12.sent);\n          case 8:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12);\n    }));\n    return function method() {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n  (0, index_js_3.defineProperties)(method, {\n    name: contract.interface.getFunctionName(key),\n    _contract: contract,\n    _key: key,\n    getFragment: getFragment,\n    estimateGas: estimateGas,\n    populateTransaction: populateTransaction,\n    send: send,\n    staticCall: staticCall,\n    staticCallResult: staticCallResult\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      var fragment = contract.interface.getFunction(key);\n      (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\nfunction buildWrappedEvent(contract, key) {\n  var getFragment = function getFragment() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    var fragment = contract.interface.getEvent(key, args);\n    (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  var method = function method() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return new PreparedTopicFilter(contract, getFragment.apply(void 0, args), args);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    name: contract.interface.getEventName(key),\n    _contract: contract,\n    _key: key,\n    getFragment: getFragment\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      var fragment = contract.interface.getEvent(key);\n      (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nvar internal = Symbol.for(\"_ethersInternal_contract\");\nvar internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n  internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n  return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n  return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nfunction getSubInfo(_x11, _x12) {\n  return _getSubInfo.apply(this, arguments);\n}\nfunction _getSubInfo() {\n  _getSubInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(contract, event) {\n    var topics, fragment, topicHashify, tag;\n    return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n      while (1) switch (_context30.prev = _context30.next) {\n        case 0:\n          fragment = null; // Convert named events to topicHash and get the fragment for\n          // events which need deconstructing.\n          if (!Array.isArray(event)) {\n            _context30.next = 6;\n            break;\n          }\n          topicHashify = function topicHashify(name) {\n            if ((0, index_js_3.isHexString)(name, 32)) {\n              return name;\n            }\n            var fragment = contract.interface.getEvent(name);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n          }; // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n          topics = event.map(function (e) {\n            if (e == null) {\n              return null;\n            }\n            if (Array.isArray(e)) {\n              return e.map(topicHashify);\n            }\n            return topicHashify(e);\n          });\n          _context30.next = 21;\n          break;\n        case 6:\n          if (!(event === \"*\")) {\n            _context30.next = 10;\n            break;\n          }\n          topics = [null];\n          _context30.next = 21;\n          break;\n        case 10:\n          if (!(typeof event === \"string\")) {\n            _context30.next = 14;\n            break;\n          }\n          if ((0, index_js_3.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [event];\n          } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n          }\n          _context30.next = 21;\n          break;\n        case 14:\n          if (!isDeferred(event)) {\n            _context30.next = 20;\n            break;\n          }\n          _context30.next = 17;\n          return event.getTopicFilter();\n        case 17:\n          topics = _context30.sent;\n          _context30.next = 21;\n          break;\n        case 20:\n          if (\"fragment\" in event) {\n            // ContractEvent; e.g. `contract.filter.Transfer`\n            fragment = event.fragment;\n            topics = [fragment.topicHash];\n          } else {\n            (0, index_js_3.assertArgument)(false, \"unknown event name\", \"event\", event);\n          }\n        case 21:\n          // Normalize topics and sort TopicSets\n          topics = topics.map(function (t) {\n            if (t == null) {\n              return null;\n            }\n            if (Array.isArray(t)) {\n              var items = Array.from(new Set(t.map(function (t) {\n                return t.toLowerCase();\n              })).values());\n              if (items.length === 1) {\n                return items[0];\n              }\n              items.sort();\n              return items;\n            }\n            return t.toLowerCase();\n          });\n          tag = topics.map(function (t) {\n            if (t == null) {\n              return \"null\";\n            }\n            if (Array.isArray(t)) {\n              return t.join(\"|\");\n            }\n            return t;\n          }).join(\"&\");\n          return _context30.abrupt(\"return\", {\n            fragment: fragment,\n            tag: tag,\n            topics: topics\n          });\n        case 24:\n        case \"end\":\n          return _context30.stop();\n      }\n    }, _callee30);\n  }));\n  return _getSubInfo.apply(this, arguments);\n}\nfunction hasSub(_x13, _x14) {\n  return _hasSub.apply(this, arguments);\n}\nfunction _hasSub() {\n  _hasSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(contract, event) {\n    var _getInternal5, subs;\n    return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n      while (1) switch (_context31.prev = _context31.next) {\n        case 0:\n          _getInternal5 = getInternal(contract), subs = _getInternal5.subs;\n          _context31.t1 = subs;\n          _context31.next = 4;\n          return getSubInfo(contract, event);\n        case 4:\n          _context31.t2 = _context31.sent.tag;\n          _context31.t0 = _context31.t1.get.call(_context31.t1, _context31.t2);\n          if (_context31.t0) {\n            _context31.next = 8;\n            break;\n          }\n          _context31.t0 = null;\n        case 8:\n          return _context31.abrupt(\"return\", _context31.t0);\n        case 9:\n        case \"end\":\n          return _context31.stop();\n      }\n    }, _callee31);\n  }));\n  return _hasSub.apply(this, arguments);\n}\nfunction getSub(_x15, _x16, _x17) {\n  return _getSub.apply(this, arguments);\n} // We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nfunction _getSub() {\n  _getSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(contract, operation, event) {\n    var provider, _yield$getSubInfo2, fragment, tag, topics, _getInternal6, addr, subs, sub, address, filter, listener, starting, start, stop;\n    return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n      while (1) switch (_context33.prev = _context33.next) {\n        case 0:\n          // Make sure our runner can actually subscribe to events\n          provider = getProvider(contract.runner);\n          (0, index_js_3.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n            operation: operation\n          });\n          _context33.next = 4;\n          return getSubInfo(contract, event);\n        case 4:\n          _yield$getSubInfo2 = _context33.sent;\n          fragment = _yield$getSubInfo2.fragment;\n          tag = _yield$getSubInfo2.tag;\n          topics = _yield$getSubInfo2.topics;\n          _getInternal6 = getInternal(contract), addr = _getInternal6.addr, subs = _getInternal6.subs;\n          sub = subs.get(tag);\n          if (!sub) {\n            address = addr ? addr : contract;\n            filter = {\n              address: address,\n              topics: topics\n            };\n            listener = function listener(log) {\n              var foundFragment = fragment;\n              if (foundFragment == null) {\n                try {\n                  foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n              }\n              // If fragment is null, we do not deconstruct the args to emit\n              if (foundFragment) {\n                var _foundFragment = foundFragment;\n                var _args32 = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                _emit4(contract, event, _args32, function (listener) {\n                  return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n              } else {\n                _emit4(contract, event, [], function (listener) {\n                  return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n              }\n            };\n            starting = [];\n            start = function start() {\n              if (starting.length) {\n                return;\n              }\n              starting.push(provider.on(filter, listener));\n            };\n            stop = /*#__PURE__*/function () {\n              var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n                var started;\n                return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n                  while (1) switch (_context32.prev = _context32.next) {\n                    case 0:\n                      if (!(starting.length == 0)) {\n                        _context32.next = 2;\n                        break;\n                      }\n                      return _context32.abrupt(\"return\");\n                    case 2:\n                      started = starting;\n                      starting = [];\n                      _context32.next = 6;\n                      return Promise.all(started);\n                    case 6:\n                      provider.off(filter, listener);\n                    case 7:\n                    case \"end\":\n                      return _context32.stop();\n                  }\n                }, _callee32);\n              }));\n              return function stop() {\n                return _ref17.apply(this, arguments);\n              };\n            }();\n            sub = {\n              tag: tag,\n              listeners: [],\n              start: start,\n              stop: stop\n            };\n            subs.set(tag, sub);\n          }\n          return _context33.abrupt(\"return\", sub);\n        case 12:\n        case \"end\":\n          return _context33.stop();\n      }\n    }, _callee33);\n  }));\n  return _getSub.apply(this, arguments);\n}\nvar lastEmit = Promise.resolve();\nfunction _emit(_x18, _x19, _x20, _x21) {\n  return _emit2.apply(this, arguments);\n}\nfunction _emit2() {\n  _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(contract, event, args, payloadFunc) {\n    var sub, count;\n    return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n      while (1) switch (_context34.prev = _context34.next) {\n        case 0:\n          _context34.next = 2;\n          return lastEmit;\n        case 2:\n          _context34.next = 4;\n          return hasSub(contract, event);\n        case 4:\n          sub = _context34.sent;\n          if (sub) {\n            _context34.next = 7;\n            break;\n          }\n          return _context34.abrupt(\"return\", false);\n        case 7:\n          count = sub.listeners.length;\n          sub.listeners = sub.listeners.filter(function (_ref18) {\n            var listener = _ref18.listener,\n              once = _ref18.once;\n            var passArgs = Array.from(args);\n            if (payloadFunc) {\n              passArgs.push(payloadFunc(once ? null : listener));\n            }\n            try {\n              listener.call.apply(listener, [contract].concat(passArgs));\n            } catch (error) {}\n            return !once;\n          });\n          return _context34.abrupt(\"return\", count > 0);\n        case 10:\n        case \"end\":\n          return _context34.stop();\n      }\n    }, _callee34);\n  }));\n  return _emit2.apply(this, arguments);\n}\nfunction _emit4(_x22, _x23, _x24, _x25) {\n  return _emit3.apply(this, arguments);\n}\nfunction _emit3() {\n  _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(contract, event, args, payloadFunc) {\n    var resultPromise;\n    return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n      while (1) switch (_context35.prev = _context35.next) {\n        case 0:\n          _context35.prev = 0;\n          _context35.next = 3;\n          return lastEmit;\n        case 3:\n          _context35.next = 7;\n          break;\n        case 5:\n          _context35.prev = 5;\n          _context35.t0 = _context35[\"catch\"](0);\n        case 7:\n          resultPromise = _emit(contract, event, args, payloadFunc);\n          lastEmit = resultPromise;\n          _context35.next = 11;\n          return resultPromise;\n        case 11:\n          return _context35.abrupt(\"return\", _context35.sent);\n        case 12:\n        case \"end\":\n          return _context35.stop();\n      }\n    }, _callee35, null, [[0, 5]]);\n  }));\n  return _emit3.apply(this, arguments);\n}\nvar passProperties = [\"then\"];\nvar BaseContract = /*#__PURE__*/function () {\n  /**\n   *  Creates a new contract connected to %%target%% with the %%abi%% and\n   *  optionally connected to a %%runner%% to perform operations on behalf\n   *  of.\n   */\n  function BaseContract(target, abi, runner, _deployTx) {\n    var _this = this;\n    _classCallCheck(this, BaseContract);\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    _defineProperty(this, \"target\", void 0);\n    /**\n     *  The contract Interface.\n     */\n    _defineProperty(this, \"interface\", void 0);\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    _defineProperty(this, \"runner\", void 0);\n    /**\n     *  All the Events available on this contract.\n     */\n    _defineProperty(this, \"filters\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, internal, void 0);\n    /**\n     *  The fallback or receive function if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    (0, index_js_3.assertArgument)(typeof target === \"string\" || (0, index_js_2.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n    if (runner == null) {\n      runner = null;\n    }\n    var iface = index_js_1.Interface.from(abi);\n    (0, index_js_3.defineProperties)(this, {\n      target: target,\n      runner: runner,\n      interface: iface\n    });\n    Object.defineProperty(this, internal, {\n      value: {}\n    });\n    var addrPromise;\n    var addr = null;\n    var deployTx = null;\n    if (_deployTx) {\n      var provider = getProvider(runner);\n      // @TODO: the provider can be null; make a custom dummy provider that will throw a\n      // meaningful error\n      deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);\n    }\n    var subs = new Map();\n    // Resolve the target as the address\n    if (typeof target === \"string\") {\n      if ((0, index_js_3.isHexString)(target)) {\n        addr = target;\n        addrPromise = Promise.resolve(target);\n      } else {\n        var resolver = getRunner(runner, \"resolveName\");\n        if (!canResolve(resolver)) {\n          throw (0, index_js_3.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n          });\n        }\n        addrPromise = resolver.resolveName(target).then(function (addr) {\n          if (addr == null) {\n            throw new Error(\"TODO\");\n          }\n          getInternal(_this).addr = addr;\n          return addr;\n        });\n      }\n    } else {\n      addrPromise = target.getAddress().then(function (addr) {\n        if (addr == null) {\n          throw new Error(\"TODO\");\n        }\n        getInternal(_this).addr = addr;\n        return addr;\n      });\n    }\n    // Set our private values\n    setInternal(this, {\n      addrPromise: addrPromise,\n      addr: addr,\n      deployTx: deployTx,\n      subs: subs\n    });\n    // Add the event filters\n    var filters = new Proxy({}, {\n      get: function get(target, _prop, receiver) {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        var prop = String(_prop);\n        var result = _this.getEvent(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(\"unknown contract event: \".concat(prop));\n      },\n      has: function has(target, prop) {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return Reflect.has(target, prop) || _this.interface.hasEvent(String(prop));\n      }\n    });\n    (0, index_js_3.defineProperties)(this, {\n      filters: filters\n    });\n    (0, index_js_3.defineProperties)(this, {\n      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n    });\n    // Return a Proxy that will respond to functions\n    return new Proxy(this, {\n      get: function get(target, _prop, receiver) {\n        if (_prop in target || passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        var prop = String(_prop);\n        var result = target.getFunction(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(\"unknown contract method: \".concat(prop));\n      },\n      has: function has(target, prop) {\n        if (prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return target.interface.hasFunction(String(prop));\n      }\n    });\n  }\n  /**\n   *  Return a new Contract instance with the same target and ABI, but\n   *  a different %%runner%%.\n   */\n  _createClass(BaseContract, [{\n    key: \"connect\",\n    value: function connect(runner) {\n      return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n  }, {\n    key: \"attach\",\n    value: function attach(target) {\n      return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return getInternal(this).addrPromise;\n            case 2:\n              return _context13.abrupt(\"return\", _context13.sent);\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n    /**\n     *  Return the dedployed bytecode or null if no bytecode is found.\n     */\n  }, {\n    key: \"getDeployedCode\",\n    value: function () {\n      var _getDeployedCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var provider, code;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              provider = getProvider(this.runner);\n              (0, index_js_3.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getDeployedCode\"\n              });\n              _context14.t0 = provider;\n              _context14.next = 5;\n              return this.getAddress();\n            case 5:\n              _context14.t1 = _context14.sent;\n              _context14.next = 8;\n              return _context14.t0.getCode.call(_context14.t0, _context14.t1);\n            case 8:\n              code = _context14.sent;\n              if (!(code === \"0x\")) {\n                _context14.next = 11;\n                break;\n              }\n              return _context14.abrupt(\"return\", null);\n            case 11:\n              return _context14.abrupt(\"return\", code);\n            case 12:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getDeployedCode() {\n        return _getDeployedCode.apply(this, arguments);\n      }\n      return getDeployedCode;\n    }()\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n  }, {\n    key: \"waitForDeployment\",\n    value: function () {\n      var _waitForDeployment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this2 = this;\n        var deployTx, code, provider;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              // We have the deployement transaction; just use that (throws if deployement fails)\n              deployTx = this.deploymentTransaction();\n              if (!deployTx) {\n                _context16.next = 5;\n                break;\n              }\n              _context16.next = 4;\n              return deployTx.wait();\n            case 4:\n              return _context16.abrupt(\"return\", this);\n            case 5:\n              _context16.next = 7;\n              return this.getDeployedCode();\n            case 7:\n              code = _context16.sent;\n              if (!(code != null)) {\n                _context16.next = 10;\n                break;\n              }\n              return _context16.abrupt(\"return\", this);\n            case 10:\n              // Make sure we can subscribe to a provider event\n              provider = getProvider(this.runner);\n              (0, index_js_3.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"waitForDeployment\"\n              });\n              return _context16.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var checkCode = /*#__PURE__*/function () {\n                  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n                    var _code;\n                    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n                      while (1) switch (_context15.prev = _context15.next) {\n                        case 0:\n                          _context15.prev = 0;\n                          _context15.next = 3;\n                          return _this2.getDeployedCode();\n                        case 3:\n                          _code = _context15.sent;\n                          if (!(_code != null)) {\n                            _context15.next = 6;\n                            break;\n                          }\n                          return _context15.abrupt(\"return\", resolve(_this2));\n                        case 6:\n                          provider.once(\"block\", checkCode);\n                          _context15.next = 12;\n                          break;\n                        case 9:\n                          _context15.prev = 9;\n                          _context15.t0 = _context15[\"catch\"](0);\n                          reject(_context15.t0);\n                        case 12:\n                        case \"end\":\n                          return _context15.stop();\n                      }\n                    }, _callee15, null, [[0, 9]]);\n                  }));\n                  return function checkCode() {\n                    return _ref13.apply(this, arguments);\n                  };\n                }();\n                checkCode();\n              }));\n            case 13:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function waitForDeployment() {\n        return _waitForDeployment.apply(this, arguments);\n      }\n      return waitForDeployment;\n    }()\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n  }, {\n    key: \"deploymentTransaction\",\n    value: function deploymentTransaction() {\n      return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(key) {\n      if (typeof key !== \"string\") {\n        key = key.format();\n      }\n      var func = buildWrappedMethod(this, key);\n      return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n  }, {\n    key: \"getEvent\",\n    value: function getEvent(key) {\n      if (typeof key !== \"string\") {\n        key = key.format();\n      }\n      return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n  }, {\n    key: \"queryTransaction\",\n    value: function () {\n      var _queryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(hash) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              throw new Error(\"@TODO\");\n            case 1:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17);\n      }));\n      function queryTransaction(_x26) {\n        return _queryTransaction.apply(this, arguments);\n      }\n      return queryTransaction;\n    }()\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n  }, {\n    key: \"queryFilter\",\n    value: function () {\n      var _queryFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(event, fromBlock, toBlock) {\n        var _this3 = this;\n        var _getInternal, addr, addrPromise, address, _yield$getSubInfo, fragment, topics, filter, provider;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              if (fromBlock == null) {\n                fromBlock = 0;\n              }\n              if (toBlock == null) {\n                toBlock = \"latest\";\n              }\n              _getInternal = getInternal(this), addr = _getInternal.addr, addrPromise = _getInternal.addrPromise;\n              if (!addr) {\n                _context18.next = 7;\n                break;\n              }\n              _context18.t0 = addr;\n              _context18.next = 10;\n              break;\n            case 7:\n              _context18.next = 9;\n              return addrPromise;\n            case 9:\n              _context18.t0 = _context18.sent;\n            case 10:\n              address = _context18.t0;\n              _context18.next = 13;\n              return getSubInfo(this, event);\n            case 13:\n              _yield$getSubInfo = _context18.sent;\n              fragment = _yield$getSubInfo.fragment;\n              topics = _yield$getSubInfo.topics;\n              filter = {\n                address: address,\n                topics: topics,\n                fromBlock: fromBlock,\n                toBlock: toBlock\n              };\n              provider = getProvider(this.runner);\n              (0, index_js_3.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"queryFilter\"\n              });\n              _context18.next = 21;\n              return provider.getLogs(filter);\n            case 21:\n              return _context18.abrupt(\"return\", _context18.sent.map(function (log) {\n                var foundFragment = fragment;\n                if (foundFragment == null) {\n                  try {\n                    foundFragment = _this3.interface.getEvent(log.topics[0]);\n                  } catch (error) {}\n                }\n                if (foundFragment) {\n                  return new wrappers_js_1.EventLog(log, _this3.interface, foundFragment);\n                } else {\n                  return new provider_js_1.Log(log, provider);\n                }\n              }));\n            case 22:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function queryFilter(_x27, _x28, _x29) {\n        return _queryFilter.apply(this, arguments);\n      }\n      return queryFilter;\n    }()\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n  }, {\n    key: \"on\",\n    value: function () {\n      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return getSub(this, \"on\", event);\n            case 2:\n              sub = _context19.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: false\n              });\n              sub.start();\n              return _context19.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function on(_x30, _x31) {\n        return _on.apply(this, arguments);\n      }\n      return on;\n    }()\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n  }, {\n    key: \"once\",\n    value: function () {\n      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return getSub(this, \"once\", event);\n            case 2:\n              sub = _context20.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: true\n              });\n              sub.start();\n              return _context20.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function once(_x32, _x33) {\n        return _once.apply(this, arguments);\n      }\n      return once;\n    }()\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n  }, {\n    key: \"emit\",\n    value: function () {\n      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(event) {\n        var _len5,\n          args,\n          _key5,\n          _args21 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              for (_len5 = _args21.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                args[_key5 - 1] = _args21[_key5];\n              }\n              _context21.next = 3;\n              return _emit4(this, event, args, null);\n            case 3:\n              return _context21.abrupt(\"return\", _context21.sent);\n            case 4:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function emit(_x34) {\n        return _emit5.apply(this, arguments);\n      }\n      return emit;\n    }()\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n  }, {\n    key: \"listenerCount\",\n    value: function () {\n      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(event) {\n        var sub, _getInternal2, subs, total, _iterator, _step, listeners;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              if (!event) {\n                _context22.next = 7;\n                break;\n              }\n              _context22.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context22.sent;\n              if (sub) {\n                _context22.next = 6;\n                break;\n              }\n              return _context22.abrupt(\"return\", 0);\n            case 6:\n              return _context22.abrupt(\"return\", sub.listeners.length);\n            case 7:\n              _getInternal2 = getInternal(this), subs = _getInternal2.subs;\n              total = 0;\n              _iterator = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  listeners = _step.value.listeners;\n                  total += listeners.length;\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context22.abrupt(\"return\", total);\n            case 12:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function listenerCount(_x35) {\n        return _listenerCount.apply(this, arguments);\n      }\n      return listenerCount;\n    }()\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n  }, {\n    key: \"listeners\",\n    value: function () {\n      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(event) {\n        var sub, _getInternal3, subs, result, _iterator2, _step2, _listeners2;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              if (!event) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context23.sent;\n              if (sub) {\n                _context23.next = 6;\n                break;\n              }\n              return _context23.abrupt(\"return\", []);\n            case 6:\n              return _context23.abrupt(\"return\", sub.listeners.map(function (_ref14) {\n                var listener = _ref14.listener;\n                return listener;\n              }));\n            case 7:\n              _getInternal3 = getInternal(this), subs = _getInternal3.subs;\n              result = [];\n              _iterator2 = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  _listeners2 = _step2.value.listeners;\n                  result = result.concat(_listeners2.map(function (_ref15) {\n                    var listener = _ref15.listener;\n                    return listener;\n                  }));\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              return _context23.abrupt(\"return\", result);\n            case 12:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function listeners(_x36) {\n        return _listeners.apply(this, arguments);\n      }\n      return listeners;\n    }()\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n  }, {\n    key: \"off\",\n    value: function () {\n      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(event, listener) {\n        var sub, index;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return hasSub(this, event);\n            case 2:\n              sub = _context24.sent;\n              if (sub) {\n                _context24.next = 5;\n                break;\n              }\n              return _context24.abrupt(\"return\", this);\n            case 5:\n              if (listener) {\n                index = sub.listeners.map(function (_ref16) {\n                  var listener = _ref16.listener;\n                  return listener;\n                }).indexOf(listener);\n                if (index >= 0) {\n                  sub.listeners.splice(index, 1);\n                }\n              }\n              if (listener == null || sub.listeners.length === 0) {\n                sub.stop();\n                getInternal(this).subs.delete(sub.tag);\n              }\n              return _context24.abrupt(\"return\", this);\n            case 8:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function off(_x37, _x38) {\n        return _off.apply(this, arguments);\n      }\n      return off;\n    }()\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n  }, {\n    key: \"removeAllListeners\",\n    value: function () {\n      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(event) {\n        var sub, _getInternal4, subs, _iterator3, _step3, _step3$value, tag, stop;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              if (!event) {\n                _context25.next = 10;\n                break;\n              }\n              _context25.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context25.sent;\n              if (sub) {\n                _context25.next = 6;\n                break;\n              }\n              return _context25.abrupt(\"return\", this);\n            case 6:\n              sub.stop();\n              getInternal(this).subs.delete(sub.tag);\n              _context25.next = 13;\n              break;\n            case 10:\n              _getInternal4 = getInternal(this), subs = _getInternal4.subs;\n              _iterator3 = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _step3$value = _step3.value, tag = _step3$value.tag, stop = _step3$value.stop;\n                  stop();\n                  subs.delete(tag);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            case 13:\n              return _context25.abrupt(\"return\", this);\n            case 14:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function removeAllListeners(_x39) {\n        return _removeAllListeners.apply(this, arguments);\n      }\n      return removeAllListeners;\n    }()\n    /**\n     *  Alias for [on].\n     */\n  }, {\n    key: \"addListener\",\n    value: function () {\n      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return this.on(event, listener);\n            case 2:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 3:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function addListener(_x40, _x41) {\n        return _addListener.apply(this, arguments);\n      }\n      return addListener;\n    }()\n    /**\n     *  Alias for [off].\n     */\n  }, {\n    key: \"removeListener\",\n    value: function () {\n      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.next = 2;\n              return this.off(event, listener);\n            case 2:\n              return _context27.abrupt(\"return\", _context27.sent);\n            case 3:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function removeListener(_x42, _x43) {\n        return _removeListener.apply(this, arguments);\n      }\n      return removeListener;\n    }()\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n  }], [{\n    key: \"buildClass\",\n    value: function buildClass(abi) {\n      var CustomContract = /*#__PURE__*/function (_BaseContract) {\n        _inherits(CustomContract, _BaseContract);\n        var _super = _createSuper(CustomContract);\n        function CustomContract(address) {\n          var runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          _classCallCheck(this, CustomContract);\n          return _super.call(this, address, abi, runner);\n        }\n        return _createClass(CustomContract);\n      }(BaseContract);\n      return CustomContract;\n    }\n  }, {\n    key: \"from\",\n    value:\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    function from(target, abi, runner) {\n      if (runner == null) {\n        runner = null;\n      }\n      var contract = new this(target, abi, runner);\n      return contract;\n    }\n  }]);\n  return BaseContract;\n}();\nexports.BaseContract = BaseContract;\nfunction _ContractBase() {\n  return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nvar Contract = /*#__PURE__*/function (_ContractBase2) {\n  _inherits(Contract, _ContractBase2);\n  var _super2 = _createSuper(Contract);\n  function Contract() {\n    _classCallCheck(this, Contract);\n    return _super2.apply(this, arguments);\n  }\n  return _createClass(Contract);\n}(_ContractBase());\nexports.Contract = Contract;","map":{"version":3,"names":["index_js_1","require","index_js_2","provider_js_1","index_js_3","wrappers_js_1","BN_0","BigInt","canCall","value","call","canEstimate","estimateGas","canResolve","resolveName","canSend","sendTransaction","_filter","WeakMap","PreparedTopicFilter","contract","fragment","args","_classCallCheck","_classPrivateFieldInitSpec","writable","_defineProperty","defineProperties","inputs","length","Error","runner","getRunner","resolver","_classPrivateFieldSet","_asyncToGenerator","_regeneratorRuntime","mark","_callee","resolvedArgs","wrap","_callee$","_context","prev","next","Promise","all","map","param","index","arg","walkAsync","type","resolveAddress","sent","abrupt","interface","encodeFilterTopics","stop","_createClass","key","getTopicFilter","_classPrivateFieldGet","feature","provider","getProvider","copyOverrides","_x","_x2","_copyOverrides","apply","arguments","_callee28","allowed","overrides","_callee28$","_context28","copyRequest","Typed","dereference","assertArgument","to","indexOf","data","from","exports","resolveArgs","_x3","_x4","_x5","_resolveArgs","_callee29","_runner","_callee29$","_context29","buildWrappedFallback","populateTransaction","_ref2","_callee2","tx","iface","noValue","noData","payable","_callee2$","_context2","getAddress","getBigInt","fallback","receive","_x6","staticCall","_ref3","_callee3","_callee3$","_context3","assert","operation","t0","isCallException","makeError","_x7","send","_ref4","_callee4","_callee4$","_context4","t1","ContractTransactionResponse","_x8","_ref5","_callee5","_callee5$","_context5","_x9","method","_ref6","_callee6","_callee6$","_context6","_x10","_contract","buildWrappedMethod","getFragment","_len","Array","_key","getFunction","_ref7","_callee7","_len2","_key2","_args7","_callee7$","_context7","pop","Object","t2","resolveProperties","encodeFunctionData","t3","assign","_ref8","_callee8","result","_args8","_callee8$","_context8","staticCallResult","_ref9","_callee9","_args9","_callee9$","_context9","_ref10","_callee10","_args10","_callee10$","_context10","_ref11","_callee11","_args11","_callee11$","_context11","decodeFunctionResult","_ref12","_callee12","_args12","_callee12$","_context12","constant","name","getFunctionName","defineProperty","configurable","enumerable","get","buildWrappedEvent","_len3","_key3","getEvent","_len4","_key4","getEventName","internal","Symbol","for","internalValues","setInternal","values","set","getInternal","isDeferred","getSubInfo","_x11","_x12","_getSubInfo","_callee30","event","topics","topicHashify","tag","_callee30$","_context30","isArray","isHexString","topicHash","e","t","items","Set","toLowerCase","sort","join","hasSub","_x13","_x14","_hasSub","_callee31","_getInternal5","subs","_callee31$","_context31","getSub","_x15","_x16","_x17","_getSub","_callee33","_yield$getSubInfo2","_getInternal6","addr","sub","address","filter","listener","starting","start","_callee33$","_context33","log","foundFragment","error","_foundFragment","decodeEventLog","emit","ContractEventPayload","ContractUnknownEventPayload","push","on","_ref17","_callee32","started","_callee32$","_context32","off","listeners","lastEmit","resolve","_emit","_x18","_x19","_x20","_x21","_emit2","_callee34","payloadFunc","count","_callee34$","_context34","_ref18","once","passArgs","concat","_x22","_x23","_x24","_x25","_emit3","_callee35","resultPromise","_callee35$","_context35","passProperties","BaseContract","target","abi","_deployTx","_this","isAddressable","Interface","addrPromise","deployTx","Map","then","filters","Proxy","_prop","receiver","Reflect","prop","String","has","hasEvent","hasFunction","connect","attach","_getAddress","_callee13","_callee13$","_context13","_getDeployedCode","_callee14","code","_callee14$","_context14","getCode","getDeployedCode","_waitForDeployment","_callee16","_this2","_callee16$","_context16","deploymentTransaction","wait","reject","checkCode","_ref13","_callee15","_code","_callee15$","_context15","waitForDeployment","format","func","_queryTransaction","_callee17","hash","_callee17$","_context17","queryTransaction","_x26","_queryFilter","_callee18","fromBlock","toBlock","_this3","_getInternal","_yield$getSubInfo","_callee18$","_context18","getLogs","EventLog","Log","queryFilter","_x27","_x28","_x29","_on","_callee19","_callee19$","_context19","_x30","_x31","_once","_callee20","_callee20$","_context20","_x32","_x33","_emit5","_callee21","_len5","_key5","_args21","_callee21$","_context21","_x34","_listenerCount","_callee22","_getInternal2","total","_iterator","_step","_callee22$","_context22","_createForOfIteratorHelper","s","n","done","err","f","listenerCount","_x35","_listeners","_callee23","_getInternal3","_iterator2","_step2","_listeners2","_callee23$","_context23","_ref14","_ref15","_x36","_off","_callee24","_callee24$","_context24","_ref16","splice","delete","_x37","_x38","_removeAllListeners","_callee25","_getInternal4","_iterator3","_step3","_step3$value","_callee25$","_context25","removeAllListeners","_x39","_addListener","_callee26","_callee26$","_context26","addListener","_x40","_x41","_removeListener","_callee27","_callee27$","_context27","removeListener","_x42","_x43","buildClass","CustomContract","_BaseContract","_inherits","_super","_createSuper","undefined","_ContractBase","Contract","_ContractBase2","_super2"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/contract/contract.ts"],"sourcesContent":["import { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log, TransactionResponse } from \"../providers/provider.js\";\nimport {\n    defineProperties, getBigInt, isCallException, isHexString, resolveProperties,\n    makeError, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport {\n    ContractEventPayload, ContractUnknownEventPayload,\n    ContractTransactionResponse,\n    EventLog\n} from \"./wrappers.js\";\n\nimport type { EventFragment, FunctionFragment, InterfaceAbi, ParamType, Result } from \"../abi/index.js\";\nimport type { Addressable } from \"../address/index.js\";\nimport type { EventEmitterable, Listener } from \"../utils/index.js\";\nimport type {\n    BlockTag, ContractRunner, Provider, TransactionRequest, TopicFilter\n} from \"../providers/index.js\";\n\nimport type {\n    BaseContractMethod,\n    ContractEventName,\n    ContractInterface,\n    ContractMethodArgs,\n    ContractMethod,\n    ContractEventArgs,\n    ContractEvent,\n    ContractTransaction,\n    DeferredTopicFilter,\n    WrappedFallback\n} from \"./types.js\";\n\nconst BN_0 = BigInt(0);\n\ninterface ContractRunnerCaller extends ContractRunner {\n    call: (tx: TransactionRequest) => Promise<string>;\n}\n\ninterface ContractRunnerEstimater extends ContractRunner {\n    estimateGas: (tx: TransactionRequest) => Promise<bigint>;\n}\n\ninterface ContractRunnerSender extends ContractRunner {\n    sendTransaction: (tx: TransactionRequest) => Promise<TransactionResponse>;\n}\n\ninterface ContractRunnerResolver extends ContractRunner {\n    resolveName: (name: string | Addressable) => Promise<null | string>;\n}\n\nfunction canCall(value: any): value is ContractRunnerCaller {\n    return (value && typeof(value.call) === \"function\");\n}\n\nfunction canEstimate(value: any): value is ContractRunnerEstimater {\n    return (value && typeof(value.estimateGas) === \"function\");\n}\n\nfunction canResolve(value: any): value is ContractRunnerResolver {\n    return (value && typeof(value.resolveName) === \"function\");\n}\n\nfunction canSend(value: any): value is ContractRunnerSender {\n    return (value && typeof(value.sendTransaction) === \"function\");\n}\n\nclass PreparedTopicFilter implements DeferredTopicFilter {\n    #filter: Promise<TopicFilter>;\n    readonly fragment!: EventFragment;\n\n    constructor(contract: BaseContract, fragment: EventFragment, args: Array<any>) {\n        defineProperties<PreparedTopicFilter>(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner: null;\n        this.#filter = (async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) { return null; }\n\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n\n    getTopicFilter(): Promise<TopicFilter> {\n        return this.#filter;\n    }\n}\n\n\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\n\nfunction getRunner<T extends ContractRunner>(value: any, feature: keyof ContractRunner): null | T {\n    if (value == null) { return null; }\n    if (typeof(value[feature]) === \"function\") { return value; }\n    if (value.provider && typeof(value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\n\nfunction getProvider(value: null | ContractRunner): null | Provider {\n    if (value == null) { return null; }\n    return value.provider || null;\n}\n\n/**\n *  @_ignore:\n */\nexport async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(Typed.dereference(arg, \"overrides\"));\n\n    assertArgument(overrides.to == null || (allowed || [ ]).indexOf(\"to\") >= 0,\n      \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || [ ]).indexOf(\"data\") >= 0,\n      \"cannot override data\", \"overrides.data\", overrides.data);\n\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await resolveAddress(overrides.from);\n    }\n\n    return <Omit<ContractTransaction, O>>overrides;\n}\n\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner: null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") { return resolveAddress(value, resolver); }\n            return value;\n        });\n    }));\n}\n\nfunction buildWrappedFallback(contract: BaseContract): WrappedFallback {\n\n    const populateTransaction = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await contract.getAddress();\n\n        const iface = contract.interface;\n\n        const noValue = (getBigInt((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n\n        assertArgument(iface.fallback || noData,\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || noValue,\n          \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || noData,\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    const staticCall = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    const send = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(overrides));\n    }\n\n    const method = async (overrides?: Omit<TransactionRequest, \"to\">) => {\n        return await send(overrides);\n    };\n\n    defineProperties<any>(method, {\n        _contract: contract,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n\n    return <WrappedFallback>method;\n}\n\nfunction buildWrappedMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse>(contract: BaseContract, key: string): BaseContractMethod<A, R, D> {\n\n    const getFragment = function(...args: ContractMethodArgs<A>): FunctionFragment {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n        return fragment;\n    }\n\n    const populateTransaction = async function(...args: ContractMethodArgs<A>): Promise<ContractTransaction> {\n        const fragment = getFragment(...args);\n\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides: Omit<ContractTransaction, \"data\" | \"to\"> = { };\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n\n        return Object.assign({ }, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    }\n\n    const staticCall = async function(...args: ContractMethodArgs<A>): Promise<R> {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) { return result[0]; }\n        return <R><unknown>result;\n    }\n\n    const send = async function(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(...args: ContractMethodArgs<A>): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(...args));\n    }\n\n    const staticCallResult = async function(...args: ContractMethodArgs<A>): Promise<Result> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(...args);\n\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n\n    const method = async (...args: ContractMethodArgs<A>) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) { return await staticCall(...args); }\n        return await send(...args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n\n        getFragment,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n            return fragment;\n        }\n    });\n\n    return <BaseContractMethod<A, R, D>>method;\n}\n\nfunction buildWrappedEvent<A extends Array<any> = Array<any>>(contract: BaseContract, key: string): ContractEvent<A> {\n\n    const getFragment = function(...args: ContractEventArgs<A>): EventFragment {\n        const fragment = contract.interface.getEvent(key, args);\n\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n\n        return fragment;\n    }\n\n    const method = function(...args: ContractMethodArgs<A>): PreparedTopicFilter {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n\n        getFragment\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n\n            return fragment;\n        }\n    });\n\n    return <ContractEvent<A>><unknown>method;\n}\n\ntype Sub = {\n    tag: string;\n    listeners: Array<{ listener: Listener, once: boolean }>,\n    start: () => void;\n    stop: () => void;\n};\n\n\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\n\nconst internal = Symbol.for(\"_ethersInternal_contract\");\ntype Internal = {\n    addrPromise: Promise<string>;\n    addr: null | string;\n\n    deployTx: null | ContractTransactionResponse;\n\n    subs: Map<string, Sub>;\n};\n\nconst internalValues: WeakMap<BaseContract, Internal> = new WeakMap();\n\nfunction setInternal(contract: BaseContract, values: Internal): void {\n    internalValues.set(contract[internal], values);\n}\n\nfunction getInternal(contract: BaseContract): Internal {\n    return internalValues.get(contract[internal]) as Internal;\n}\n\nfunction isDeferred(value: any): value is DeferredTopicFilter {\n    return (value && typeof(value) === \"object\" && (\"getTopicFilter\" in value) &&\n      (typeof(value.getTopicFilter) === \"function\") && value.fragment);\n}\n\nasync function getSubInfo(contract: BaseContract, event: ContractEventName): Promise<{ fragment: null | EventFragment, tag: string, topics: TopicFilter }> {\n    let topics: Array<null | string | Array<string>>;\n    let fragment: null | EventFragment = null;\n\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n\n    if (Array.isArray(event)) {\n        const topicHashify = function(name: string): string {\n            if (isHexString(name, 32)) { return name; }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        }\n\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) { return null; }\n            if (Array.isArray(e)) { return e.map(topicHashify); }\n            return topicHashify(e);\n        });\n\n    } else if (event === \"*\") {\n        topics = [ null ];\n\n    } else if (typeof(event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [ event ];\n        } else {\n           // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [ fragment.topicHash ];\n        }\n\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [ fragment.topicHash ];\n\n    } else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) { return null; }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) { return items[0]; }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n\n    const tag = topics.map((t) => {\n        if (t == null) { return \"null\"; }\n        if (Array.isArray(t)) { return t.join(\"|\"); }\n        return t;\n    }).join(\"&\");\n\n    return { fragment, tag, topics }\n}\n\nasync function hasSub(contract: BaseContract, event: ContractEventName): Promise<null | Sub> {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\n\nasync function getSub(contract: BaseContract, operation: string, event: ContractEventName): Promise<Sub> {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\",\n        \"UNSUPPORTED_OPERATION\", { operation });\n\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n\n    const { addr, subs } = getInternal(contract);\n\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address: string | Addressable = (addr ? addr: contract);\n        const filter = { address, topics };\n        const listener = (log: Log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            // If fragment is null, we do not deconstruct the args to emit\n\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics): [ ];\n                emit(contract, event, args, (listener: null | Listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [ ], (listener: null | Listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n\n        let starting: Array<Promise<any>> = [ ];\n        const start = () => {\n            if (starting.length) { return; }\n            starting.push(provider.on(filter, listener));\n        };\n\n        const stop = async () => {\n            if (starting.length == 0) { return; }\n\n            let started = starting;\n            starting = [ ];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n\n        sub = { tag, listeners: [ ], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit: Promise<any> = Promise.resolve();\n\ntype PayloadFunc = (listener: null | Listener) => ContractUnknownEventPayload;\n\nasync function _emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    await lastEmit;\n\n    const sub = await hasSub(contract, event);\n    if (!sub) { return false; }\n\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null: listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) { }\n        return !once;\n    });\n    return (count > 0);\n}\n\nasync function emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    try {\n        await lastEmit;\n    } catch (error) { }\n\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\n\nconst passProperties = [ \"then\" ];\nexport class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    readonly target!: string | Addressable;\n\n    /**\n     *  The contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    readonly runner!: null | ContractRunner;\n\n    /**\n     *  All the Events available on this contract.\n     */\n    readonly filters!: Record<string, ContractEvent>;\n\n    /**\n     *  @_ignore:\n     */\n    readonly [internal]: any;\n\n    /**\n     *  The fallback or receive function if any.\n     */\n    readonly fallback!: null | WrappedFallback;\n\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target: string | Addressable, abi: Interface | InterfaceAbi, runner?: null | ContractRunner, _deployTx?: null | TransactionResponse) {\n        assertArgument(typeof(target) === \"string\" || isAddressable(target),\n            \"invalid value for Contract target\", \"target\", target);\n\n        if (runner == null) { runner = null; }\n        const iface = Interface.from(abi);\n        defineProperties<BaseContract>(this, { target, runner, interface: iface });\n\n        Object.defineProperty(this, internal, { value: { } });\n\n        let addrPromise;\n        let addr = null;\n\n        let deployTx: null | ContractTransactionResponse = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, <Provider>provider, _deployTx);\n        }\n\n        let subs = new Map();\n\n        // Resolve the target as the address\n        if (typeof(target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) { throw new Error(\"TODO\"); }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) { throw new Error(\"TODO\"); }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n\n        // Add the event filters\n        const filters = new Proxy({ }, {\n            get: (target, _prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = this.getEvent(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract event: ${ prop }`);\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties<BaseContract>(this, { filters });\n\n        defineProperties<BaseContract>(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)): null)\n        });\n\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, _prop, receiver) => {\n                if (_prop in target || passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = target.getFunction(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract method: ${ prop }`);\n            },\n            has: (target, prop) => {\n                if (prop in target || passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return target.interface.hasFunction(String(prop));\n            }\n        });\n\n    }\n\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner: null | ContractRunner): BaseContract {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target: string | Addressable): BaseContract {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress(): Promise<string> { return await getInternal(this).addrPromise; }\n\n    /**\n     *  Return the dedployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode(): Promise<null | string> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") { return null; }\n        return code;\n    }\n\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment(): Promise<this> {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) { return this; }\n\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) { return resolve(this); }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction(): null | ContractTransactionResponse {\n        return getInternal(this).deployTx;\n    }\n\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        const func = buildWrappedMethod(this, key);\n        return <T>func;\n    }\n\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key: string | EventFragment): ContractEvent {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        return buildWrappedEvent(this, key);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash: string): Promise<Array<EventLog>> {\n        // Is this useful?\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event: ContractEventName, fromBlock?: BlockTag, toBlock?: BlockTag): Promise<Array<EventLog | Log>> {\n        if (fromBlock == null) { fromBlock = 0; }\n        if (toBlock == null) { toBlock = \"latest\"; }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr: (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            if (foundFragment) {\n                return new EventLog(log, this.interface, foundFragment);\n            } else {\n                return new Log(log, provider);\n            }\n        });\n    }\n\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event: ContractEventName, ...args: Array<any>): Promise<boolean> {\n        return await emit(this, event, args, null);\n    }\n\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event?: ContractEventName): Promise<number> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        const { subs } = getInternal(this);\n\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event?: ContractEventName): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n\n        const { subs } = getInternal(this);\n\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event: ContractEventName, listener?: Listener): Promise<this> {\n        const sub = await hasSub(this, event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event?: ContractEventName): Promise<this> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return this; }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.on(event, listener);\n    }\n\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.off(event, listener);\n    }\n\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass<T = ContractInterface>(abi: Interface | InterfaceAbi): new (target: string, runner?: null | ContractRunner) => BaseContract & Omit<T, keyof BaseContract> {\n        class CustomContract extends BaseContract {\n            constructor(address: string, runner: null | ContractRunner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract as any;\n    };\n\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from<T = ContractInterface>(target: string, abi: Interface | InterfaceAbi, runner?: null | ContractRunner): BaseContract & Omit<T, keyof BaseContract> {\n        if (runner == null) { runner = null; }\n        const contract = new this(target, abi, runner );\n        return contract as any;\n    }\n}\n\nfunction _ContractBase(): new (target: string, abi: Interface | InterfaceAbi, runner?: null | ContractRunner) => BaseContract & Omit<ContractInterface, keyof BaseContract> {\n    return BaseContract as any;\n}\n\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport class Contract extends _ContractBase() { }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}