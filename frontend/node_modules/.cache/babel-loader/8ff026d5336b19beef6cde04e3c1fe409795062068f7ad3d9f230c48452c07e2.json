{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classStaticPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classStaticPrivateMethodGet.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;\n/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */\nvar index_js_1 = require(\"../crypto/index.js\");\nvar index_js_2 = require(\"../providers/index.js\");\nvar index_js_3 = require(\"../transaction/index.js\");\nvar index_js_4 = require(\"../utils/index.js\");\nvar lang_en_js_1 = require(\"../wordlists/lang-en.js\");\nvar base_wallet_js_1 = require(\"./base-wallet.js\");\nvar mnemonic_js_1 = require(\"./mnemonic.js\");\nvar json_keystore_js_1 = require(\"./json-keystore.js\");\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */\nexports.defaultPath = \"m/44'/60'/0'/0/0\";\n// \"Bitcoin seed\"\nvar MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\nvar HardenedBit = 0x80000000;\nvar N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nvar Nibbles = \"0123456789abcdef\";\nfunction zpad(value, length) {\n  var result = \"\";\n  while (value) {\n    result = Nibbles[value % 16] + result;\n    value = Math.trunc(value / 16);\n  }\n  while (result.length < length * 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction encodeBase58Check(_value) {\n  var value = (0, index_js_4.getBytes)(_value);\n  var check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);\n  var bytes = (0, index_js_4.concat)([value, check]);\n  return (0, index_js_4.encodeBase58)(bytes);\n}\nvar _guard = {};\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n  var data = new Uint8Array(37);\n  if (index & HardenedBit) {\n    (0, index_js_4.assert)(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"deriveChild\"\n    });\n    // Data = 0x00 || ser_256(k_par)\n    data.set((0, index_js_4.getBytes)(privateKey), 1);\n  } else {\n    // Data = ser_p(point(k_par))\n    data.set((0, index_js_4.getBytes)(publicKey));\n  }\n  // Data += ser_32(i)\n  for (var i = 24; i >= 0; i -= 8) {\n    data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n  }\n  var I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)(\"sha512\", chainCode, data));\n  return {\n    IL: I.slice(0, 32),\n    IR: I.slice(32)\n  };\n}\nfunction _derivePath(node, path) {\n  var components = path.split(\"/\");\n  (0, index_js_4.assertArgument)(components.length > 0 && (components[0] === \"m\" || node.depth > 0), \"invalid path\", \"path\", path);\n  if (components[0] === \"m\") {\n    components.shift();\n  }\n  var result = node;\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n    if (component.match(/^[0-9]+'$/)) {\n      var index = parseInt(component.substring(0, component.length - 1));\n      (0, index_js_4.assertArgument)(index < HardenedBit, \"invalid path index\", \"path[\".concat(i, \"]\"), component);\n      result = result.deriveChild(HardenedBit + index);\n    } else if (component.match(/^[0-9]+$/)) {\n      var _index2 = parseInt(component);\n      (0, index_js_4.assertArgument)(_index2 < HardenedBit, \"invalid path index\", \"path[\".concat(i, \"]\"), component);\n      result = result.deriveChild(_index2);\n    } else {\n      (0, index_js_4.assertArgument)(false, \"invalid path component\", \"path[\".concat(i, \"]\"), component);\n    }\n  }\n  return result;\n}\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */\nvar _account = /*#__PURE__*/new WeakSet();\nvar HDNodeWallet = /*#__PURE__*/function (_base_wallet_js_1$Bas) {\n  _inherits(HDNodeWallet, _base_wallet_js_1$Bas);\n  var _super = _createSuper(HDNodeWallet);\n  /**\n   *  @private\n   */\n  function HDNodeWallet(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\n    var _this;\n    _classCallCheck(this, HDNodeWallet);\n    _this = _super.call(this, signingKey, provider);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _account);\n    /**\n     *  The compressed public key.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"publicKey\", void 0);\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"fingerprint\", void 0);\n    /**\n     *  The parent fingerprint.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"parentFingerprint\", void 0);\n    /**\n     *  The mnemonic used to create this HD Node, if available.\n     *\n     *  Sources such as extended keys do not encode the mnemonic, in\n     *  which case this will be ``null``.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"mnemonic\", void 0);\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"chainCode\", void 0);\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"path\", void 0);\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"index\", void 0);\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"depth\", void 0);\n    (0, index_js_4.assertPrivate)(guard, _guard, \"HDNodeWallet\");\n    (0, index_js_4.defineProperties)(_assertThisInitialized(_this), {\n      publicKey: signingKey.compressedPublicKey\n    });\n    var fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(_this.publicKey)), 0, 4);\n    (0, index_js_4.defineProperties)(_assertThisInitialized(_this), {\n      parentFingerprint: parentFingerprint,\n      fingerprint: fingerprint,\n      chainCode: chainCode,\n      path: path,\n      index: index,\n      depth: depth\n    });\n    (0, index_js_4.defineProperties)(_assertThisInitialized(_this), {\n      mnemonic: mnemonic\n    });\n    return _this;\n  }\n  _createClass(HDNodeWallet, [{\n    key: \"connect\",\n    value: function connect(provider) {\n      return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n  }, {\n    key: \"encrypt\",\n    value:\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    function () {\n      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, progressCallback) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return (0, json_keystore_js_1.encryptKeystoreJson)(_classPrivateMethodGet(this, _account, _account2).call(this), password, {\n                progressCallback: progressCallback\n              });\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function encrypt(_x, _x2) {\n        return _encrypt.apply(this, arguments);\n      }\n      return encrypt;\n    }()\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n  }, {\n    key: \"encryptSync\",\n    value: function encryptSync(password) {\n      return (0, json_keystore_js_1.encryptKeystoreJsonSync)(_classPrivateMethodGet(this, _account, _account2).call(this), password);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */\n  }, {\n    key: \"extendedKey\",\n    get: function get() {\n      // We only support the mainnet values for now, but if anyone needs\n      // testnet values, let me know. I believe current sentiment is that\n      // we should always use mainnet, and use BIP-44 to derive the network\n      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n      //   - Testnet: public=0x043587CF, private=0x04358394\n      (0, index_js_4.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"extendedKey\"\n      });\n      return encodeBase58Check((0, index_js_4.concat)([\"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, (0, index_js_4.concat)([\"0x00\", this.privateKey])]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n  }, {\n    key: \"hasPath\",\n    value: function hasPath() {\n      return this.path != null;\n    }\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */\n  }, {\n    key: \"neuter\",\n    value: function neuter() {\n      return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n    }\n    /**\n     *  Return the child for %%index%%.\n     */\n  }, {\n    key: \"deriveChild\",\n    value: function deriveChild(_index) {\n      var index = (0, index_js_4.getNumber)(_index, \"index\");\n      (0, index_js_4.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n      // Base path\n      var path = this.path;\n      if (path) {\n        path += \"/\" + (index & ~HardenedBit);\n        if (index & HardenedBit) {\n          path += \"'\";\n        }\n      }\n      var _ser_I = ser_I(index, this.chainCode, this.publicKey, this.privateKey),\n        IR = _ser_I.IR,\n        IL = _ser_I.IL;\n      var ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));\n      return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n    }\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */\n  }, {\n    key: \"derivePath\",\n    value: function derivePath(path) {\n      return _derivePath(this, path);\n    }\n  }], [{\n    key: \"fromExtendedKey\",\n    value:\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */\n    function fromExtendedKey(extendedKey) {\n      var bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey)); // @TODO: redact\n      (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n      var depth = bytes[4];\n      var parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));\n      var index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n      var chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));\n      var key = bytes.slice(45, 78);\n      switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {\n        // Public Key\n        case \"0x0488b21e\":\n        case \"0x043587cf\":\n          {\n            var publicKey = (0, index_js_4.hexlify)(key);\n            return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n          }\n        // Private Key\n        case \"0x0488ade4\":\n        case \"0x04358394 \":\n          if (key[0] !== 0) {\n            break;\n          }\n          return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n      }\n      (0, index_js_4.assertArgument)(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n    /**\n     *  Creates a new random HDNode.\n     */\n  }, {\n    key: \"createRandom\",\n    value: function createRandom(password, path, wordlist) {\n      if (password == null) {\n        password = \"\";\n      }\n      if (path == null) {\n        path = exports.defaultPath;\n      }\n      if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n      }\n      var mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);\n      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */\n  }, {\n    key: \"fromMnemonic\",\n    value: function fromMnemonic(mnemonic, path) {\n      if (!path) {\n        path = exports.defaultPath;\n      }\n      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */\n  }, {\n    key: \"fromPhrase\",\n    value: function fromPhrase(phrase, password, path, wordlist) {\n      if (password == null) {\n        password = \"\";\n      }\n      if (path == null) {\n        path = exports.defaultPath;\n      }\n      if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n      }\n      var mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);\n      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */\n  }, {\n    key: \"fromSeed\",\n    value: function fromSeed(seed) {\n      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, seed, null);\n    }\n  }]);\n  return HDNodeWallet;\n}(base_wallet_js_1.BaseWallet);\nfunction _account2() {\n  var account = {\n    address: this.address,\n    privateKey: this.privateKey\n  };\n  var m = this.mnemonic;\n  if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n    account.mnemonic = {\n      path: this.path,\n      locale: \"en\",\n      entropy: m.entropy\n    };\n  }\n  return account;\n}\nfunction _fromSeed(_seed, mnemonic) {\n  (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n  var seed = (0, index_js_4.getBytes)(_seed, \"seed\");\n  (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n  var I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)(\"sha512\", MasterSecret, seed));\n  var signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));\n  return new HDNodeWallet(_guard, signingKey, \"0x00000000\", (0, index_js_4.hexlify)(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n}\nexports.HDNodeWallet = HDNodeWallet;\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */\nvar HDNodeVoidWallet = /*#__PURE__*/function (_index_js_2$VoidSigne) {\n  _inherits(HDNodeVoidWallet, _index_js_2$VoidSigne);\n  var _super2 = _createSuper(HDNodeVoidWallet);\n  /**\n   *  @private\n   */\n  function HDNodeVoidWallet(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\n    var _this2;\n    _classCallCheck(this, HDNodeVoidWallet);\n    _this2 = _super2.call(this, address, provider);\n    /**\n     *  The compressed public key.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"publicKey\", void 0);\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"fingerprint\", void 0);\n    /**\n     *  The parent node fingerprint.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"parentFingerprint\", void 0);\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"chainCode\", void 0);\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"path\", void 0);\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"index\", void 0);\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    _defineProperty(_assertThisInitialized(_this2), \"depth\", void 0);\n    (0, index_js_4.assertPrivate)(guard, _guard, \"HDNodeVoidWallet\");\n    (0, index_js_4.defineProperties)(_assertThisInitialized(_this2), {\n      publicKey: publicKey\n    });\n    var fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);\n    (0, index_js_4.defineProperties)(_assertThisInitialized(_this2), {\n      publicKey: publicKey,\n      fingerprint: fingerprint,\n      parentFingerprint: parentFingerprint,\n      chainCode: chainCode,\n      path: path,\n      index: index,\n      depth: depth\n    });\n    return _this2;\n  }\n  _createClass(HDNodeVoidWallet, [{\n    key: \"connect\",\n    value: function connect(provider) {\n      return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */\n  }, {\n    key: \"extendedKey\",\n    get: function get() {\n      // We only support the mainnet values for now, but if anyone needs\n      // testnet values, let me know. I believe current sentiment is that\n      // we should always use mainnet, and use BIP-44 to derive the network\n      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n      //   - Testnet: public=0x043587CF, private=0x04358394\n      (0, index_js_4.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"extendedKey\"\n      });\n      return encodeBase58Check((0, index_js_4.concat)([\"0x0488B21E\", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n  }, {\n    key: \"hasPath\",\n    value: function hasPath() {\n      return this.path != null;\n    }\n    /**\n     *  Return the child for %%index%%.\n     */\n  }, {\n    key: \"deriveChild\",\n    value: function deriveChild(_index) {\n      var index = (0, index_js_4.getNumber)(_index, \"index\");\n      (0, index_js_4.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n      // Base path\n      var path = this.path;\n      if (path) {\n        path += \"/\" + (index & ~HardenedBit);\n        if (index & HardenedBit) {\n          path += \"'\";\n        }\n      }\n      var _ser_I2 = ser_I(index, this.chainCode, this.publicKey, null),\n        IR = _ser_I2.IR,\n        IL = _ser_I2.IL;\n      var Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);\n      var address = (0, index_js_3.computeAddress)(Ki);\n      return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);\n    }\n    /**\n     *  Return the signer for %%path%% from this node.\n     */\n  }, {\n    key: \"derivePath\",\n    value: function derivePath(path) {\n      return _derivePath(this, path);\n    }\n  }]);\n  return HDNodeVoidWallet;\n}(index_js_2.VoidSigner);\nexports.HDNodeVoidWallet = HDNodeVoidWallet;\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/\n/**\n *  Returns the [[link-bip-32]] path for the acount at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */\nfunction getAccountPath(_index) {\n  var index = (0, index_js_4.getNumber)(_index, \"index\");\n  (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n  return \"m/44'/60'/\".concat(index, \"'/0/0\");\n}\nexports.getAccountPath = getAccountPath;\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */\nfunction getIndexedAccountPath(_index) {\n  var index = (0, index_js_4.getNumber)(_index, \"index\");\n  (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n  return \"m/44'/60'/0'/0/\".concat(index);\n}\nexports.getIndexedAccountPath = getIndexedAccountPath;","map":{"version":3,"names":["index_js_1","require","index_js_2","index_js_3","index_js_4","lang_en_js_1","base_wallet_js_1","mnemonic_js_1","json_keystore_js_1","exports","defaultPath","MasterSecret","Uint8Array","HardenedBit","N","BigInt","Nibbles","zpad","value","length","result","Math","trunc","encodeBase58Check","_value","getBytes","check","dataSlice","sha256","bytes","concat","encodeBase58","_guard","ser_I","index","chainCode","publicKey","privateKey","data","assert","operation","set","i","I","computeHmac","IL","slice","IR","derivePath","node","path","components","split","assertArgument","depth","shift","component","match","parseInt","substring","deriveChild","_account","WeakSet","HDNodeWallet","_base_wallet_js_1$Bas","_inherits","_super","_createSuper","guard","signingKey","parentFingerprint","mnemonic","provider","_this","_classCallCheck","call","_classPrivateMethodInitSpec","_assertThisInitialized","_defineProperty","assertPrivate","defineProperties","compressedPublicKey","fingerprint","ripemd160","_createClass","key","connect","_encrypt","_asyncToGenerator","_regeneratorRuntime","mark","_callee","password","progressCallback","wrap","_callee$","_context","prev","next","encryptKeystoreJson","_classPrivateMethodGet","_account2","abrupt","sent","stop","encrypt","_x","_x2","apply","arguments","encryptSync","encryptKeystoreJsonSync","get","hasPath","neuter","HDNodeVoidWallet","address","_index","getNumber","_ser_I","ki","SigningKey","toBeHex","toBigInt","hexlify","fromExtendedKey","extendedKey","toBeArray","decodeBase58","computeAddress","createRandom","wordlist","LangEn","Mnemonic","fromEntropy","randomBytes","_classStaticPrivateMethodGet","_fromSeed","computeSeed","fromMnemonic","fromPhrase","phrase","fromSeed","seed","BaseWallet","account","m","locale","entropy","_seed","isBytesLike","_index_js_2$VoidSigne","_super2","_this2","_ser_I2","Ki","addPoints","VoidSigner","getAccountPath","getIndexedAccountPath"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/wallet/hdwallet.ts"],"sourcesContent":["/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */\nimport { computeHmac, randomBytes, ripemd160, SigningKey, sha256 } from \"../crypto/index.js\";\nimport { VoidSigner } from \"../providers/index.js\";\nimport { computeAddress } from \"../transaction/index.js\";\nimport {\n    concat, dataSlice, decodeBase58, defineProperties, encodeBase58,\n    getBytes, hexlify, isBytesLike,\n    getNumber, toBeArray, toBigInt, toBeHex,\n    assertPrivate, assert, assertArgument\n} from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\nimport {\n    encryptKeystoreJson, encryptKeystoreJsonSync,\n} from \"./json-keystore.js\";\n\nimport type { ProgressCallback } from \"../crypto/index.js\";\nimport type { Provider } from \"../providers/index.js\";\nimport type { BytesLike, Numeric } from \"../utils/index.js\";\nimport type { Wordlist } from \"../wordlists/index.js\";\n\nimport type { KeystoreAccount } from \"./json-keystore.js\";\n\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */\nexport const defaultPath: string = \"m/44'/60'/0'/0/0\";\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([ 66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100 ]);\n\nconst HardenedBit = 0x80000000;\n\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value: number, length: number): string {\n    let result = \"\";\n    while (value) {\n        result = Nibbles[value % 16] + result;\n        value = Math.trunc(value / 16);\n    }\n    while (result.length < length * 2) { result = \"0\" + result; }\n    return \"0x\" + result;\n}\n\nfunction encodeBase58Check(_value: BytesLike): string {\n    const value = getBytes(_value);\n    const check = dataSlice(sha256(sha256(value)), 0, 4);\n    const bytes = concat([ value, check ]);\n    return encodeBase58(bytes);\n}\n\nconst _guard = { };\n\nfunction ser_I(index: number, chainCode: string, publicKey: string, privateKey: null | string): { IL: Uint8Array, IR: Uint8Array } {\n    const data = new Uint8Array(37);\n\n    if (index & HardenedBit) {\n        assert(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"deriveChild\"\n        });\n\n        // Data = 0x00 || ser_256(k_par)\n        data.set(getBytes(privateKey), 1);\n\n    } else {\n        // Data = ser_p(point(k_par))\n        data.set(getBytes(publicKey));\n    }\n\n    // Data += ser_32(i)\n    for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n    const I = getBytes(computeHmac(\"sha512\", chainCode, data));\n\n    return { IL: I.slice(0, 32), IR: I.slice(32) };\n}\n\ntype HDNodeLike<T> = { depth: number, deriveChild: (i: number) => T };\nfunction derivePath<T extends HDNodeLike<T>>(node: T, path: string): T {\n    const components = path.split(\"/\");\n\n    assertArgument(components.length > 0 && (components[0] === \"m\" || node.depth > 0), \"invalid path\", \"path\", path);\n\n    if (components[0] === \"m\") { components.shift(); }\n\n    let result: T = node;\n    for (let i = 0; i < components.length; i++) {\n        const component = components[i];\n\n        if (component.match(/^[0-9]+'$/)) {\n            const index = parseInt(component.substring(0, component.length - 1));\n            assertArgument(index < HardenedBit, \"invalid path index\", `path[${ i }]`, component);\n            result = result.deriveChild(HardenedBit + index);\n\n        } else if (component.match(/^[0-9]+$/)) {\n            const index = parseInt(component);\n            assertArgument(index < HardenedBit, \"invalid path index\", `path[${ i }]`, component);\n            result = result.deriveChild(index);\n\n        } else {\n            assertArgument(false, \"invalid path component\", `path[${ i }]`, component);\n        }\n    }\n\n    return result;\n}\n\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */\nexport class HDNodeWallet extends BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    readonly fingerprint!: string;\n\n    /**\n     *  The parent fingerprint.\n     */\n    readonly parentFingerprint!: string;\n\n    /**\n     *  The mnemonic used to create this HD Node, if available.\n     *\n     *  Sources such as extended keys do not encode the mnemonic, in\n     *  which case this will be ``null``.\n     */\n    readonly mnemonic!: null | Mnemonic;\n\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    readonly chainCode!: string;\n\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    readonly path!: null | string;\n\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    readonly index!: number;\n\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    readonly depth!: number;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, signingKey: SigningKey, parentFingerprint: string, chainCode: string, path: null | string, index: number, depth: number, mnemonic: null | Mnemonic, provider: null | Provider) {\n        super(signingKey, provider);\n        assertPrivate(guard, _guard, \"HDNodeWallet\");\n\n        defineProperties<HDNodeWallet>(this, { publicKey: signingKey.compressedPublicKey });\n\n        const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);\n        defineProperties<HDNodeWallet>(this, {\n            parentFingerprint, fingerprint,\n            chainCode, path, index, depth\n        });\n\n        defineProperties<HDNodeWallet>(this, { mnemonic });\n    }\n\n    connect(provider: null | Provider): HDNodeWallet {\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint,\n            this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n\n    #account(): KeystoreAccount {\n        const account: KeystoreAccount = { address: this.address, privateKey: this.privateKey };\n        const m = this.mnemonic;\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n            account.mnemonic = {\n                path: this.path,\n                locale: \"en\",\n                entropy: m.entropy\n            };\n        }\n\n        return account;\n    }\n\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password: Uint8Array | string, progressCallback?: ProgressCallback): Promise<string> {\n        return await encryptKeystoreJson(this.#account(), password, { progressCallback });\n    }\n\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password: Uint8Array | string): string {\n        return encryptKeystoreJsonSync(this.#account(), password);\n    }\n\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n\n        return encodeBase58Check(concat([\n            \"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint,\n            zpad(this.index, 4), this.chainCode,\n            concat([ \"0x00\", this.privateKey ])\n        ]));\n    }\n\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath(): this is { path: string } { return (this.path != null); }\n\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */\n    neuter(): HDNodeVoidWallet {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey,\n            this.parentFingerprint, this.chainCode, this.path, this.index,\n            this.depth, this.provider);\n    }\n\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index: Numeric): HDNodeWallet {\n        const index = getNumber(_index, \"index\");\n        assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index);\n\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) { path += \"'\"; }\n        }\n\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n        const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));\n\n        return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR),\n            path, index, this.depth + 1, this.mnemonic, this.provider);\n\n    }\n\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */\n    derivePath(path: string): HDNodeWallet {\n        return derivePath<HDNodeWallet>(this, path);\n    }\n\n    static #fromSeed(_seed: BytesLike, mnemonic: null | Mnemonic): HDNodeWallet {\n        assertArgument(isBytesLike(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n\n        const seed = getBytes(_seed, \"seed\");\n        assertArgument(seed.length >= 16 && seed.length <= 64 , \"invalid seed\", \"seed\", \"[REDACTED]\");\n\n        const I = getBytes(computeHmac(\"sha512\", MasterSecret, seed));\n        const signingKey = new SigningKey(hexlify(I.slice(0, 32)));\n\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", hexlify(I.slice(32)),\n            \"m\", 0, 0, mnemonic, null);\n    }\n\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */\n    static fromExtendedKey(extendedKey: string): HDNodeWallet | HDNodeVoidWallet {\n        const bytes = toBeArray(decodeBase58(extendedKey)); // @TODO: redact\n\n        assertArgument(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey,\n            \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\": {\n                const publicKey = hexlify(key);\n                return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey,\n                    parentFingerprint, chainCode, null, index, depth, null);\n            }\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNodeWallet(_guard, new SigningKey(key.slice(1)),\n                    parentFingerprint, chainCode, null, index, depth, null, null);\n        }\n\n\n        assertArgument(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n\n    /**\n     *  Creates a new random HDNode.\n     */\n    static createRandom(password?: string, path?: string, wordlist?: Wordlist): HDNodeWallet {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = defaultPath; }\n        if (wordlist == null) { wordlist = LangEn.wordlist(); }\n        const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist)\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */\n    static fromMnemonic(mnemonic: Mnemonic, path?: string): HDNodeWallet {\n        if (!path) { path = defaultPath; }\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */\n    static fromPhrase(phrase: string, password?: string, path?: string, wordlist?: Wordlist): HDNodeWallet {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = defaultPath; }\n        if (wordlist == null) { wordlist = LangEn.wordlist(); }\n        const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist)\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */\n    static fromSeed(seed: BytesLike): HDNodeWallet {\n        return HDNodeWallet.#fromSeed(seed, null);\n    }\n}\n\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by \n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */\nexport class HDNodeVoidWallet extends VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    readonly fingerprint!: string;\n\n    /**\n     *  The parent node fingerprint.\n     */\n    readonly parentFingerprint!: string;\n\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    readonly chainCode!: string;\n\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    readonly path!: null | string;\n\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    readonly index!: number;\n\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    readonly depth!: number;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, address: string, publicKey: string, parentFingerprint: string, chainCode: string, path: null | string, index: number, depth: number, provider: null | Provider) {\n        super(address, provider);\n        assertPrivate(guard, _guard, \"HDNodeVoidWallet\");\n\n        defineProperties<HDNodeVoidWallet>(this, { publicKey });\n\n        const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);\n        defineProperties<HDNodeVoidWallet>(this, {\n            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth\n        });\n    }\n\n    connect(provider: null | Provider): HDNodeVoidWallet {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey,\n            this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n\n        return encodeBase58Check(concat([\n            \"0x0488B21E\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            this.publicKey,\n        ]));\n    }\n\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath(): this is { path: string } { return (this.path != null); }\n\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index: Numeric): HDNodeVoidWallet {\n        const index = getNumber(_index, \"index\");\n        assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index);\n\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) { path += \"'\"; }\n        }\n\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\n        const Ki = SigningKey.addPoints(IL, this.publicKey, true);\n\n        const address = computeAddress(Ki);\n\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR),\n            path, index, this.depth + 1, this.provider);\n\n    }\n\n    /**\n     *  Return the signer for %%path%% from this node.\n     */\n    derivePath(path: string): HDNodeVoidWallet {\n        return derivePath<HDNodeVoidWallet>(this, path);\n    }\n}\n\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/\n\n/**\n *  Returns the [[link-bip-32]] path for the acount at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */\nexport function getAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${ index }'/0/0`;\n}\n\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */\nexport function getIndexedAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${ index}`;\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}