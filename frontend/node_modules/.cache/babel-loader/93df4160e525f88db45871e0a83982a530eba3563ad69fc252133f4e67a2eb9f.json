{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;\nvar index_js_1 = require(\"../utils/index.js\");\nvar address_js_1 = require(\"./address.js\");\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nfunction isAddressable(value) {\n  return value && typeof value.getAddress === \"function\";\n}\nexports.isAddressable = isAddressable;\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nfunction isAddress(value) {\n  try {\n    (0, address_js_1.getAddress)(value);\n    return true;\n  } catch (error) {}\n  return false;\n}\nexports.isAddress = isAddress;\nfunction checkAddress(_x, _x2) {\n  return _checkAddress.apply(this, arguments);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nfunction _checkAddress() {\n  _checkAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(target, promise) {\n    var result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return promise;\n        case 2:\n          result = _context.sent;\n          if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n            (0, index_js_1.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n              value: target\n            });\n            (0, index_js_1.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n          }\n          return _context.abrupt(\"return\", (0, address_js_1.getAddress)(result));\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _checkAddress.apply(this, arguments);\n}\nfunction resolveAddress(target, resolver) {\n  if (typeof target === \"string\") {\n    if (target.match(/^0x[0-9a-f]{40}$/i)) {\n      return (0, address_js_1.getAddress)(target);\n    }\n    (0, index_js_1.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"resolveName\"\n    });\n    return checkAddress(target, resolver.resolveName(target));\n  } else if (isAddressable(target)) {\n    return checkAddress(target, target.getAddress());\n  } else if (target && typeof target.then === \"function\") {\n    return checkAddress(target, target);\n  }\n  (0, index_js_1.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\nexports.resolveAddress = resolveAddress;","map":{"version":3,"names":["index_js_1","require","address_js_1","isAddressable","value","getAddress","exports","isAddress","error","checkAddress","_x","_x2","_checkAddress","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","target","promise","result","wrap","_callee$","_context","prev","next","sent","assert","assertArgument","abrupt","stop","resolveAddress","resolver","match","operation","resolveName","then"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/address/checks.ts"],"sourcesContent":["import { assert, assertArgument } from \"../utils/index.js\";\n\nimport { getAddress } from \"./address.js\";\n\nimport type { Addressable, AddressLike, NameResolver } from \"./index.js\";\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nexport function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}\n\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nexport function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nasync function checkAddress(target: any, promise: Promise<null | string>): Promise<string> {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        assert(typeof(target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return getAddress(result);\n}\n\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nexport function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n\n        return checkAddress(target, resolver.resolveName(target));\n\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n\n    } else if (target && typeof(target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n\n    assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,UAAA,GAAAC,OAAA;AAEA,IAAAC,YAAA,GAAAD,OAAA;AAKA;;;;;;;;;;;;;;AAcA,SAAgBE,aAAaA,CAACC,KAAU;EACpC,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACC,UAAW,KAAK,UAAU;AAC5D;AAFAC,OAAA,CAAAH,aAAA,GAAAA,aAAA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,SAAgBI,SAASA,CAACH,KAAU;EAChC,IAAI;IACA,IAAAF,YAAA,CAAAG,UAAU,EAACD,KAAK,CAAC;IACjB,OAAO,IAAI;GACd,CAAC,OAAOI,KAAK,EAAE;EAChB,OAAO,KAAK;AAChB;AANAF,OAAA,CAAAC,SAAA,GAAAA,SAAA;AAMC,SAEcE,YAAYA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAS3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAAF,cAAA;EAAAA,aAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CATA,SAAAC,QAA4BC,MAAW,EAAEC,OAA+B;IAAA,IAAAC,MAAA;IAAA,OAAAL,mBAAA,GAAAM,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OAC/CN,OAAO;QAAA;UAAtBC,MAAM,GAAAG,QAAA,CAAAG,IAAA;UACZ,IAAIN,MAAM,IAAI,IAAI,IAAIA,MAAM,KAAK,4CAA4C,EAAE;YAC3E,IAAArB,UAAA,CAAA4B,MAAM,EAAC,OAAOT,MAAO,KAAK,QAAQ,EAAE,mBAAmB,EAAE,mBAAmB,EAAE;cAAEf,KAAK,EAAEe;YAAM,CAAE,CAAC;YAChG,IAAAnB,UAAA,CAAA6B,cAAc,EAAC,KAAK,EAAE,+DAA+D,EAAE,QAAQ,EAAEV,MAAM,CAAC;;UAC3G,OAAAK,QAAA,CAAAM,MAAA,WACM,IAAA5B,YAAA,CAAAG,UAAU,EAACgB,MAAM,CAAC;QAAA;QAAA;UAAA,OAAAG,QAAA,CAAAO,IAAA;MAAA;IAAA,GAAAb,OAAA;EAAA,CAC5B;EAAA,OAAAN,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAuCD,SAAgBkB,cAAcA,CAACb,MAAmB,EAAEc,QAA8B;EAE9E,IAAI,OAAOd,MAAO,KAAK,QAAQ,EAAE;IAC7B,IAAIA,MAAM,CAACe,KAAK,CAAC,mBAAmB,CAAC,EAAE;MAAE,OAAO,IAAAhC,YAAA,CAAAG,UAAU,EAACc,MAAM,CAAC;;IAElE,IAAAnB,UAAA,CAAA4B,MAAM,EAACK,QAAQ,IAAI,IAAI,EAAE,oCAAoC,EACzD,uBAAuB,EAAE;MAAEE,SAAS,EAAE;IAAa,CAAE,CAAC;IAE1D,OAAO1B,YAAY,CAACU,MAAM,EAAEc,QAAQ,CAACG,WAAW,CAACjB,MAAM,CAAC,CAAC;GAE5D,MAAM,IAAIhB,aAAa,CAACgB,MAAM,CAAC,EAAE;IAC9B,OAAOV,YAAY,CAACU,MAAM,EAAEA,MAAM,CAACd,UAAU,EAAE,CAAC;GAEnD,MAAM,IAAIc,MAAM,IAAI,OAAOA,MAAM,CAACkB,IAAK,KAAK,UAAU,EAAE;IACrD,OAAO5B,YAAY,CAACU,MAAM,EAAEA,MAAM,CAAC;;EAGvC,IAAAnB,UAAA,CAAA6B,cAAc,EAAC,KAAK,EAAE,+BAA+B,EAAE,QAAQ,EAAEV,MAAM,CAAC;AAC5E;AAlBAb,OAAA,CAAA0B,cAAA,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}