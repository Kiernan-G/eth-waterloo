{"ast":null,"code":"\"use strict\";\n\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;\nvar index_js_1 = require(\"../utils/index.js\");\nvar index_js_2 = require(\"../hash/index.js\");\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n  var result = new Set();\n  items.forEach(function (k) {\n    return result.add(k);\n  });\n  return Object.freeze(result);\n}\n// Visibility Keywords\nvar _kwVisib = \"constant external internal payable private public pure view\";\nvar KwVisib = setify(_kwVisib.split(\" \"));\nvar _kwTypes = \"constructor error event fallback function receive struct\";\nvar KwTypes = setify(_kwTypes.split(\" \"));\nvar _kwModifiers = \"calldata memory storage payable indexed\";\nvar KwModifiers = setify(_kwModifiers.split(\" \"));\nvar _kwOther = \"tuple returns\";\n// All Keywords\nvar _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nvar Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nvar SimpleTokens = {\n  \"(\": \"OPEN_PAREN\",\n  \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\",\n  \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\",\n  \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nvar regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nvar regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nvar regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nvar regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nvar regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _tokens = /*#__PURE__*/new WeakMap();\nvar _subTokenString = /*#__PURE__*/new WeakSet();\nvar TokenString = /*#__PURE__*/function () {\n  function TokenString(tokens) {\n    _classCallCheck(this, TokenString);\n    _classPrivateMethodInitSpec(this, _subTokenString);\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tokens, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _offset, 0);\n    _classPrivateFieldSet(this, _tokens, tokens.slice());\n  }\n  _createClass(TokenString, [{\n    key: \"offset\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _offset);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _tokens).length - _classPrivateFieldGet(this, _offset);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new TokenString(_classPrivateFieldGet(this, _tokens));\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _classPrivateFieldSet(this, _offset, 0);\n    }\n  }, {\n    key: \"popKeyword\",\n    value:\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    function popKeyword(allowed) {\n      var top = this.peek();\n      if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n        throw new Error(\"expected keyword \".concat(top.text));\n      }\n      return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n  }, {\n    key: \"popType\",\n    value: function popType(type) {\n      if (this.peek().type !== type) {\n        throw new Error(\"expected \".concat(type, \"; got \").concat(JSON.stringify(this.peek())));\n      }\n      return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n  }, {\n    key: \"popParen\",\n    value: function popParen() {\n      var top = this.peek();\n      if (top.type !== \"OPEN_PAREN\") {\n        throw new Error(\"bad start\");\n      }\n      var result = _classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset) + 1, top.match + 1);\n      _classPrivateFieldSet(this, _offset, top.match + 1);\n      return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n  }, {\n    key: \"popParams\",\n    value: function popParams() {\n      var top = this.peek();\n      if (top.type !== \"OPEN_PAREN\") {\n        throw new Error(\"bad start\");\n      }\n      var result = [];\n      while (_classPrivateFieldGet(this, _offset) < top.match - 1) {\n        var link = this.peek().linkNext;\n        result.push(_classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset) + 1, link));\n        _classPrivateFieldSet(this, _offset, link);\n      }\n      _classPrivateFieldSet(this, _offset, top.match + 1);\n      return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      if (_classPrivateFieldGet(this, _offset) >= _classPrivateFieldGet(this, _tokens).length) {\n        throw new Error(\"out-of-bounds\");\n      }\n      return _classPrivateFieldGet(this, _tokens)[_classPrivateFieldGet(this, _offset)];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n  }, {\n    key: \"peekKeyword\",\n    value: function peekKeyword(allowed) {\n      var top = this.peekType(\"KEYWORD\");\n      return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n  }, {\n    key: \"peekType\",\n    value: function peekType(type) {\n      if (this.length === 0) {\n        return null;\n      }\n      var top = this.peek();\n      return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var _this$offset, _this$offset2;\n      var result = this.peek();\n      _classPrivateFieldSet(this, _offset, (_this$offset = _classPrivateFieldGet(this, _offset), _this$offset2 = _this$offset++, _this$offset)), _this$offset2;\n      return result;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var tokens = [];\n      for (var i = _classPrivateFieldGet(this, _offset); i < _classPrivateFieldGet(this, _tokens).length; i++) {\n        var token = _classPrivateFieldGet(this, _tokens)[i];\n        tokens.push(\"\".concat(token.type, \":\").concat(token.text));\n      }\n      return \"<TokenString \".concat(tokens.join(\" \"), \">\");\n    }\n  }]);\n  return TokenString;\n}();\nfunction _subTokenString2() {\n  var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return new TokenString(_classPrivateFieldGet(this, _tokens).slice(from, to).map(function (t) {\n    return Object.freeze(Object.assign({}, t, {\n      match: t.match - from,\n      linkBack: t.linkBack - from,\n      linkNext: t.linkNext - from\n    }));\n  }));\n}\nfunction lex(text) {\n  var tokens = [];\n  var throwError = function throwError(message) {\n    var token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n    throw new Error(\"invalid token \".concat(token, \" at \").concat(offset, \": \").concat(message));\n  };\n  var brackets = [];\n  var commas = [];\n  var offset = 0;\n  while (offset < text.length) {\n    // Strip off any leading whitespace\n    var cur = text.substring(offset);\n    var match = cur.match(regexWhitespacePrefix);\n    if (match) {\n      offset += match[1].length;\n      cur = text.substring(offset);\n    }\n    var token = {\n      depth: brackets.length,\n      linkBack: -1,\n      linkNext: -1,\n      match: -1,\n      type: \"\",\n      text: \"\",\n      offset: offset,\n      value: -1\n    };\n    tokens.push(token);\n    var type = SimpleTokens[cur[0]] || \"\";\n    if (type) {\n      token.type = type;\n      token.text = cur[0];\n      offset++;\n      if (type === \"OPEN_PAREN\") {\n        brackets.push(tokens.length - 1);\n        commas.push(tokens.length - 1);\n      } else if (type == \"CLOSE_PAREN\") {\n        if (brackets.length === 0) {\n          throwError(\"no matching open bracket\");\n        }\n        token.match = brackets.pop();\n        tokens[token.match].match = tokens.length - 1;\n        token.depth--;\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n      } else if (type === \"COMMA\") {\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n        commas.push(tokens.length - 1);\n      } else if (type === \"OPEN_BRACKET\") {\n        token.type = \"BRACKET\";\n      } else if (type === \"CLOSE_BRACKET\") {\n        // Remove the CLOSE_BRACKET\n        var suffix = tokens.pop().text;\n        if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n          var value = tokens.pop().text;\n          suffix = value + suffix;\n          tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);\n        }\n        if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n          throw new Error(\"missing opening bracket\");\n        }\n        tokens[tokens.length - 1].text += suffix;\n      }\n      continue;\n    }\n    match = cur.match(regexIdPrefix);\n    if (match) {\n      token.text = match[1];\n      offset += token.text.length;\n      if (Keywords.has(token.text)) {\n        token.type = \"KEYWORD\";\n        continue;\n      }\n      if (token.text.match(regexType)) {\n        token.type = \"TYPE\";\n        continue;\n      }\n      token.type = \"ID\";\n      continue;\n    }\n    match = cur.match(regexNumberPrefix);\n    if (match) {\n      token.text = match[1];\n      token.type = \"NUMBER\";\n      offset += token.text.length;\n      continue;\n    }\n    throw new Error(\"unexpected token \".concat(JSON.stringify(cur[0]), \" at position \").concat(offset));\n  }\n  return new TokenString(tokens.map(function (t) {\n    return Object.freeze(t);\n  }));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n  var included = [];\n  for (var key in allowed.keys()) {\n    if (set.has(key)) {\n      included.push(key);\n    }\n  }\n  if (included.length > 1) {\n    throw new Error(\"conflicting types: \".concat(included.join(\", \")));\n  }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n  if (tokens.peekKeyword(KwTypes)) {\n    var keyword = tokens.pop().text;\n    if (keyword !== type) {\n      throw new Error(\"expected \".concat(type, \", got \").concat(keyword));\n    }\n  }\n  return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n  var keywords = new Set();\n  while (true) {\n    var keyword = tokens.peekType(\"KEYWORD\");\n    if (keyword == null || allowed && !allowed.has(keyword)) {\n      break;\n    }\n    tokens.pop();\n    if (keywords.has(keyword)) {\n      throw new Error(\"duplicate keywords: \".concat(JSON.stringify(keyword)));\n    }\n    keywords.add(keyword);\n  }\n  return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n  var modifiers = consumeKeywords(tokens, KwVisib);\n  // Detect conflicting modifiers\n  allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n  allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n  // Process mutability states\n  if (modifiers.has(\"view\")) {\n    return \"view\";\n  }\n  if (modifiers.has(\"pure\")) {\n    return \"pure\";\n  }\n  if (modifiers.has(\"payable\")) {\n    return \"payable\";\n  }\n  if (modifiers.has(\"nonpayable\")) {\n    return \"nonpayable\";\n  }\n  // Process legacy `constant` last\n  if (modifiers.has(\"constant\")) {\n    return \"view\";\n  }\n  return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n  return tokens.popParams().map(function (t) {\n    return ParamType.from(t, allowIndexed);\n  });\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n  if (tokens.peekType(\"AT\")) {\n    tokens.pop();\n    if (tokens.peekType(\"NUMBER\")) {\n      return (0, index_js_1.getBigInt)(tokens.pop().text);\n    }\n    throw new Error(\"invalid gas\");\n  }\n  return null;\n}\nfunction consumeEoi(tokens) {\n  if (tokens.length) {\n    throw new Error(\"unexpected tokens: \".concat(tokens.toString()));\n  }\n}\nvar regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n  var match = type.match(regexType);\n  (0, index_js_1.assertArgument)(match, \"invalid type\", \"type\", type);\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n  if (type === \"int\") {\n    return \"int256\";\n  }\n  if (match[2]) {\n    // bytesXX\n    var length = parseInt(match[2]);\n    (0, index_js_1.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n  } else if (match[3]) {\n    // intXX or uintXX\n    var size = parseInt(match[3]);\n    (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n  }\n  return type;\n}\n// Make the Fragment constructors effectively private\nvar _guard = {};\nvar internal = Symbol.for(\"_ethers_internal\");\nvar ParamTypeInternal = \"_ParamTypeInternal\";\nvar ErrorFragmentInternal = \"_ErrorInternal\";\nvar EventFragmentInternal = \"_EventInternal\";\nvar ConstructorFragmentInternal = \"_ConstructorInternal\";\nvar FallbackFragmentInternal = \"_FallbackInternal\";\nvar FunctionFragmentInternal = \"_FunctionInternal\";\nvar StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nvar _walkAsync = /*#__PURE__*/new WeakSet();\nvar ParamType = /*#__PURE__*/function () {\n  /**\n   *  @private\n   */\n  function ParamType(guard, name, type, baseType, indexed, _components, arrayLength, arrayChildren) {\n    _classCallCheck(this, ParamType);\n    _classPrivateMethodInitSpec(this, _walkAsync);\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    _defineProperty(this, \"type\", void 0);\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    _defineProperty(this, \"baseType\", void 0);\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    _defineProperty(this, \"indexed\", void 0);\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    _defineProperty(this, \"components\", void 0);\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    _defineProperty(this, \"arrayLength\", void 0);\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    _defineProperty(this, \"arrayChildren\", void 0);\n    (0, index_js_1.assertPrivate)(guard, _guard, \"ParamType\");\n    Object.defineProperty(this, internal, {\n      value: ParamTypeInternal\n    });\n    if (_components) {\n      _components = Object.freeze(_components.slice());\n    }\n    if (baseType === \"array\") {\n      if (arrayLength == null || arrayChildren == null) {\n        throw new Error(\"\");\n      }\n    } else if (arrayLength != null || arrayChildren != null) {\n      throw new Error(\"\");\n    }\n    if (baseType === \"tuple\") {\n      if (_components == null) {\n        throw new Error(\"\");\n      }\n    } else if (_components != null) {\n      throw new Error(\"\");\n    }\n    (0, index_js_1.defineProperties)(this, {\n      name: name,\n      type: type,\n      baseType: baseType,\n      indexed: indexed,\n      components: _components,\n      arrayLength: arrayLength,\n      arrayChildren: arrayChildren\n    });\n  }\n  /**\n   *  Return a string representation of this type.\n   *\n   *  For example,\n   *\n   *  ``sighash\" => \"(uint256,address)\"``\n   *\n   *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n   *\n   *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n   */\n  _createClass(ParamType, [{\n    key: \"format\",\n    value: function format(_format) {\n      if (_format == null) {\n        _format = \"sighash\";\n      }\n      if (_format === \"json\") {\n        var _result = {\n          type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n          name: this.name || undefined\n        };\n        if (typeof this.indexed === \"boolean\") {\n          _result.indexed = this.indexed;\n        }\n        if (this.isTuple()) {\n          _result.components = this.components.map(function (c) {\n            return JSON.parse(c.format(_format));\n          });\n        }\n        return JSON.stringify(_result);\n      }\n      var result = \"\";\n      // Array\n      if (this.isArray()) {\n        result += this.arrayChildren.format(_format);\n        result += \"[\".concat(this.arrayLength < 0 ? \"\" : String(this.arrayLength), \"]\");\n      } else {\n        if (this.isTuple()) {\n          if (_format !== \"sighash\") {\n            result += this.type;\n          }\n          result += \"(\" + this.components.map(function (comp) {\n            return comp.format(_format);\n          }).join(_format === \"full\" ? \", \" : \",\") + \")\";\n        } else {\n          result += this.type;\n        }\n      }\n      if (_format !== \"sighash\") {\n        if (this.indexed === true) {\n          result += \" indexed\";\n        }\n        if (_format === \"full\" && this.name) {\n          result += \" \" + this.name;\n        }\n      }\n      return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n  }, {\n    key: \"isArray\",\n    value: function isArray() {\n      return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n  }, {\n    key: \"isTuple\",\n    value: function isTuple() {\n      return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n  }, {\n    key: \"isIndexable\",\n    value: function isIndexable() {\n      return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n  }, {\n    key: \"walk\",\n    value: function walk(value, process) {\n      if (this.isArray()) {\n        if (!Array.isArray(value)) {\n          throw new Error(\"invalid array value\");\n        }\n        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n          throw new Error(\"array is wrong length\");\n        }\n        var _this = this;\n        return value.map(function (v) {\n          return _this.arrayChildren.walk(v, process);\n        });\n      }\n      if (this.isTuple()) {\n        if (!Array.isArray(value)) {\n          throw new Error(\"invalid tuple value\");\n        }\n        if (value.length !== this.components.length) {\n          throw new Error(\"array is wrong length\");\n        }\n        var _this2 = this;\n        return value.map(function (v, i) {\n          return _this2.components[i].walk(v, process);\n        });\n      }\n      return process(this.type, value);\n    }\n  }, {\n    key: \"walkAsync\",\n    value:\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    function () {\n      var _walkAsync3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value, process) {\n        var promises, result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              promises = [];\n              result = [value];\n              _classPrivateMethodGet(this, _walkAsync, _walkAsync2).call(this, promises, value, process, function (value) {\n                result[0] = value;\n              });\n              if (!promises.length) {\n                _context.next = 6;\n                break;\n              }\n              _context.next = 6;\n              return Promise.all(promises);\n            case 6:\n              return _context.abrupt(\"return\", result[0]);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function walkAsync(_x, _x2) {\n        return _walkAsync3.apply(this, arguments);\n      }\n      return walkAsync;\n    }()\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(obj, allowIndexed) {\n      if (ParamType.isParamType(obj)) {\n        return obj;\n      }\n      if (typeof obj === \"string\") {\n        return ParamType.from(lex(obj), allowIndexed);\n      } else if (obj instanceof TokenString) {\n        var _type = \"\",\n          baseType = \"\";\n        var comps = null;\n        if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n          // Tuple\n          baseType = \"tuple\";\n          comps = obj.popParams().map(function (t) {\n            return ParamType.from(t);\n          });\n          _type = \"tuple(\".concat(comps.map(function (c) {\n            return c.format();\n          }).join(\",\"), \")\");\n        } else {\n          // Normal\n          _type = verifyBasicType(obj.popType(\"TYPE\"));\n          baseType = _type;\n        }\n        // Check for Array\n        var arrayChildren = null;\n        var arrayLength = null;\n        while (obj.length && obj.peekType(\"BRACKET\")) {\n          var bracket = obj.pop(); //arrays[i];\n          arrayChildren = new ParamType(_guard, \"\", _type, baseType, null, comps, arrayLength, arrayChildren);\n          arrayLength = bracket.value;\n          _type += bracket.text;\n          baseType = \"array\";\n          comps = null;\n        }\n        var _indexed = null;\n        var keywords = consumeKeywords(obj, KwModifiers);\n        if (keywords.has(\"indexed\")) {\n          if (!allowIndexed) {\n            throw new Error(\"\");\n          }\n          _indexed = true;\n        }\n        var _name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n        if (obj.length) {\n          throw new Error(\"leftover tokens\");\n        }\n        return new ParamType(_guard, _name, _type, baseType, _indexed, comps, arrayLength, arrayChildren);\n      }\n      var name = obj.name;\n      (0, index_js_1.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n      var indexed = obj.indexed;\n      if (indexed != null) {\n        (0, index_js_1.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n        indexed = !!indexed;\n      }\n      var type = obj.type;\n      var arrayMatch = type.match(regexArrayType);\n      if (arrayMatch) {\n        var _arrayLength = parseInt(arrayMatch[2] || \"-1\");\n        var _arrayChildren = ParamType.from({\n          type: arrayMatch[1],\n          components: obj.components\n        });\n        return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, _arrayLength, _arrayChildren);\n      }\n      if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n        var _comps = obj.components != null ? obj.components.map(function (c) {\n          return ParamType.from(c);\n        }) : null;\n        var tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, _comps, null, null);\n        // @TODO: use lexer to validate and normalize type\n        return tuple;\n      }\n      type = verifyBasicType(obj.type);\n      return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n  }, {\n    key: \"isParamType\",\n    value: function isParamType(value) {\n      return value && value[internal] === ParamTypeInternal;\n    }\n  }]);\n  return ParamType;\n}();\nfunction _walkAsync2(promises, value, process, setValue) {\n  if (this.isArray()) {\n    if (!Array.isArray(value)) {\n      throw new Error(\"invalid array value\");\n    }\n    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n      throw new Error(\"array is wrong length\");\n    }\n    var childType = this.arrayChildren;\n    var _result2 = value.slice();\n    _result2.forEach(function (value, index) {\n      _classPrivateMethodGet(childType, _walkAsync, _walkAsync2).call(childType, promises, value, process, function (value) {\n        _result2[index] = value;\n      });\n    });\n    setValue(_result2);\n    return;\n  }\n  if (this.isTuple()) {\n    var components = this.components;\n    // Convert the object into an array\n    var _result3;\n    if (Array.isArray(value)) {\n      _result3 = value.slice();\n    } else {\n      if (value == null || typeof value !== \"object\") {\n        throw new Error(\"invalid tuple value\");\n      }\n      _result3 = components.map(function (param) {\n        if (!param.name) {\n          throw new Error(\"cannot use object value with unnamed components\");\n        }\n        if (!(param.name in value)) {\n          throw new Error(\"missing value for component \".concat(param.name));\n        }\n        return value[param.name];\n      });\n    }\n    if (_result3.length !== this.components.length) {\n      throw new Error(\"array is wrong length\");\n    }\n    _result3.forEach(function (value, index) {\n      var _components$index;\n      _classPrivateMethodGet(_components$index = components[index], _walkAsync, _walkAsync2).call(_components$index, promises, value, process, function (value) {\n        _result3[index] = value;\n      });\n    });\n    setValue(_result3);\n    return;\n  }\n  var result = process(this.type, value);\n  if (result.then) {\n    promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = setValue;\n            _context2.next = 3;\n            return result;\n          case 3:\n            _context2.t1 = _context2.sent;\n            (0, _context2.t0)(_context2.t1);\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))());\n  } else {\n    setValue(result);\n  }\n}\nexports.ParamType = ParamType;\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nvar Fragment = /*#__PURE__*/function () {\n  /**\n   *  @private\n   */\n  function Fragment(guard, type, inputs) {\n    _classCallCheck(this, Fragment);\n    /**\n     *  The type of the fragment.\n     */\n    _defineProperty(this, \"type\", void 0);\n    /**\n     *  The inputs for the fragment.\n     */\n    _defineProperty(this, \"inputs\", void 0);\n    (0, index_js_1.assertPrivate)(guard, _guard, \"Fragment\");\n    inputs = Object.freeze(inputs.slice());\n    (0, index_js_1.defineProperties)(this, {\n      type: type,\n      inputs: inputs\n    });\n  }\n  /**\n   *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n   *  ABI frgament type.\n   */\n  _createClass(Fragment, null, [{\n    key: \"from\",\n    value: function from(obj) {\n      if (typeof obj === \"string\") {\n        // Try parsing JSON...\n        try {\n          Fragment.from(JSON.parse(obj));\n        } catch (e) {}\n        // ...otherwise, use the human-readable lexer\n        return Fragment.from(lex(obj));\n      }\n      if (obj instanceof TokenString) {\n        // Human-readable ABI (already lexed)\n        var type = obj.peekKeyword(KwTypes);\n        switch (type) {\n          case \"constructor\":\n            return ConstructorFragment.from(obj);\n          case \"error\":\n            return ErrorFragment.from(obj);\n          case \"event\":\n            return EventFragment.from(obj);\n          case \"fallback\":\n          case \"receive\":\n            return FallbackFragment.from(obj);\n          case \"function\":\n            return FunctionFragment.from(obj);\n          case \"struct\":\n            return StructFragment.from(obj);\n        }\n      } else if (typeof obj === \"object\") {\n        // JSON ABI\n        switch (obj.type) {\n          case \"constructor\":\n            return ConstructorFragment.from(obj);\n          case \"error\":\n            return ErrorFragment.from(obj);\n          case \"event\":\n            return EventFragment.from(obj);\n          case \"fallback\":\n          case \"receive\":\n            return FallbackFragment.from(obj);\n          case \"function\":\n            return FunctionFragment.from(obj);\n          case \"struct\":\n            return StructFragment.from(obj);\n        }\n        (0, index_js_1.assert)(false, \"unsupported type: \".concat(obj.type), \"UNSUPPORTED_OPERATION\", {\n          operation: \"Fragment.from\"\n        });\n      }\n      (0, index_js_1.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n  }, {\n    key: \"isConstructor\",\n    value: function isConstructor(value) {\n      return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n  }, {\n    key: \"isError\",\n    value: function isError(value) {\n      return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n  }, {\n    key: \"isEvent\",\n    value: function isEvent(value) {\n      return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n  }, {\n    key: \"isFunction\",\n    value: function isFunction(value) {\n      return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n  }, {\n    key: \"isStruct\",\n    value: function isStruct(value) {\n      return StructFragment.isFragment(value);\n    }\n  }]);\n  return Fragment;\n}();\nexports.Fragment = Fragment;\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nvar NamedFragment = /*#__PURE__*/function (_Fragment) {\n  _inherits(NamedFragment, _Fragment);\n  var _super = _createSuper(NamedFragment);\n  /**\n   *  @private\n   */\n  function NamedFragment(guard, type, name, inputs) {\n    var _this3;\n    _classCallCheck(this, NamedFragment);\n    _this3 = _super.call(this, guard, type, inputs);\n    /**\n     *  The name of the fragment.\n     */\n    _defineProperty(_assertThisInitialized(_this3), \"name\", void 0);\n    (0, index_js_1.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n    inputs = Object.freeze(inputs.slice());\n    (0, index_js_1.defineProperties)(_assertThisInitialized(_this3), {\n      name: name\n    });\n    return _this3;\n  }\n  return _createClass(NamedFragment);\n}(Fragment);\nexports.NamedFragment = NamedFragment;\nfunction joinParams(format, params) {\n  return \"(\" + params.map(function (p) {\n    return p.format(format);\n  }).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nvar ErrorFragment = /*#__PURE__*/function (_NamedFragment) {\n  _inherits(ErrorFragment, _NamedFragment);\n  var _super2 = _createSuper(ErrorFragment);\n  /**\n   *  @private\n   */\n  function ErrorFragment(guard, name, inputs) {\n    var _this4;\n    _classCallCheck(this, ErrorFragment);\n    _this4 = _super2.call(this, guard, \"error\", name, inputs);\n    Object.defineProperty(_assertThisInitialized(_this4), internal, {\n      value: ErrorFragmentInternal\n    });\n    return _this4;\n  }\n  /**\n   *  The Custom Error selector.\n   */\n  _createClass(ErrorFragment, [{\n    key: \"selector\",\n    get: function get() {\n      return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n  }, {\n    key: \"format\",\n    value: function format(_format2) {\n      if (_format2 == null) {\n        _format2 = \"sighash\";\n      }\n      if (_format2 === \"json\") {\n        return JSON.stringify({\n          type: \"error\",\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format2));\n          })\n        });\n      }\n      var result = [];\n      if (_format2 !== \"sighash\") {\n        result.push(\"error\");\n      }\n      result.push(this.name + joinParams(_format2, this.inputs));\n      return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(obj) {\n      if (ErrorFragment.isFragment(obj)) {\n        return obj;\n      }\n      if (typeof obj === \"string\") {\n        return ErrorFragment.from(lex(obj));\n      } else if (obj instanceof TokenString) {\n        var name = consumeName(\"error\", obj);\n        var inputs = consumeParams(obj);\n        consumeEoi(obj);\n        return new ErrorFragment(_guard, name, inputs);\n      }\n      return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return value && value[internal] === ErrorFragmentInternal;\n    }\n  }]);\n  return ErrorFragment;\n}(NamedFragment);\nexports.ErrorFragment = ErrorFragment;\n/**\n *  A Fragment which represents an Event.\n */\nvar EventFragment = /*#__PURE__*/function (_NamedFragment2) {\n  _inherits(EventFragment, _NamedFragment2);\n  var _super3 = _createSuper(EventFragment);\n  /**\n   *  @private\n   */\n  function EventFragment(guard, name, inputs, anonymous) {\n    var _this5;\n    _classCallCheck(this, EventFragment);\n    _this5 = _super3.call(this, guard, \"event\", name, inputs);\n    /**\n     *  Whether this event is anonymous.\n     */\n    _defineProperty(_assertThisInitialized(_this5), \"anonymous\", void 0);\n    Object.defineProperty(_assertThisInitialized(_this5), internal, {\n      value: EventFragmentInternal\n    });\n    (0, index_js_1.defineProperties)(_assertThisInitialized(_this5), {\n      anonymous: anonymous\n    });\n    return _this5;\n  }\n  /**\n   *  The Event topic hash.\n   */\n  _createClass(EventFragment, [{\n    key: \"topicHash\",\n    get: function get() {\n      return (0, index_js_2.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n  }, {\n    key: \"format\",\n    value: function format(_format3) {\n      if (_format3 == null) {\n        _format3 = \"sighash\";\n      }\n      if (_format3 === \"json\") {\n        return JSON.stringify({\n          type: \"event\",\n          anonymous: this.anonymous,\n          name: this.name,\n          inputs: this.inputs.map(function (i) {\n            return JSON.parse(i.format(_format3));\n          })\n        });\n      }\n      var result = [];\n      if (_format3 !== \"sighash\") {\n        result.push(\"event\");\n      }\n      result.push(this.name + joinParams(_format3, this.inputs));\n      if (_format3 !== \"sighash\" && this.anonymous) {\n        result.push(\"anonymous\");\n      }\n      return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n  }], [{\n    key: \"getTopicHash\",\n    value: function getTopicHash(name, params) {\n      params = (params || []).map(function (p) {\n        return ParamType.from(p);\n      });\n      var fragment = new EventFragment(_guard, name, params, false);\n      return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n  }, {\n    key: \"from\",\n    value: function from(obj) {\n      if (EventFragment.isFragment(obj)) {\n        return obj;\n      }\n      if (typeof obj === \"string\") {\n        return EventFragment.from(lex(obj));\n      } else if (obj instanceof TokenString) {\n        var name = consumeName(\"event\", obj);\n        var inputs = consumeParams(obj, true);\n        var anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n        consumeEoi(obj);\n        return new EventFragment(_guard, name, inputs, anonymous);\n      }\n      return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(function (p) {\n        return ParamType.from(p, true);\n      }) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return value && value[internal] === EventFragmentInternal;\n    }\n  }]);\n  return EventFragment;\n}(NamedFragment);\nexports.EventFragment = EventFragment;\n/**\n *  A Fragment which represents a constructor.\n */\nvar ConstructorFragment = /*#__PURE__*/function (_Fragment2) {\n  _inherits(ConstructorFragment, _Fragment2);\n  var _super4 = _createSuper(ConstructorFragment);\n  /**\n   *  @private\n   */\n  function ConstructorFragment(guard, type, inputs, payable, gas) {\n    var _this6;\n    _classCallCheck(this, ConstructorFragment);\n    _this6 = _super4.call(this, guard, type, inputs);\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    _defineProperty(_assertThisInitialized(_this6), \"payable\", void 0);\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    _defineProperty(_assertThisInitialized(_this6), \"gas\", void 0);\n    Object.defineProperty(_assertThisInitialized(_this6), internal, {\n      value: ConstructorFragmentInternal\n    });\n    (0, index_js_1.defineProperties)(_assertThisInitialized(_this6), {\n      payable: payable,\n      gas: gas\n    });\n    return _this6;\n  }\n  /**\n   *  Returns a string representation of this constructor as %%format%%.\n   */\n  _createClass(ConstructorFragment, [{\n    key: \"format\",\n    value: function format(_format4) {\n      (0, index_js_1.assert)(_format4 != null && _format4 !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"format(sighash)\"\n      });\n      if (_format4 === \"json\") {\n        return JSON.stringify({\n          type: \"constructor\",\n          stateMutability: this.payable ? \"payable\" : \"undefined\",\n          payable: this.payable,\n          gas: this.gas != null ? this.gas : undefined,\n          inputs: this.inputs.map(function (i) {\n            return JSON.parse(i.format(_format4));\n          })\n        });\n      }\n      var result = [\"constructor\".concat(joinParams(_format4, this.inputs))];\n      result.push(this.payable ? \"payable\" : \"nonpayable\");\n      if (this.gas != null) {\n        result.push(\"@\".concat(this.gas.toString()));\n      }\n      return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(obj) {\n      if (ConstructorFragment.isFragment(obj)) {\n        return obj;\n      }\n      if (typeof obj === \"string\") {\n        return ConstructorFragment.from(lex(obj));\n      } else if (obj instanceof TokenString) {\n        consumeKeywords(obj, setify([\"constructor\"]));\n        var inputs = consumeParams(obj);\n        var payable = !!consumeKeywords(obj, setify([\"payable\"])).has(\"payable\");\n        var gas = consumeGas(obj);\n        consumeEoi(obj);\n        return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n      }\n      return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return value && value[internal] === ConstructorFragmentInternal;\n    }\n  }]);\n  return ConstructorFragment;\n}(Fragment);\nexports.ConstructorFragment = ConstructorFragment;\n/**\n *  A Fragment which represents a method.\n */\nvar FallbackFragment = /*#__PURE__*/function (_Fragment3) {\n  _inherits(FallbackFragment, _Fragment3);\n  var _super5 = _createSuper(FallbackFragment);\n  function FallbackFragment(guard, inputs, payable) {\n    var _this7;\n    _classCallCheck(this, FallbackFragment);\n    _this7 = _super5.call(this, guard, \"fallback\", inputs);\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    _defineProperty(_assertThisInitialized(_this7), \"payable\", void 0);\n    Object.defineProperty(_assertThisInitialized(_this7), internal, {\n      value: FallbackFragmentInternal\n    });\n    (0, index_js_1.defineProperties)(_assertThisInitialized(_this7), {\n      payable: payable\n    });\n    return _this7;\n  }\n  /**\n   *  Returns a string representation of this fallback as %%format%%.\n   */\n  _createClass(FallbackFragment, [{\n    key: \"format\",\n    value: function format(_format5) {\n      var type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n      if (_format5 === \"json\") {\n        var stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n        return JSON.stringify({\n          type: type,\n          stateMutability: stateMutability\n        });\n      }\n      return \"\".concat(type, \"()\").concat(this.payable ? \" payable\" : \"\");\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(obj) {\n      if (FallbackFragment.isFragment(obj)) {\n        return obj;\n      }\n      if (typeof obj === \"string\") {\n        return FallbackFragment.from(lex(obj));\n      } else if (obj instanceof TokenString) {\n        var errorObj = obj.toString();\n        var topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n        (0, index_js_1.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n        var type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n        // receive()\n        if (type === \"receive\") {\n          var _inputs = consumeParams(obj);\n          (0, index_js_1.assertArgument)(_inputs.length === 0, \"receive cannot have arguments\", \"obj.inputs\", _inputs);\n          consumeKeywords(obj, setify([\"payable\"]));\n          consumeEoi(obj);\n          return new FallbackFragment(_guard, [], true);\n        }\n        // fallback() [payable]\n        // fallback(bytes) [payable] returns (bytes)\n        var inputs = consumeParams(obj);\n        if (inputs.length) {\n          (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map(function (i) {\n            return i.format(\"minimal\");\n          }).join(\", \"));\n        } else {\n          inputs = [ParamType.from(\"bytes\")];\n        }\n        var mutability = consumeMutability(obj);\n        (0, index_js_1.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n        if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n          var outputs = consumeParams(obj);\n          (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map(function (i) {\n            return i.format(\"minimal\");\n          }).join(\", \"));\n        }\n        consumeEoi(obj);\n        return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n      }\n      if (obj.type === \"receive\") {\n        return new FallbackFragment(_guard, [], true);\n      }\n      if (obj.type === \"fallback\") {\n        var _inputs2 = [ParamType.from(\"bytes\")];\n        var payable = obj.stateMutability === \"payable\";\n        return new FallbackFragment(_guard, _inputs2, payable);\n      }\n      (0, index_js_1.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return value && value[internal] === FallbackFragmentInternal;\n    }\n  }]);\n  return FallbackFragment;\n}(Fragment);\nexports.FallbackFragment = FallbackFragment;\n/**\n *  A Fragment which represents a method.\n */\nvar FunctionFragment = /*#__PURE__*/function (_NamedFragment3) {\n  _inherits(FunctionFragment, _NamedFragment3);\n  var _super6 = _createSuper(FunctionFragment);\n  /**\n   *  @private\n   */\n  function FunctionFragment(guard, name, stateMutability, inputs, outputs, gas) {\n    var _this8;\n    _classCallCheck(this, FunctionFragment);\n    _this8 = _super6.call(this, guard, \"function\", name, inputs);\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    _defineProperty(_assertThisInitialized(_this8), \"constant\", void 0);\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    _defineProperty(_assertThisInitialized(_this8), \"outputs\", void 0);\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    _defineProperty(_assertThisInitialized(_this8), \"stateMutability\", void 0);\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    _defineProperty(_assertThisInitialized(_this8), \"payable\", void 0);\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    _defineProperty(_assertThisInitialized(_this8), \"gas\", void 0);\n    Object.defineProperty(_assertThisInitialized(_this8), internal, {\n      value: FunctionFragmentInternal\n    });\n    outputs = Object.freeze(outputs.slice());\n    var constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    var payable = stateMutability === \"payable\";\n    (0, index_js_1.defineProperties)(_assertThisInitialized(_this8), {\n      constant: constant,\n      gas: gas,\n      outputs: outputs,\n      payable: payable,\n      stateMutability: stateMutability\n    });\n    return _this8;\n  }\n  /**\n   *  The Function selector.\n   */\n  _createClass(FunctionFragment, [{\n    key: \"selector\",\n    get: function get() {\n      return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n  }, {\n    key: \"format\",\n    value: function format(_format6) {\n      if (_format6 == null) {\n        _format6 = \"sighash\";\n      }\n      if (_format6 === \"json\") {\n        return JSON.stringify({\n          type: \"function\",\n          name: this.name,\n          constant: this.constant,\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payable: this.payable,\n          gas: this.gas != null ? this.gas : undefined,\n          inputs: this.inputs.map(function (i) {\n            return JSON.parse(i.format(_format6));\n          }),\n          outputs: this.outputs.map(function (o) {\n            return JSON.parse(o.format(_format6));\n          })\n        });\n      }\n      var result = [];\n      if (_format6 !== \"sighash\") {\n        result.push(\"function\");\n      }\n      result.push(this.name + joinParams(_format6, this.inputs));\n      if (_format6 !== \"sighash\") {\n        if (this.stateMutability !== \"nonpayable\") {\n          result.push(this.stateMutability);\n        }\n        if (this.outputs && this.outputs.length) {\n          result.push(\"returns\");\n          result.push(joinParams(_format6, this.outputs));\n        }\n        if (this.gas != null) {\n          result.push(\"@\".concat(this.gas.toString()));\n        }\n      }\n      return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n  }], [{\n    key: \"getSelector\",\n    value: function getSelector(name, params) {\n      params = (params || []).map(function (p) {\n        return ParamType.from(p);\n      });\n      var fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n      return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n  }, {\n    key: \"from\",\n    value: function from(obj) {\n      if (FunctionFragment.isFragment(obj)) {\n        return obj;\n      }\n      if (typeof obj === \"string\") {\n        return FunctionFragment.from(lex(obj));\n      } else if (obj instanceof TokenString) {\n        var name = consumeName(\"function\", obj);\n        var inputs = consumeParams(obj);\n        var mutability = consumeMutability(obj);\n        var outputs = [];\n        if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n          outputs = consumeParams(obj);\n        }\n        var gas = consumeGas(obj);\n        consumeEoi(obj);\n        return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n      }\n      var stateMutability = obj.stateMutability;\n      // Use legacy Solidity ABI logic if stateMutability is missing\n      if (stateMutability == null) {\n        stateMutability = \"payable\";\n        if (typeof obj.constant === \"boolean\") {\n          stateMutability = \"view\";\n          if (!obj.constant) {\n            stateMutability = \"payable\";\n            if (typeof obj.payable === \"boolean\" && !obj.payable) {\n              stateMutability = \"nonpayable\";\n            }\n          }\n        } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n          stateMutability = \"nonpayable\";\n        }\n      }\n      // @TODO: verifyState for stateMutability (e.g. throw if\n      //        payable: false but stateMutability is \"nonpayable\")\n      return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return value && value[internal] === FunctionFragmentInternal;\n    }\n  }]);\n  return FunctionFragment;\n}(NamedFragment);\nexports.FunctionFragment = FunctionFragment;\n/**\n *  A Fragment which represents a structure.\n */\nvar StructFragment = /*#__PURE__*/function (_NamedFragment4) {\n  _inherits(StructFragment, _NamedFragment4);\n  var _super7 = _createSuper(StructFragment);\n  /**\n   *  @private\n   */\n  function StructFragment(guard, name, inputs) {\n    var _this9;\n    _classCallCheck(this, StructFragment);\n    _this9 = _super7.call(this, guard, \"struct\", name, inputs);\n    Object.defineProperty(_assertThisInitialized(_this9), internal, {\n      value: StructFragmentInternal\n    });\n    return _this9;\n  }\n  /**\n   *  Returns a string representation of this struct as %%format%%.\n   */\n  _createClass(StructFragment, [{\n    key: \"format\",\n    value: function format() {\n      throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(obj) {\n      if (typeof obj === \"string\") {\n        return StructFragment.from(lex(obj));\n      } else if (obj instanceof TokenString) {\n        var name = consumeName(\"struct\", obj);\n        var inputs = consumeParams(obj);\n        consumeEoi(obj);\n        return new StructFragment(_guard, name, inputs);\n      }\n      return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return value && value[internal] === StructFragmentInternal;\n    }\n  }]);\n  return StructFragment;\n}(NamedFragment);\nexports.StructFragment = StructFragment;","map":{"version":3,"names":["_assertThisInitialized","require","default","_inherits","_createSuper","_regeneratorRuntime","_asyncToGenerator","_defineProperty","_classCallCheck","_createClass","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateMethodGet","_classPrivateFieldSet","_classPrivateFieldGet","index_js_1","index_js_2","setify","items","result","Set","forEach","k","add","Object","freeze","_kwVisib","KwVisib","split","_kwTypes","KwTypes","_kwModifiers","KwModifiers","_kwOther","_keywords","join","Keywords","SimpleTokens","regexWhitespacePrefix","RegExp","regexNumberPrefix","regexIdPrefix","regexId","regexType","_offset","WeakMap","_tokens","_subTokenString","WeakSet","TokenString","tokens","writable","value","slice","key","get","length","clone","reset","popKeyword","allowed","top","peek","type","has","text","Error","concat","pop","popType","JSON","stringify","popParen","_subTokenString2","call","match","popParams","link","linkNext","push","peekKeyword","peekType","_this$offset","_this$offset2","toString","i","token","from","arguments","undefined","to","map","t","assign","linkBack","lex","throwError","message","offset","brackets","commas","cur","substring","depth","suffix","getNumber","allowSingle","set","included","keys","consumeName","keyword","consumeKeywords","keywords","consumeMutability","modifiers","consumeParams","allowIndexed","ParamType","consumeGas","getBigInt","consumeEoi","regexArrayType","verifyBasicType","assertArgument","parseInt","size","_guard","internal","Symbol","for","ParamTypeInternal","ErrorFragmentInternal","EventFragmentInternal","ConstructorFragmentInternal","FallbackFragmentInternal","FunctionFragmentInternal","StructFragmentInternal","_walkAsync","guard","name","baseType","indexed","components","arrayLength","arrayChildren","assertPrivate","defineProperty","defineProperties","format","isTuple","c","parse","isArray","String","comp","isIndexable","walk","process","Array","_this","v","_walkAsync3","mark","_callee","promises","wrap","_callee$","_context","prev","next","_walkAsync2","Promise","all","abrupt","stop","walkAsync","_x","_x2","apply","obj","isParamType","comps","bracket","arrayMatch","startsWith","tuple","setValue","childType","index","param","_components$index","then","_callee2","_callee2$","_context2","t0","t1","sent","exports","Fragment","inputs","e","ConstructorFragment","ErrorFragment","EventFragment","FallbackFragment","FunctionFragment","StructFragment","assert","operation","isConstructor","isFragment","isError","isEvent","isFunction","isStruct","NamedFragment","_Fragment","_super","_this3","joinParams","params","p","_NamedFragment","_super2","_this4","id","input","_NamedFragment2","_super3","anonymous","_this5","getTopicHash","fragment","topicHash","_Fragment2","_super4","payable","gas","_this6","stateMutability","_Fragment3","_super5","_this7","errorObj","topIsValid","mutability","outputs","_NamedFragment3","_super6","_this8","constant","o","getSelector","selector","_NamedFragment4","_super7","_this9"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/abi/fragments.ts"],"sourcesContent":["/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\n\nimport {\n    defineProperties, getBigInt, getNumber,\n    assert, assertPrivate, assertArgument\n} from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n\n/**\n *  A Type description in a [JSON ABI format](link-solc-jsonabi).\n */\nexport interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The internal Solidity type.\n     */\n    readonly internalType?: string;\n\n    /**\n     *  The components for a tuple.\n     */\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\n/**\n *  A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).\n */\nexport interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n    readonly anonymous?: boolean;\n\n    /**\n     *  If the function is payable.\n     */\n    readonly payable?: boolean;\n\n    /**\n     *  If the function is constant.\n     */\n    readonly constant?: boolean;\n\n    /**\n     *  The mutability state of the function.\n     */\n    readonly stateMutability?: string;\n\n    /**\n     *  The input parameters.\n     */\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The output parameters.\n     */\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The gas limit to use when sending a transaction for this function.\n     */\n    readonly gas?: string;\n};\n\n/**\n *  The format to serialize the output as.\n *\n *  **``\"sighash\"``** - the bare formatting, used to compute the selector\n *  or topic hash; this format cannot be reversed (as it discards ``indexed``)\n *  so cannot by used to export an [[Interface]].\n *\n *  **``\"minimal\"``** - Human-Readable ABI with minimal spacing and without\n *  names, so it is compact, but will result in Result objects that cannot\n *  be accessed by name.\n *\n *  **``\"full\"``** - Full Human-Readable ABI, with readable spacing and names\n *  intact; this is generally the recommended format.\n *\n *  **``\"json\"``** - The [JSON ABI format](link-solc-jsonabi).\n */\nexport type FormatType = \"sighash\" | \"minimal\" | \"full\" | \"json\";\n\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items: Array<string>): ReadonlySet<string> {\n    const result: Set<string> = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\n\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\n\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\n\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\n\nconst _kwOther = \"tuple returns\";\n\n// All Keywords\nconst _keywords = [ _kwTypes, _kwModifiers, _kwOther, _kwVisib ].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n\n// Single character tokens\nconst SimpleTokens: Record<string, string> = {\n  \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\", \"@\": \"AT\"\n};\n\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\n\n/**\n *  @ignore:\n */\ntype Token = Readonly<{\n    // Type of token (e.g. TYPE, KEYWORD, NUMBER, etc)\n    type: string;\n\n    // Offset into the original source code\n    offset: number;\n\n    // Actual text content of the token\n    text: string;\n\n    // The parenthesis depth\n    depth: number;\n\n    // If a parenthesis, the offset (in tokens) that balances it\n    match: number;\n\n    // For parenthesis and commas, the offset (in tokens) to the\n    // previous/next parenthesis or comma in the list\n    linkBack: number;\n    linkNext: number;\n\n    // If a BRACKET, the value inside\n    value: number;\n}>;\n\nclass TokenString {\n    #offset: number;\n    #tokens: ReadonlyArray<Token>;\n\n    get offset(): number { return this.#offset; }\n    get length(): number { return this.#tokens.length - this.#offset; }\n\n    constructor(tokens: ReadonlyArray<Token>) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n\n    clone(): TokenString { return new TokenString(this.#tokens); }\n    reset(): void { this.#offset = 0; }\n\n    #subTokenString(from: number = 0, to: number = 0): TokenString {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({ }, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed: ReadonlySet<string>): string {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) { throw new Error(`expected keyword ${ top.text }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type: string): string {\n        if (this.peek().type !== type) { throw new Error(`expected ${ type }; got ${ JSON.stringify(this.peek()) }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen(): TokenString {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams(): Array<TokenString> {\n        const top = this.peek();\n\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n\n        const result: Array<TokenString> = [ ];\n\n        while(this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n\n        this.#offset = top.match + 1;\n\n        return result;\n    }\n\n    // Returns the top Token, throwing if out of tokens\n    peek(): Token {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed: ReadonlySet<string>): null | string {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top: null;\n    }\n\n    // Returns the value of the next token if it is `type`\n    peekType(type: string): null | string {\n        if (this.length === 0) { return null; }\n        const top = this.peek();\n        return (top.type === type) ? top.text: null;\n    }\n\n    // Returns the next token; throws if out of tokens\n    pop(): Token {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n\n    toString(): string {\n        const tokens: Array<string> = [ ];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${ token.type }:${ token.text }`);\n        }\n        return `<TokenString ${ tokens.join(\" \") }>`\n    }\n}\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction lex(text: string): TokenString {\n    const tokens: Array<Token> = [ ];\n\n    const throwError = (message: string) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]): \"$EOI\";\n        throw new Error(`invalid token ${ token } at ${ offset }: ${ message }`);\n    };\n\n    let brackets: Array<number> = [ ];\n    let commas: Array<number> = [ ];\n\n    let offset = 0;\n    while (offset < text.length) {\n\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) { throwError(\"no matching open bracket\"); }\n\n                token.match = brackets.pop() as number;\n                (<Writeable<Token>>(tokens[token.match])).match = tokens.length - 1;\n                token.depth--;\n\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = (tokens.pop() as Token).text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = (tokens.pop() as Token).text;\n                    suffix = value + suffix;\n                    (<Writeable<Token>>(tokens[tokens.length - 1])).value = getNumber(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (<Writeable<Token>>(tokens[tokens.length - 1])).text += suffix;\n            }\n\n            continue;\n        }\n\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n\n            token.type = \"ID\";\n            continue;\n        }\n\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n\n        throw new Error(`unexpected token ${ JSON.stringify(cur[0]) } at position ${ offset }`);\n    }\n\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set: ReadonlySet<string>, allowed: ReadonlySet<string>): void {\n    let included: Array<string> = [ ];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) { included.push(key); }\n    }\n    if (included.length > 1) { throw new Error(`conflicting types: ${ included.join(\", \") }`); }\n}\n\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n\n// ...the name with an optional type, returning the name\nfunction consumeName(type: string, tokens: TokenString): string {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${ type }, got ${ keyword }`);\n        }\n    }\n\n    return tokens.popType(\"ID\");\n}\n\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens: TokenString, allowed?: ReadonlySet<string>): ReadonlySet<string> {\n    const keywords: Set<string> = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n\n        if (keyword == null || (allowed && !allowed.has(keyword))) { break; }\n        tokens.pop();\n\n        if (keywords.has(keyword)) { throw new Error(`duplicate keywords: ${ JSON.stringify(keyword) }`); }\n        keywords.add(keyword);\n    }\n\n    return Object.freeze(keywords);\n}\n\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens: TokenString): \"payable\" | \"nonpayable\" | \"view\" | \"pure\" {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n\n    // Process mutability states\n    if (modifiers.has(\"view\")) { return \"view\"; }\n    if (modifiers.has(\"pure\")) { return \"pure\"; }\n    if (modifiers.has(\"payable\")) { return \"payable\"; }\n    if (modifiers.has(\"nonpayable\")) { return \"nonpayable\"; }\n\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) { return \"view\"; }\n\n    return \"nonpayable\";\n}\n\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens: TokenString, allowIndexed?: boolean): Array<ParamType> {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens: TokenString): null | bigint {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return getBigInt(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\n\nfunction consumeEoi(tokens: TokenString): void {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${ tokens.toString() }`);\n    }\n}\n\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nfunction verifyBasicType(type: string): string {\n    const match = type.match(regexType);\n    assertArgument(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") { return \"uint256\"; }\n    if (type === \"int\") { return \"int256\"; }\n\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3] as string);\n        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n\n    return type;\n}\n\n// Make the Fragment constructors effectively private\nconst _guard = { };\n\n\n/**\n *  When [walking](ParamType-walk) a [[ParamType]], this is called\n *  on each component.\n */\nexport type ParamTypeWalkFunc = (type: string, value: any) => any;\n\n/**\n *  When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\n *  this is called on each component.\n */\nexport type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;\n\nconst internal = Symbol.for(\"_ethers_internal\");\n\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nexport class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    readonly baseType!: string;\n\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    readonly indexed!: null | boolean;\n\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    readonly components!: null | ReadonlyArray<ParamType>;\n\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayLength!: null | number;\n\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayChildren!: null | ParamType;\n\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, type: string, baseType: string, indexed: null | boolean, components: null | ReadonlyArray<ParamType>, arrayLength: null | number, arrayChildren: null | ParamType) {\n        assertPrivate(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n\n        if (components) { components = Object.freeze(components.slice()); }\n\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n\n        if (baseType === \"tuple\") {\n            if (components == null) { throw new Error(\"\"); }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n\n        defineProperties<ParamType>(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${ (this.arrayLength < 0 ? \"\": String(this.arrayLength)) }]`;\n        } else {\n            if (this.isTuple()) {\n                if (format !== \"sighash\") { result += this.type; }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === \"full\") ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== \"sighash\") {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray(): this is (ParamType & { arrayChildren: ParamType, arrayLength: number }) {\n        return (this.baseType === \"array\")\n    }\n\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple(): this is (ParamType & { components: ReadonlyArray<ParamType> }) {\n        return (this.baseType === \"tuple\");\n    }\n\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable(): this is (ParamType & { indexed: boolean }) {\n        return (this.indexed != null);\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value: any, process: ParamTypeWalkFunc): any {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid tuple value\"); }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n\n        return process(this.type, value);\n    }\n\n    #walkAsync(promises: Array<Promise<void>>, value: any, process: ParamTypeWalkAsyncFunc, setValue: (value: any) => void): void {\n\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        if (this.isTuple()) {\n            const components = this.components;\n\n            // Convert the object into an array\n            let result: Array<any>;\n            if (Array.isArray(value)) {\n                result = value.slice();\n\n            } else {\n                if (value == null || typeof(value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n\n                result = components.map((param) => {\n                    if (!param.name) { throw new Error(\"cannot use object value with unnamed components\"); }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${ param.name }`);\n                    }\n                    return value[param.name];\n                });\n            }\n\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function() { setValue(await result); })());\n        } else {\n            setValue(result);\n        }\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value: any, process: ParamTypeWalkAsyncFunc): Promise<any> {\n        const promises: Array<Promise<void>> = [ ];\n        const result: [ any ] = [ value ];\n        this.#walkAsync(promises, value, process, (value: any) => {\n            result[0] = value;\n        });\n        if (promises.length) { await Promise.all(promises); }\n        return result[0];\n    }\n\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj: any, allowIndexed?: boolean): ParamType {\n        if (ParamType.isParamType(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ParamType.from(lex(obj), allowIndexed);\n\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps: null | Array<ParamType> = null;\n\n            if (consumeKeywords(obj, setify([ \"tuple\" ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${ comps.map((c) => c.format()).join(\",\") })`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n\n            // Check for Array\n            let arrayChildren: null | ParamType  = null;\n            let arrayLength: null | number = null;\n\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) { throw new Error(\"\"); }\n                indexed = true;\n            }\n\n            const name = (obj.peekType(\"ID\") ? obj.pop().text: \"\");\n\n            if (obj.length) { throw new Error(\"leftover tokens\"); }\n\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n\n        const name = obj.name;\n        assertArgument(!name || (typeof(name) === \"string\" && name.match(regexId)),\n            \"invalid name\", \"obj.name\", name);\n\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n\n        let type = obj.type;\n\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n\n        if (type === \"tuple\" || type.startsWith(\"tuple(\"/* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c: any) => ParamType.from(c)): null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n\n        type = verifyBasicType(obj.type);\n\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value: any): value is ParamType {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n\n/**\n *  The type of a [[Fragment]].\n */\nexport type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";\n\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>) {\n        assertPrivate(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<Fragment>(this, { type, inputs });\n    }\n\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    abstract format(format?: FormatType): string;\n\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj: any): Fragment {\n        if (typeof(obj) === \"string\") {\n\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) { }\n\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n\n            const type = obj.peekKeyword(KwTypes);\n\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n        } else if (typeof(obj) === \"object\") {\n            // JSON ABI\n\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n            assert(false, `unsupported type: ${ obj.type }`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value: any): value is ConstructorFragment {\n        return ConstructorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value: any): value is ErrorFragment {\n        return ErrorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value: any): value is EventFragment {\n        return EventFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value: any): value is FunctionFragment {\n        return FunctionFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value: any): value is StructFragment {\n        return StructFragment.isFragment(value);\n    }\n}\n\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);\n        assertArgument(typeof(name) === \"string\" && name.match(regexId),\n            \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<NamedFragment>(this, { name });\n    }\n}\n\nfunction joinParams(format: FormatType, params: ReadonlyArray<ParamType>): string { \n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \": \",\") + \")\";\n}\n\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /**\n     *  The Custom Error selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        const result = [ ];\n        if (format !== \"sighash\") { result.push(\"error\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj: any): ErrorFragment {\n        if (ErrorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n\n            return new ErrorFragment(_guard, name, inputs);\n        }\n\n        return new ErrorFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value: any): value is ErrorFragment {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        defineProperties<EventFragment>(this, { anonymous });\n    }\n\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash(): string {\n        return id(this.format(\"sighash\"));\n    }\n\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result = [ ];\n        if (format !== \"sighash\") { result.push(\"event\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) { result.push(\"anonymous\"); }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj: any): EventFragment {\n        if (EventFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return EventFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([ \"anonymous\" ])).has(\"anonymous\");\n            consumeEoi(obj);\n\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n\n        return new EventFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map((p: any) => ParamType.from(p, true)): [ ], !!obj.anonymous);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value: any): value is EventFragment {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>, payable: boolean, gas: null | bigint) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        defineProperties<ConstructorFragment>(this, { payable, gas });\n    }\n\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format?: FormatType): string {\n        assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\": \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result = [ `constructor${ joinParams(format, this.inputs) }` ];\n        result.push((this.payable) ? \"payable\": \"nonpayable\");\n        if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj: any): ConstructorFragment {\n        if (ConstructorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ConstructorFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([ \"constructor\" ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, setify([ \"payable\" ])).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n\n        return new ConstructorFragment(_guard, \"constructor\",\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n            !!obj.payable, (obj.gas != null) ? obj.gas: null);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value: any): value is ConstructorFragment {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        defineProperties<FallbackFragment>(this, { payable });\n    }\n\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format?: FormatType): string {\n        const type = ((this.inputs.length === 0) ? \"receive\": \"fallback\");\n\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\": \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n\n        return `${ type }()${ this.payable ? \" payable\": \"\" }`;\n    }\n\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj: any): FallbackFragment {\n        if (FallbackFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n             return FallbackFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n\n            const topIsValid = obj.peekKeyword(setify([ \"fallback\", \"receive\" ]));\n            assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n\n            const type = obj.popKeyword(setify([ \"fallback\", \"receive\" ]));\n\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([ \"payable\" ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [ ], true);\n            }\n\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\",\n                    \"invalid fallback inputs\", \"obj.inputs\",\n                    inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [ ParamType.from(\"bytes\") ];\n            }\n\n            const mutability = consumeMutability(obj);\n            assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\",\n                    \"invalid fallback outputs\", \"obj.outputs\",\n                    outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n\n            consumeEoi(obj);\n\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [ ], true);\n        }\n\n        if (obj.type === \"fallback\") {\n            const inputs = [ ParamType.from(\"bytes\") ];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value: any): value is FallbackFragment {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    readonly stateMutability!: \"payable\" | \"nonpayable\" | \"view\" | \"pure\";\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, stateMutability: \"payable\" | \"nonpayable\" | \"view\" | \"pure\", inputs: ReadonlyArray<ParamType>, outputs: ReadonlyArray<ParamType>, gas: null | bigint) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        defineProperties<FunctionFragment>(this, { constant, gas, outputs, payable, stateMutability });\n    }\n\n    /**\n     *  The Function selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n\n        const result = [];\n\n        if (format !== \"sighash\") { result.push(\"function\"); }\n\n        result.push(this.name + joinParams(format, this.inputs));\n\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n\n            if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        }\n        return result.join(\" \");\n    }\n\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [ ], null);\n        return fragment.selector;\n    }\n\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj: any): FunctionFragment {\n        if (FunctionFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n             return FunctionFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n\n            let outputs: Array<ParamType> = [ ];\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n\n            const gas = consumeGas(obj);\n\n            consumeEoi(obj);\n\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n\n        let stateMutability = obj.stateMutability;\n\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n\n            if (typeof(obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\"\n                    if (typeof(obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof(obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n\n        return new FunctionFragment(_guard, obj.name, stateMutability,\n             obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n             obj.outputs ? obj.outputs.map(ParamType.from): [ ],\n             (obj.gas != null) ? obj.gas: null);\n    }\n\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format(): string {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj: any): StructFragment {\n        if (typeof(obj) === \"string\") {\n            return StructFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n// @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}