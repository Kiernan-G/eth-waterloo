{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scryptSync = exports.scrypt = void 0;\nvar scrypt_1 = require(\"@noble/hashes/scrypt\");\nvar index_js_1 = require(\"../utils/index.js\");\nvar lockedSync = false,\n  lockedAsync = false;\nvar _scryptAsync = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(passwd, salt, N, r, p, dkLen, onProgress) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return (0, scrypt_1.scryptAsync)(passwd, salt, {\n            N: N,\n            r: r,\n            p: p,\n            dkLen: dkLen,\n            onProgress: onProgress\n          });\n        case 2:\n          return _context.abrupt(\"return\", _context.sent);\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function _scryptAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar _scryptSync = function _scryptSync(passwd, salt, N, r, p, dkLen) {\n  return (0, scrypt_1.scrypt)(passwd, salt, {\n    N: N,\n    r: r,\n    p: p,\n    dkLen: dkLen\n  });\n};\nvar __scryptAsync = _scryptAsync;\nvar __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nfunction scrypt(_x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n  return _scrypt.apply(this, arguments);\n}\nfunction _scrypt() {\n  _scrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_passwd, _salt, N, r, p, dkLen, progress) {\n    var passwd, salt;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          passwd = (0, index_js_1.getBytes)(_passwd, \"passwd\");\n          salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n          _context2.t0 = (0, index_js_1.hexlify);\n          _context2.next = 5;\n          return __scryptAsync(passwd, salt, N, r, p, dkLen, progress);\n        case 5:\n          _context2.t1 = _context2.sent;\n          return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t1));\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _scrypt.apply(this, arguments);\n}\nexports.scrypt = scrypt;\nscrypt._ = _scryptAsync;\nscrypt.lock = function () {\n  lockedAsync = true;\n};\nscrypt.register = function (func) {\n  if (lockedAsync) {\n    throw new Error(\"scrypt is locked\");\n  }\n  __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nfunction scryptSync(_passwd, _salt, N, r, p, dkLen) {\n  var passwd = (0, index_js_1.getBytes)(_passwd, \"passwd\");\n  var salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n  return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nexports.scryptSync = scryptSync;\nscryptSync._ = _scryptSync;\nscryptSync.lock = function () {\n  lockedSync = true;\n};\nscryptSync.register = function (func) {\n  if (lockedSync) {\n    throw new Error(\"scryptSync is locked\");\n  }\n  __scryptSync = func;\n};\nObject.freeze(scryptSync);","map":{"version":3,"names":["scrypt_1","require","index_js_1","lockedSync","lockedAsync","_scryptAsync","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","passwd","salt","N","r","p","dkLen","onProgress","wrap","_callee$","_context","prev","next","scryptAsync","abrupt","sent","stop","_x","_x2","_x3","_x4","_x5","_x6","_x7","apply","arguments","_scryptSync","scrypt","__scryptAsync","__scryptSync","_x8","_x9","_x10","_x11","_x12","_x13","_x14","_scrypt","_callee2","_passwd","_salt","progress","_callee2$","_context2","getBytes","t0","hexlify","t1","exports","_","lock","register","func","Error","Object","freeze","scryptSync"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/crypto/scrypt.ts"],"sourcesContent":["import { scrypt as _nobleSync, scryptAsync as _nobleAsync } from \"@noble/hashes/scrypt\";\n\nimport { getBytes, hexlify as H } from \"../utils/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\n/**\n *  A callback during long-running operations to update any\n *  UI or provide programatic access to the progress.\n *\n *  The %%percent%% is a value between ``0`` and ``1``.\n *\n *  @_docloc: api/crypto:Passwords\n */\nexport type ProgressCallback = (percent: number) => void;\n\n\nlet lockedSync = false, lockedAsync = false;\n\nconst _scryptAsync = async function(passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number, onProgress?: ProgressCallback) {\n    return await _nobleAsync(passwd, salt, { N, r, p, dkLen, onProgress });\n}\nconst _scryptSync = function(passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number) {\n    return _nobleSync(passwd, salt, { N, r, p, dkLen });\n}\n\nlet __scryptAsync: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number, onProgress?: ProgressCallback) => Promise<BytesLike> = _scryptAsync;\nlet __scryptSync: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number) => BytesLike = _scryptSync\n\n\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport async function scrypt(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback): Promise<string> {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n}\nscrypt._ = _scryptAsync;\nscrypt.lock = function(): void { lockedAsync = true; }\nscrypt.register = function(func: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback) => Promise<BytesLike>) {\n    if (lockedAsync) { throw new Error(\"scrypt is locked\"); }\n    __scryptAsync = func;\n}\nObject.freeze(scrypt);\n\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport function scryptSync(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number): string {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nscryptSync._ = _scryptSync;\nscryptSync.lock = function(): void { lockedSync = true; }\nscryptSync.register = function(func: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number) => BytesLike) {\n    if (lockedSync) { throw new Error(\"scryptSync is locked\"); }\n    __scryptSync = func;\n}\nObject.freeze(scryptSync);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}