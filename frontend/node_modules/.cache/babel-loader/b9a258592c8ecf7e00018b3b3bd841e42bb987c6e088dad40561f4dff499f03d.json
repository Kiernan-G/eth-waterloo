{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateMethodInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _defineProperty = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _possibleConstructorReturn = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\").default;\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;\nvar index_js_1 = require(\"../../utils/index.js\");\n/**\n * @_ignore:\n */\nexports.WordSize = 32;\nvar Padding = new Uint8Array(exports.WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nvar passProperties = [\"then\"];\nvar _guard = {};\nfunction throwError(name, error) {\n  var wrapped = new Error(\"deferred error during ABI decoding triggered accessing \".concat(name));\n  wrapped.error = error;\n  throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nvar _names = /*#__PURE__*/new WeakMap();\nvar Result = /*#__PURE__*/function (_Array) {\n  _inherits(Result, _Array);\n  var _super = _createSuper(Result);\n  /**\n   *  @private\n   */\n  function Result() {\n    var _this;\n    _classCallCheck(this, Result);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    var guard = args[0];\n    var items = args[1];\n    var names = (args[2] || []).slice();\n    var wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    _this = _super.call(this, items.length);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _names, {\n      writable: true,\n      value: void 0\n    });\n    items.forEach(function (item, index) {\n      _this[index] = item;\n    });\n    // Find all unique keys\n    var nameCounts = names.reduce(function (accum, name) {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    _classPrivateFieldSet(_assertThisInitialized(_this), _names, Object.freeze(items.map(function (item, index) {\n      var name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    })));\n    if (!wrap) {\n      return _possibleConstructorReturn(_this);\n    }\n    // A wrapped Result is immutable\n    Object.freeze(_assertThisInitialized(_this));\n    // Proxy indices and names so we can trap deferred errors\n    return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), {\n      get: function get(target, prop, receiver) {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            var index = (0, index_js_1.getNumber)(prop, \"%index\");\n            if (index < 0 || index >= _this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            var item = target[index];\n            if (item instanceof Error) {\n              throwError(\"index \".concat(index), item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          var value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function () {\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(_assertThisInitialized(_this) === receiver ? target : _assertThisInitialized(_this), [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    }));\n  }\n  /**\n   *  Returns the Result as a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  _createClass(Result, [{\n    key: \"toArray\",\n    value: function toArray() {\n      var result = [];\n      this.forEach(function (item, index) {\n        if (item instanceof Error) {\n          throwError(\"index \".concat(index), item);\n        }\n        result.push(item);\n      });\n      return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      var _this2 = this;\n      return _classPrivateFieldGet(this, _names).reduce(function (accum, name, index) {\n        (0, index_js_1.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"toObject()\"\n        });\n        // Add values for names that don't conflict\n        if (!(name in accum)) {\n          accum[name] = _this2.getValue(name);\n        }\n        return accum;\n      }, {});\n    }\n    /**\n     *  @_ignore\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(start, end) {\n      if (start == null) {\n        start = 0;\n      }\n      if (start < 0) {\n        start += this.length;\n        if (start < 0) {\n          start = 0;\n        }\n      }\n      if (end == null) {\n        end = this.length;\n      }\n      if (end < 0) {\n        end += this.length;\n        if (end < 0) {\n          end = 0;\n        }\n      }\n      if (end > this.length) {\n        end = this.length;\n      }\n      var result = [],\n        names = [];\n      for (var i = start; i < end; i++) {\n        result.push(this[i]);\n        names.push(_classPrivateFieldGet(this, _names)[i]);\n      }\n      return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(callback, thisArg) {\n      var result = [],\n        names = [];\n      for (var i = 0; i < this.length; i++) {\n        var item = this[i];\n        if (item instanceof Error) {\n          throwError(\"index \".concat(i), item);\n        }\n        if (callback.call(thisArg, item, i, this)) {\n          result.push(item);\n          names.push(_classPrivateFieldGet(this, _names)[i]);\n        }\n      }\n      return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n  }, {\n    key: \"map\",\n    value: function map(callback, thisArg) {\n      var result = [];\n      for (var i = 0; i < this.length; i++) {\n        var item = this[i];\n        if (item instanceof Error) {\n          throwError(\"index \".concat(i), item);\n        }\n        result.push(callback.call(thisArg, item, i, this));\n      }\n      return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue(name) {\n      var index = _classPrivateFieldGet(this, _names).indexOf(name);\n      if (index === -1) {\n        return undefined;\n      }\n      var value = this[index];\n      if (value instanceof Error) {\n        throwError(\"property \".concat(JSON.stringify(name)), value.error);\n      }\n      return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems(items, keys) {\n      return new Result(_guard, items, keys);\n    }\n  }]);\n  return Result;\n}( /*#__PURE__*/_wrapNativeSuper(Array));\nexports.Result = Result;\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexports.checkResultErrors = checkResultErrors;\nfunction getValue(value) {\n  var bytes = (0, index_js_1.toBeArray)(value);\n  (0, index_js_1.assert)(bytes.length <= exports.WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: exports.WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== exports.WordSize) {\n    bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nvar Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    _defineProperty(this, \"name\", void 0);\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    _defineProperty(this, \"type\", void 0);\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    _defineProperty(this, \"localName\", void 0);\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    _defineProperty(this, \"dynamic\", void 0);\n    (0, index_js_1.defineProperties)(this, {\n      name: name,\n      type: type,\n      localName: localName,\n      dynamic: dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      (0, index_js_1.assertArgument)(false, message, this.localName, value);\n    }\n  }]);\n  return Coder;\n}();\nexports.Coder = Coder;\n/**\n *  @_ignore\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _writeData = /*#__PURE__*/new WeakSet();\nvar Writer = /*#__PURE__*/function () {\n  function Writer() {\n    _classCallCheck(this, Writer);\n    _classPrivateMethodInitSpec(this, _writeData);\n    // An array of WordSize lengthed objects to concatenation\n    _classPrivateFieldInitSpec(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _dataLength, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _data, []);\n    _classPrivateFieldSet(this, _dataLength, 0);\n  }\n  _createClass(Writer, [{\n    key: \"data\",\n    get: function get() {\n      return (0, index_js_1.concat)(_classPrivateFieldGet(this, _data));\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _dataLength);\n    }\n  }, {\n    key: \"appendWriter\",\n    value: function appendWriter(writer) {\n      return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, (0, index_js_1.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = (0, index_js_1.getBytesCopy)(value);\n      var paddingOffset = bytes.length % exports.WordSize;\n      if (paddingOffset) {\n        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));\n      }\n      return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this3 = this;\n      var offset = _classPrivateFieldGet(this, _data).length;\n      _classPrivateFieldGet(this, _data).push(Padding);\n      _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _dataLength) + exports.WordSize);\n      return function (value) {\n        _classPrivateFieldGet(_this3, _data)[offset] = getValue(value);\n      };\n    }\n  }]);\n  return Writer;\n}();\nfunction _writeData2(data) {\n  _classPrivateFieldGet(this, _data).push(data);\n  _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _dataLength) + data.length);\n  return data.length;\n}\nexports.Writer = Writer;\n/**\n *  @_ignore\n */\nvar _data2 = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _peekBytes = /*#__PURE__*/new WeakSet();\nvar Reader = /*#__PURE__*/function () {\n  function Reader(data, allowLoose) {\n    _classCallCheck(this, Reader);\n    _classPrivateMethodInitSpec(this, _peekBytes);\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    _defineProperty(this, \"allowLoose\", void 0);\n    _classPrivateFieldInitSpec(this, _data2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_1.defineProperties)(this, {\n      allowLoose: !!allowLoose\n    });\n    _classPrivateFieldSet(this, _data2, (0, index_js_1.getBytesCopy)(data));\n    _classPrivateFieldSet(this, _offset, 0);\n  }\n  _createClass(Reader, [{\n    key: \"data\",\n    get: function get() {\n      return (0, index_js_1.hexlify)(_classPrivateFieldGet(this, _data2));\n    }\n  }, {\n    key: \"dataLength\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _data2).length;\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _offset);\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return new Uint8Array(_classPrivateFieldGet(this, _data2));\n    }\n  }, {\n    key: \"subReader\",\n    value:\n    // Create a sub-reader with the same underlying data, but offset\n    function subReader(offset) {\n      return new Reader(_classPrivateFieldGet(this, _data2).slice(_classPrivateFieldGet(this, _offset) + offset), this.allowLoose);\n    }\n    // Read bytes\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length, loose) {\n      var bytes = _classPrivateMethodGet(this, _peekBytes, _peekBytes2).call(this, 0, length, !!loose);\n      _classPrivateFieldSet(this, _offset, _classPrivateFieldGet(this, _offset) + bytes.length);\n      // @TODO: Make sure the length..end bytes are all 0?\n      return bytes.slice(0, length);\n    }\n    // Read a numeric values\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));\n    }\n  }, {\n    key: \"readIndex\",\n    value: function readIndex() {\n      return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));\n    }\n  }]);\n  return Reader;\n}();\nfunction _peekBytes2(offset, length, loose) {\n  var alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;\n  if (_classPrivateFieldGet(this, _offset) + alignedLength > _classPrivateFieldGet(this, _data2).length) {\n    if (this.allowLoose && loose && _classPrivateFieldGet(this, _offset) + length <= _classPrivateFieldGet(this, _data2).length) {\n      alignedLength = length;\n    } else {\n      (0, index_js_1.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: (0, index_js_1.getBytesCopy)(_classPrivateFieldGet(this, _data2)),\n        length: _classPrivateFieldGet(this, _data2).length,\n        offset: _classPrivateFieldGet(this, _offset) + alignedLength\n      });\n    }\n  }\n  return _classPrivateFieldGet(this, _data2).slice(_classPrivateFieldGet(this, _offset), _classPrivateFieldGet(this, _offset) + alignedLength);\n}\nexports.Reader = Reader;","map":{"version":3,"names":["index_js_1","require","exports","WordSize","Padding","Uint8Array","passProperties","_guard","throwError","name","error","wrapped","Error","concat","_names","WeakMap","Result","_Array","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","guard","items","names","slice","wrap","call","_classPrivateFieldInitSpec","_assertThisInitialized","writable","value","forEach","item","index","nameCounts","reduce","accum","set","get","Map","_classPrivateFieldSet","Object","freeze","map","_possibleConstructorReturn","Proxy","target","prop","receiver","match","getNumber","RangeError","indexOf","Reflect","Function","_len2","_key2","apply","getValue","_createClass","key","toArray","result","push","toObject","_this2","_classPrivateFieldGet","assert","operation","start","end","i","filter","callback","thisArg","undefined","JSON","stringify","fromItems","keys","_wrapNativeSuper","checkResultErrors","errors","checkErrors","path","object","isArray","childPath","bytes","toBeArray","buffer","offset","getBytesCopy","Coder","type","localName","dynamic","_defineProperty","defineProperties","_throwError","message","assertArgument","_data","_dataLength","_writeData","WeakSet","Writer","_classPrivateMethodInitSpec","appendWriter","writer","_classPrivateMethodGet","_writeData2","data","writeBytes","paddingOffset","writeValue","writeUpdatableValue","_this3","_data2","_offset","_peekBytes","Reader","allowLoose","hexlify","subReader","readBytes","loose","_peekBytes2","readValue","toBigInt","readIndex","toNumber","alignedLength","Math","ceil"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/abi/coders/abstract-coder.ts"],"sourcesContent":["\nimport {\n    defineProperties, concat, getBytesCopy, getNumber, hexlify,\n    toBeArray, toBigInt, toNumber,\n    assert, assertArgument\n} from \"../../utils/index.js\";\n\nimport type { BigNumberish, BytesLike } from \"../../utils/index.js\";\n\n/**\n * @_ignore:\n */\nexport const WordSize: number = 32;\nconst Padding = new Uint8Array(WordSize);\n\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [ \"then\" ];\n\nconst _guard = { };\n\nfunction throwError(name: string, error: Error): never {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${ name }`);\n    (<any>wrapped).error = error;\n    throw wrapped;\n}\n\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array<any> {\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @private\n     */\n    constructor(...args: Array<any>) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items: Array<any> = args[1];\n        let names: Array<null | string> = (args[2] || [ ]).slice();\n\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [ ];\n            wrap = false;\n        }\n\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof(name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, <Map<string, number>>(new Map()));\n\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n\n        if (!wrap) { return; }\n\n        // A wrapped Result is immutable\n        Object.freeze(this);\n\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"string\") {\n\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${ index }`, item);\n                        }\n                        return item;\n                    }\n\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(this: any, ...args: Array<any>) {\n                            return value.apply((this === receiver) ? target: this, args);\n                        };\n\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target: this, [ prop ]);\n                    }\n                }\n\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(): Array<any> {\n        const result: Array<any> = [ ];\n        this.forEach((item, index) => {\n            if (item instanceof Error) { throwError(`index ${ index }`, item); }\n            result.push(item);\n        });\n        return result;\n    }\n\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(): Record<string, any> {\n        return this.#names.reduce((accum, name, index) => {\n            assert(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n\n            return accum;\n        }, <Record<string, any>>{});\n    }\n\n    /**\n     *  @_ignore\n     */\n    slice(start?: number | undefined, end?: number | undefined): Result {\n        if (start == null) { start = 0; }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) { start = 0; }\n        }\n\n        if (end == null) { end = this.length; }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) { end = 0; }\n        }\n        if (end > this.length) { end = this.length; }\n\n        const result = [ ], names = [ ];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    filter(callback: (el: any, index: number, array: Result) => boolean, thisArg?: any): Result {\n        const result = [ ], names = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    map<T extends any = any>(callback: (el: any, index: number, array: Result) => T, thisArg?: any): Array<T> {\n        const result: Array<T> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            result.push(callback.call(thisArg, item, i, this));\n        }\n\n        return result;\n    }\n\n\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name: string): any {\n        const index = this.#names.indexOf(name);\n        if (index === -1) { return undefined; }\n\n        const value = this[index];\n\n        if (value instanceof Error) {\n            throwError(`property ${ JSON.stringify(name) }`, (<any>value).error);\n        }\n\n        return value;\n    }\n\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items: Array<any>, keys?: Array<null | string>): Result {\n        return new Result(_guard, items, keys);\n    }\n}\n\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error: any) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nfunction getValue(value: BigNumberish): Uint8Array {\n    let bytes = toBeArray(value);\n\n    assert (bytes.length <= WordSize, \"value out-of-bounds\",\n        \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([ Padding.slice(bytes.length % WordSize), bytes ]));\n    }\n\n    return bytes;\n}\n\n/**\n *  @_ignore\n */\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name!: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type!: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName!: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic!: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        defineProperties<Coder>(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n\n    _throwError(message: string, value: any): never {\n        assertArgument(false, message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data: Array<Uint8Array>;\n    #dataLength: number;\n\n    constructor() {\n        this.#data = [ ];\n        this.#dataLength = 0;\n    }\n\n    get data(): string {\n        return concat(this.#data);\n    }\n    get length(): number { return this.#dataLength; }\n\n    #writeData(data: Uint8Array): number {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([ bytes, Padding.slice(paddingOffset) ]))\n        }\n        return this.#writeData(bytes);\n    }\n\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value: BigNumberish): number {\n        return this.#writeData(getValue(value));\n    }\n\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value: BigNumberish) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    readonly allowLoose!: boolean;\n\n    readonly #data: Uint8Array;\n    #offset: number;\n\n    constructor(data: BytesLike, allowLoose?: boolean) {\n        defineProperties<Reader>(this, { allowLoose: !!allowLoose });\n\n        this.#data = getBytesCopy(data);\n\n        this.#offset = 0;\n    }\n\n    get data(): string { return hexlify(this.#data); }\n    get dataLength(): number { return this.#data.length; }\n    get consumed(): number { return this.#offset; }\n    get bytes(): Uint8Array { return new Uint8Array(this.#data); }\n\n    #peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength)\n    }\n\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset: number): Reader {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n\n    // Read bytes\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    // Read a numeric values\n    readValue(): bigint {\n        return toBigInt(this.readBytes(WordSize));\n    }\n\n    readIndex(): number {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}