{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _Symbol$for;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Signature = void 0;\nvar index_js_1 = require(\"../constants/index.js\");\nvar index_js_2 = require(\"../utils/index.js\");\n// Constants\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\nvar BN_2 = BigInt(2);\nvar BN_27 = BigInt(27);\nvar BN_28 = BigInt(28);\nvar BN_35 = BigInt(35);\nvar _guard = {};\nfunction toUint256(value) {\n  return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nvar _r2 = /*#__PURE__*/new WeakMap();\nvar _s = /*#__PURE__*/new WeakMap();\nvar _v2 = /*#__PURE__*/new WeakMap();\nvar _networkV = /*#__PURE__*/new WeakMap();\n_Symbol$for = Symbol.for('nodejs.util.inspect.custom');\nvar Signature = /*#__PURE__*/function () {\n  /**\n   *  @private\n   */\n  function Signature(guard, r, s, v) {\n    _classCallCheck(this, Signature);\n    _classPrivateFieldInitSpec(this, _r2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _s, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _v2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _networkV, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_2.assertPrivate)(guard, _guard, \"Signature\");\n    _classPrivateFieldSet(this, _r2, r);\n    _classPrivateFieldSet(this, _s, s);\n    _classPrivateFieldSet(this, _v2, v);\n    _classPrivateFieldSet(this, _networkV, null);\n  }\n  _createClass(Signature, [{\n    key: \"r\",\n    get:\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    function get() {\n      return _classPrivateFieldGet(this, _r2);\n    },\n    set: function set(value) {\n      (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n      _classPrivateFieldSet(this, _r2, (0, index_js_2.hexlify)(value));\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n  }, {\n    key: \"s\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _s);\n    },\n    set: function set(_value) {\n      (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n      var value = (0, index_js_2.hexlify)(_value);\n      (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n      _classPrivateFieldSet(this, _s, value);\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n  }, {\n    key: \"v\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _v2);\n    },\n    set: function set(value) {\n      var v = (0, index_js_2.getNumber)(value, \"value\");\n      (0, index_js_2.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n      _classPrivateFieldSet(this, _v2, v);\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n  }, {\n    key: \"networkV\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _networkV);\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n  }, {\n    key: \"legacyChainId\",\n    get: function get() {\n      var v = this.networkV;\n      if (v == null) {\n        return null;\n      }\n      return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n  }, {\n    key: \"yParity\",\n    get: function get() {\n      return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n  }, {\n    key: \"yParityAndS\",\n    get: function get() {\n      // The EIP-2098 compact representation\n      var yParityAndS = (0, index_js_2.getBytes)(this.s);\n      if (this.yParity) {\n        yParityAndS[0] |= 0x80;\n      }\n      return (0, index_js_2.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n  }, {\n    key: \"compactSerialized\",\n    get: function get() {\n      return (0, index_js_2.concat)([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n  }, {\n    key: \"serialized\",\n    get: function get() {\n      return (0, index_js_2.concat)([this.r, this.s, this.yParity ? \"0x1c\" : \"0x1b\"]);\n    }\n  }, {\n    key: _Symbol$for,\n    value: function value() {\n      return \"Signature { r: \\\"\".concat(this.r, \"\\\", s: \\\"\").concat(this.s, \"\\\", yParity: \").concat(this.yParity, \", networkV: \").concat(this.networkV, \" }\");\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new Signature(_guard, this.r, this.s, this.v);\n      if (this.networkV) {\n        _classPrivateFieldSet(clone, _networkV, this.networkV);\n      }\n      return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var networkV = this.networkV;\n      return {\n        _type: \"signature\",\n        networkV: networkV != null ? networkV.toString() : null,\n        r: this.r,\n        s: this.s,\n        v: this.v\n      };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n  }], [{\n    key: \"getChainId\",\n    value: function getChainId(v) {\n      var bv = (0, index_js_2.getBigInt)(v, \"v\");\n      // The v is not an EIP-155 v, so it is the unspecified chain ID\n      if (bv == BN_27 || bv == BN_28) {\n        return BN_0;\n      }\n      // Bad value for an EIP-155 v\n      (0, index_js_2.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n      return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n  }, {\n    key: \"getChainIdV\",\n    value: function getChainIdV(chainId, v) {\n      return (0, index_js_2.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n  }, {\n    key: \"getNormalizedV\",\n    value: function getNormalizedV(v) {\n      var bv = (0, index_js_2.getBigInt)(v);\n      if (bv === BN_0 || bv === BN_27) {\n        return 27;\n      }\n      if (bv === BN_1 || bv === BN_28) {\n        return 28;\n      }\n      (0, index_js_2.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n      // Otherwise, EIP-155 v means odd is 27 and even is 28\n      return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n  }, {\n    key: \"from\",\n    value: function from(sig) {\n      function assertError(check, message) {\n        (0, index_js_2.assertArgument)(check, message, \"signature\", sig);\n      }\n      ;\n      if (sig == null) {\n        return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);\n      }\n      if (typeof sig === \"string\") {\n        var bytes = (0, index_js_2.getBytes)(sig, \"signature\");\n        if (bytes.length === 64) {\n          var _r3 = (0, index_js_2.hexlify)(bytes.slice(0, 32));\n          var _s2 = bytes.slice(32, 64);\n          var _v3 = _s2[0] & 0x80 ? 28 : 27;\n          _s2[0] &= 0x7f;\n          return new Signature(_guard, _r3, (0, index_js_2.hexlify)(_s2), _v3);\n        }\n        if (bytes.length === 65) {\n          var _r4 = (0, index_js_2.hexlify)(bytes.slice(0, 32));\n          var _s3 = bytes.slice(32, 64);\n          assertError((_s3[0] & 0x80) === 0, \"non-canonical s\");\n          var _v4 = Signature.getNormalizedV(bytes[64]);\n          return new Signature(_guard, _r4, (0, index_js_2.hexlify)(_s3), _v4);\n        }\n        assertError(false, \"invalid raw signature length\");\n      }\n      if (sig instanceof Signature) {\n        return sig.clone();\n      }\n      // Get r\n      var _r = sig.r;\n      assertError(_r != null, \"missing r\");\n      var r = toUint256(_r);\n      // Get s; by any means necessary (we check consistency below)\n      var s = function (s, yParityAndS) {\n        if (s != null) {\n          return toUint256(s);\n        }\n        if (yParityAndS != null) {\n          assertError((0, index_js_2.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n          var _bytes = (0, index_js_2.getBytes)(yParityAndS);\n          _bytes[0] &= 0x7f;\n          return (0, index_js_2.hexlify)(_bytes);\n        }\n        assertError(false, \"missing s\");\n      }(sig.s, sig.yParityAndS);\n      assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, \"non-canonical s\");\n      // Get v; by any means necessary (we check consistency below)\n      var _ref = function (_v, yParityAndS, yParity) {\n          if (_v != null) {\n            var _v5 = (0, index_js_2.getBigInt)(_v);\n            return {\n              networkV: _v5 >= BN_35 ? _v5 : undefined,\n              v: Signature.getNormalizedV(_v5)\n            };\n          }\n          if (yParityAndS != null) {\n            assertError((0, index_js_2.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n            return {\n              v: (0, index_js_2.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n            };\n          }\n          if (yParity != null) {\n            switch (yParity) {\n              case 0:\n                return {\n                  v: 27\n                };\n              case 1:\n                return {\n                  v: 28\n                };\n            }\n            assertError(false, \"invalid yParity\");\n          }\n          assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity),\n        networkV = _ref.networkV,\n        v = _ref.v;\n      var result = new Signature(_guard, r, s, v);\n      if (networkV) {\n        _classPrivateFieldSet(result, _networkV, networkV);\n      }\n      // If multiple of v, yParity, yParityAndS we given, check they match\n      assertError(!(\"yParity\" in sig && sig.yParity !== result.yParity), \"yParity mismatch\");\n      assertError(!(\"yParityAndS\" in sig && sig.yParityAndS !== result.yParityAndS), \"yParityAndS mismatch\");\n      return result;\n    }\n  }]);\n  return Signature;\n}();\nexports.Signature = Signature;","map":{"version":3,"names":["index_js_1","require","index_js_2","BN_0","BigInt","BN_1","BN_2","BN_27","BN_28","BN_35","_guard","toUint256","value","zeroPadValue","toBeArray","_r2","WeakMap","_s","_v2","_networkV","_Symbol$for","Symbol","for","Signature","guard","r","s","v","_classCallCheck","_classPrivateFieldInitSpec","writable","assertPrivate","_classPrivateFieldSet","_createClass","key","get","_classPrivateFieldGet","set","assertArgument","dataLength","hexlify","_value","parseInt","substring","getNumber","networkV","getChainId","yParityAndS","getBytes","yParity","concat","clone","toJSON","_type","toString","bv","getBigInt","getChainIdV","chainId","getNormalizedV","from","sig","assertError","check","message","ZeroHash","bytes","length","slice","_r","isHexString","_ref","_v","undefined","result","exports"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/crypto/signature.ts"],"sourcesContent":["\nimport { ZeroHash } from \"../constants/index.js\";\nimport {\n    concat, dataLength, getBigInt, getBytes, getNumber, hexlify,\n    toBeArray, isHexString, zeroPadValue,\n    assertArgument, assertPrivate\n} from \"../utils/index.js\";\n\nimport type {\n    BigNumberish, BytesLike\n} from \"../utils/index.js\";\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\n\n\nconst _guard = { };\n\n// @TODO: Allow Uint8Array\n\n/**\n *  A SignatureLike\n *\n *  @_docloc: api/crypto:Signing\n */\nexport type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 | 1;\n    v?: BigNumberish;\n    yParityAndS?: string;\n};\n\nfunction toUint256(value: BigNumberish): string {\n    return zeroPadValue(toBeArray(value), 32);\n}\n\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r(): string { return this.#r; }\n    set r(value: BytesLike) {\n        assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = hexlify(value);\n    }\n\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s(): string { return this.#s; }\n    set s(_value: BytesLike) {\n        assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = hexlify(_value);\n        assertArgument(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v(): 27 | 28 { return this.#v; }\n    set v(value: BigNumberish) {\n        const v = getNumber(value, \"value\");\n        assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV(): null | bigint { return this.#networkV; }\n\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId(): null | bigint {\n        const v = this.networkV;\n        if (v == null) { return null; }\n        return Signature.getChainId(v);\n    }\n\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity(): 0 | 1 {\n        return (this.v === 27) ? 0: 1;\n    }\n\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS(): string {\n        // The EIP-2098 compact representation\n        const yParityAndS = getBytes(this.s);\n        if (this.yParity) { yParityAndS[0] |= 0x80; }\n        return hexlify(yParityAndS);\n    }\n\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized(): string {\n        return concat([ this.r, this.yParityAndS ]);\n    }\n\n    /**\n     *  The serialized representation.\n     */\n    get serialized(): string {\n        return concat([ this.r, this.s, (this.yParity ? \"0x1c\": \"0x1b\") ]);\n    }\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, r: string, s: string, v: 27 | 28) {\n        assertPrivate(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n\n    [Symbol.for('nodejs.util.inspect.custom')](): string {\n        return `Signature { r: \"${ this.r }\", s: \"${ this.s }\", yParity: ${ this.yParity }, networkV: ${ this.networkV } }`;\n    }\n\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone(): Signature {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) { clone.#networkV = this.networkV; }\n        return clone;\n    }\n\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON(): any {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString(): null),\n            r: this.r, s: this.s, v: this.v,\n        };\n    }\n\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v: BigNumberish): bigint {\n        const bv = getBigInt(v, \"v\");\n\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) { return BN_0; }\n\n        // Bad value for an EIP-155 v\n        assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n\n        return (bv - BN_35) / BN_2;\n    }\n\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId: BigNumberish, v: 27 | 28): bigint {\n        return (getBigInt(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v: BigNumberish): 27 | 28 {\n        const bv = getBigInt(v);\n\n        if (bv === BN_0 || bv === BN_27) { return 27; }\n        if (bv === BN_1 || bv === BN_28) { return 28; }\n\n        assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27: 28;\n    }\n\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig?: SignatureLike): Signature {\n        function assertError(check: unknown, message: string): asserts check {\n            assertArgument(check, message, \"signature\", sig);\n        };\n\n        if (sig == null) {\n            return new Signature(_guard, ZeroHash, ZeroHash, 27);\n        }\n\n        if (typeof(sig) === \"string\") {\n            const bytes = getBytes(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28: 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n\n            if (bytes.length === 65) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n\n            assertError(false, \"invalid raw signature length\");\n        }\n\n        if (sig instanceof Signature) { return sig.clone(); }\n\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function(s?: string, yParityAndS?: string) {\n            if (s != null) { return toUint256(s); }\n\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = getBytes(yParityAndS);\n                bytes[0] &= 0x7f;\n                return hexlify(bytes);\n            }\n\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        assertError((getBytes(s)[0] & 0x80) == 0, \"non-canonical s\");\n\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function(_v?: BigNumberish, yParityAndS?: string, yParity?: number): { networkV?: bigint, v: 27 | 28 } {\n            if (_v != null) {\n                const v = getBigInt(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v: undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: ((getBytes(yParityAndS)[0] & 0x80) ? 28: 27) };\n            }\n\n            if (yParity != null) {\n                switch (yParity) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) { result.#networkV =  networkV; }\n\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(!(\"yParity\" in sig && sig.yParity !== result.yParity), \"yParity mismatch\");\n        assertError(!(\"yParityAndS\" in sig && sig.yParityAndS !== result.yParityAndS), \"yParityAndS mismatch\");\n\n        return result;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}