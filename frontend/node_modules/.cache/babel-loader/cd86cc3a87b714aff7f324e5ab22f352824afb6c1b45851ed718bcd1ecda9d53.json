{"ast":null,"code":"\"use strict\";\n\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider\n */\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _get = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldSet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;\nvar abstract_provider_js_1 = require(\"./abstract-provider.js\");\nvar index_js_1 = require(\"../utils/index.js\");\nvar provider_jsonrpc_js_1 = require(\"./provider-jsonrpc.js\");\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filter = /*#__PURE__*/new WeakMap();\nvar _filterId = /*#__PURE__*/new WeakMap();\nvar _paused = /*#__PURE__*/new WeakMap();\nvar _emitPromise = /*#__PURE__*/new WeakMap();\nvar SocketSubscriber = /*#__PURE__*/function () {\n  /**\n   *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n   *  to %%filter%%.\n   */\n  function SocketSubscriber(provider, filter) {\n    _classCallCheck(this, SocketSubscriber);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filterId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _paused, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _emitPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider, provider);\n    _classPrivateFieldSet(this, _filter, JSON.stringify(filter));\n    _classPrivateFieldSet(this, _filterId, null);\n    _classPrivateFieldSet(this, _paused, null);\n    _classPrivateFieldSet(this, _emitPromise, null);\n  }\n  _createClass(SocketSubscriber, [{\n    key: \"filter\",\n    get:\n    /**\n     *  The filter.\n     */\n    function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _filter));\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n      _classPrivateFieldSet(this, _filterId, _classPrivateFieldGet(this, _provider).send(\"eth_subscribe\", this.filter).then(function (filterId) {\n        ;\n        _classPrivateFieldGet(_this, _provider)._register(filterId, _this);\n        return filterId;\n      }));\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this2 = this;\n      _classPrivateFieldGet(this, _filterId).then(function (filterId) {\n        _classPrivateFieldGet(_this2, _provider).send(\"eth_unsubscribe\", [filterId]);\n      });\n      _classPrivateFieldSet(this, _filterId, null);\n    }\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {\n      (0, index_js_1.assert)(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"pause(false)\"\n      });\n      _classPrivateFieldSet(this, _paused, !!dropWhilePaused);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      _classPrivateFieldSet(this, _paused, null);\n    }\n    /**\n     *  @_ignore:\n     */\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(message) {\n      var _this3 = this;\n      if (_classPrivateFieldGet(this, _filterId) == null) {\n        return;\n      }\n      if (_classPrivateFieldGet(this, _paused) === null) {\n        var emitPromise = _classPrivateFieldGet(this, _emitPromise);\n        if (emitPromise == null) {\n          emitPromise = this._emit(_classPrivateFieldGet(this, _provider), message);\n        } else {\n          emitPromise = emitPromise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return _this3._emit(_classPrivateFieldGet(_this3, _provider), message);\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          })));\n        }\n        _classPrivateFieldSet(this, _emitPromise, emitPromise.then(function () {\n          if (_classPrivateFieldGet(_this3, _emitPromise) === emitPromise) {\n            _classPrivateFieldSet(_this3, _emitPromise, null);\n          }\n        }));\n      }\n    }\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new Error(\"sub-classes must implemente this; _emit\");\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function _emit(_x, _x2) {\n        return _emit2.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketSubscriber;\n}();\nexports.SocketSubscriber = SocketSubscriber;\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nvar SocketBlockSubscriber = /*#__PURE__*/function (_SocketSubscriber) {\n  _inherits(SocketBlockSubscriber, _SocketSubscriber);\n  var _super = _createSuper(SocketBlockSubscriber);\n  /**\n   *  @_ignore:\n   */\n  function SocketBlockSubscriber(provider) {\n    _classCallCheck(this, SocketBlockSubscriber);\n    return _super.call(this, provider, [\"newHeads\"]);\n  }\n  _createClass(SocketBlockSubscriber, [{\n    key: \"_emit\",\n    value: function () {\n      var _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              provider.emit(\"block\", parseInt(message.number));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function _emit(_x3, _x4) {\n        return _emit3.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketBlockSubscriber;\n}(SocketSubscriber);\nexports.SocketBlockSubscriber = SocketBlockSubscriber;\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nvar SocketPendingSubscriber = /*#__PURE__*/function (_SocketSubscriber2) {\n  _inherits(SocketPendingSubscriber, _SocketSubscriber2);\n  var _super2 = _createSuper(SocketPendingSubscriber);\n  /**\n   *  @_ignore:\n   */\n  function SocketPendingSubscriber(provider) {\n    _classCallCheck(this, SocketPendingSubscriber);\n    return _super2.call(this, provider, [\"newPendingTransactions\"]);\n  }\n  _createClass(SocketPendingSubscriber, [{\n    key: \"_emit\",\n    value: function () {\n      var _emit4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              provider.emit(\"pending\", message);\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function _emit(_x5, _x6) {\n        return _emit4.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketPendingSubscriber;\n}(SocketSubscriber);\nexports.SocketPendingSubscriber = SocketPendingSubscriber;\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nvar _logFilter = /*#__PURE__*/new WeakMap();\nvar SocketEventSubscriber = /*#__PURE__*/function (_SocketSubscriber3) {\n  _inherits(SocketEventSubscriber, _SocketSubscriber3);\n  var _super3 = _createSuper(SocketEventSubscriber);\n  /**\n   *  @_ignore:\n   */\n  function SocketEventSubscriber(provider, filter) {\n    var _this4;\n    _classCallCheck(this, SocketEventSubscriber);\n    _this4 = _super3.call(this, provider, [\"logs\", filter]);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _logFilter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _logFilter, JSON.stringify(filter));\n    return _this4;\n  }\n  _createClass(SocketEventSubscriber, [{\n    key: \"logFilter\",\n    get:\n    /**\n     *  The filter.\n     */\n    function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _logFilter));\n    }\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _emit(_x7, _x8) {\n        return _emit5.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketEventSubscriber;\n}(SocketSubscriber);\nexports.SocketEventSubscriber = SocketEventSubscriber;\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nvar _callbacks = /*#__PURE__*/new WeakMap();\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _pending = /*#__PURE__*/new WeakMap();\nvar SocketProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {\n  _inherits(SocketProvider, _provider_jsonrpc_js_);\n  var _super4 = _createSuper(SocketProvider);\n  /**\n   *  Creates a new **SocketProvider** connected to %%network%%.\n   *\n   *  If unspecified, the network will be discovered.\n   */\n  function SocketProvider(network) {\n    var _this5;\n    _classCallCheck(this, SocketProvider);\n    _this5 = _super4.call(this, network, {\n      batchMaxCount: 1\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _callbacks, {\n      writable: true,\n      value: void 0\n    });\n    // Maps each filterId to its subscriber\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _subs, {\n      writable: true,\n      value: void 0\n    });\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _pending, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _callbacks, new Map());\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _subs, new Map());\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _pending, new Map());\n    return _this5;\n  }\n  // This value is only valid after _start has been called\n  /*\n  get _network(): Network {\n      if (this.#network == null) {\n          throw new Error(\"this shouldn't happen\");\n      }\n      return this.#network.clone();\n  }\n  */\n  _createClass(SocketProvider, [{\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      switch (sub.type) {\n        case \"close\":\n          return new abstract_provider_js_1.UnmanagedSubscriber(\"close\");\n        case \"block\":\n          return new SocketBlockSubscriber(this);\n        case \"pending\":\n          return new SocketPendingSubscriber(this);\n        case \"event\":\n          return new SocketEventSubscriber(this, sub.filter);\n        case \"orphan\":\n          // Handled auto-matically within AbstractProvider\n          // when the log.removed = true\n          if (sub.filter.orphan === \"drop-log\") {\n            return new abstract_provider_js_1.UnmanagedSubscriber(\"drop-log\");\n          }\n      }\n      return _get(_getPrototypeOf(SocketProvider.prototype), \"_getSubscriber\", this).call(this, sub);\n    }\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */\n  }, {\n    key: \"_register\",\n    value: function _register(filterId, subscriber) {\n      _classPrivateFieldGet(this, _subs).set(filterId, subscriber);\n      var pending = _classPrivateFieldGet(this, _pending).get(filterId);\n      if (pending) {\n        var _iterator = _createForOfIteratorHelper(pending),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var message = _step.value;\n            subscriber._handleMessage(message);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        _classPrivateFieldGet(this, _pending).delete(filterId);\n      }\n    }\n  }, {\n    key: \"_send\",\n    value: function () {\n      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(payload) {\n        var _this6 = this;\n        var promise;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              // WebSocket provider doesn't accept batches\n              (0, index_js_1.assertArgument)(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n              // @TODO: stringify payloads here and store to prevent mutations\n              // Prepare a promise to respond to\n              promise = new Promise(function (resolve, reject) {\n                _classPrivateFieldGet(_this6, _callbacks).set(payload.id, {\n                  payload: payload,\n                  resolve: resolve,\n                  reject: reject\n                });\n              }); // Wait until the socket is connected before writing to it\n              _context6.next = 4;\n              return this._waitUntilReady();\n            case 4:\n              _context6.next = 6;\n              return this._write(JSON.stringify(payload));\n            case 6:\n              _context6.next = 8;\n              return promise;\n            case 8:\n              _context6.t0 = _context6.sent;\n              return _context6.abrupt(\"return\", [_context6.t0]);\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function _send(_x9) {\n        return _send2.apply(this, arguments);\n      }\n      return _send;\n    }() // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n         for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n         this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n    /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */\n  }, {\n    key: \"_processMessage\",\n    value: function () {\n      var _processMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message) {\n        var result, callback, filterId, subscriber, pending;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              result = JSON.parse(message);\n              if (!(result && typeof result === \"object\" && \"id\" in result)) {\n                _context7.next = 10;\n                break;\n              }\n              callback = _classPrivateFieldGet(this, _callbacks).get(result.id);\n              if (!(callback == null)) {\n                _context7.next = 6;\n                break;\n              }\n              this.emit(\"error\", (0, index_js_1.makeError)(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNKNOWN_ID\",\n                result: result\n              }));\n              return _context7.abrupt(\"return\");\n            case 6:\n              _classPrivateFieldGet(this, _callbacks).delete(result.id);\n              callback.resolve(result);\n              _context7.next = 18;\n              break;\n            case 10:\n              if (!(result && result.method === \"eth_subscription\")) {\n                _context7.next = 16;\n                break;\n              }\n              filterId = result.params.subscription;\n              subscriber = _classPrivateFieldGet(this, _subs).get(filterId);\n              if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n              } else {\n                pending = _classPrivateFieldGet(this, _pending).get(filterId);\n                if (pending == null) {\n                  pending = [];\n                  _classPrivateFieldGet(this, _pending).set(filterId, pending);\n                }\n                pending.push(result.params.result);\n              }\n              _context7.next = 18;\n              break;\n            case 16:\n              this.emit(\"error\", (0, index_js_1.makeError)(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result: result\n              }));\n              return _context7.abrupt(\"return\");\n            case 18:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function _processMessage(_x10) {\n        return _processMessage2.apply(this, arguments);\n      }\n      return _processMessage;\n    }()\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */\n  }, {\n    key: \"_write\",\n    value: function () {\n      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              throw new Error(\"sub-classes must override this\");\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n      function _write(_x11) {\n        return _write2.apply(this, arguments);\n      }\n      return _write;\n    }()\n  }]);\n  return SocketProvider;\n}(provider_jsonrpc_js_1.JsonRpcApiProvider);\nexports.SocketProvider = SocketProvider;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_get","_getPrototypeOf","_assertThisInitialized","_inherits","_createSuper","_regeneratorRuntime","_asyncToGenerator","_classCallCheck","_createClass","_classPrivateFieldInitSpec","_classPrivateFieldSet","_classPrivateFieldGet","abstract_provider_js_1","index_js_1","provider_jsonrpc_js_1","_provider","WeakMap","_filter","_filterId","_paused","_emitPromise","SocketSubscriber","provider","filter","writable","value","JSON","stringify","key","get","parse","start","_this","send","then","filterId","_register","stop","_this2","pause","dropWhilePaused","assert","operation","resume","_handleMessage","message","_this3","emitPromise","_emit","mark","_callee","wrap","_callee$","_context","prev","next","_emit2","_callee2","_callee2$","_context2","Error","_x","_x2","apply","arguments","exports","SocketBlockSubscriber","_SocketSubscriber","_super","call","_emit3","_callee3","_callee3$","_context3","emit","parseInt","number","_x3","_x4","SocketPendingSubscriber","_SocketSubscriber2","_super2","_emit4","_callee4","_callee4$","_context4","_x5","_x6","_logFilter","SocketEventSubscriber","_SocketSubscriber3","_super3","_this4","_emit5","_callee5","_callee5$","_context5","logFilter","_wrapLog","_network","_x7","_x8","_callbacks","_subs","_pending","SocketProvider","_provider_jsonrpc_js_","_super4","network","_this5","batchMaxCount","Map","_getSubscriber","sub","type","UnmanagedSubscriber","orphan","prototype","subscriber","set","pending","_iterator","_step","s","n","done","err","e","f","delete","_send2","_callee6","payload","_this6","promise","_callee6$","_context6","assertArgument","Array","isArray","Promise","resolve","reject","id","_waitUntilReady","_write","t0","sent","abrupt","_send","_x9","_processMessage2","_callee7","result","callback","_callee7$","_context7","makeError","reasonCode","method","params","subscription","push","_processMessage","_x10","_write2","_callee8","_callee8$","_context8","_x11","JsonRpcApiProvider"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/providers/provider-socket.ts"],"sourcesContent":["/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider\n */\n\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument, makeError } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\nimport type { Subscriber, Subscription } from \"./abstract-provider.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcError, JsonRpcPayload, JsonRpcResult } from \"./provider-jsonrpc.js\";\nimport type { Networkish } from \"./network.js\";\n\n\ntype JsonRpcSubscription = {\n    method: string,\n    params: {\n        result: any,\n        subscription: string\n    }\n};\n\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nexport class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n\n    /**\n     *  The filter.\n     */\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPromise: null | Promise<void>;\n\n    /**\n     *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n     *  to %%filter%%.\n     */\n    constructor(provider: SocketProvider, filter: Array<any>) {\n        this.#provider = provider;\n        this.#filter = JSON.stringify(filter);\n        this.#filterId = null;\n        this.#paused = null;\n        this.#emitPromise = null;\n    }\n\n    start(): void {\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId) => {;\n            this.#provider._register(filterId, this);\n            return filterId;\n        });\n    }\n\n    stop(): void {\n        (<Promise<number>>(this.#filterId)).then((filterId) => {\n            this.#provider.send(\"eth_unsubscribe\", [ filterId ]);\n        });\n        this.#filterId = null;\n    }\n\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n    pause(dropWhilePaused?: boolean): void {\n        assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"pause(false)\" });\n        this.#paused = !!dropWhilePaused;\n    }\n\n    resume(): void {\n        this.#paused = null;\n    }\n\n    /**\n     *  @_ignore:\n     */\n    _handleMessage(message: any): void {\n        if (this.#filterId == null) { return; }\n        if (this.#paused === null) {\n            let emitPromise: null | Promise<void> = this.#emitPromise;\n            if (emitPromise == null) {\n                emitPromise = this._emit(this.#provider, message);\n            } else {\n                emitPromise = emitPromise.then(async () => {\n                    await this._emit(this.#provider, message);\n                });\n            }\n            this.#emitPromise = emitPromise.then(() => {\n                if (this.#emitPromise === emitPromise) {\n                    this.#emitPromise = null;\n                }\n            });\n        }\n    }\n\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        throw new Error(\"sub-classes must implemente this; _emit\");\n    }\n}\n\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nexport class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt(message.number));\n    }\n}\n\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nexport class SocketPendingSubscriber extends SocketSubscriber {\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"pending\", message);\n    }\n}\n\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nexport class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n\n    /**\n     *  The filter.\n     */\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider, filter: EventFilter) {\n        super(provider, [ \"logs\", filter ]);\n        this.#logFilter = JSON.stringify(filter);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n    }\n}\n\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nexport class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    #pending: Map<number | string, Array<any>>;\n\n    /**\n     *  Creates a new **SocketProvider** connected to %%network%%.\n     *\n     *  If unspecified, the network will be discovered.\n     */\n    constructor(network?: Networkish) {\n        super(network, { batchMaxCount: 1 });\n        this.#callbacks = new Map();\n        this.#subs = new Map();\n        this.#pending = new Map();\n    }\n\n    // This value is only valid after _start has been called\n    /*\n    get _network(): Network {\n        if (this.#network == null) {\n            throw new Error(\"this shouldn't happen\");\n        }\n        return this.#network.clone();\n    }\n    */\n\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"close\":\n                return new UnmanagedSubscriber(\"close\");\n            case \"block\":\n                return new SocketBlockSubscriber(this);\n            case \"pending\":\n                return new SocketPendingSubscriber(this);\n            case \"event\":\n                return new SocketEventSubscriber(this, sub.filter);\n            case \"orphan\":\n                // Handled auto-matically within AbstractProvider\n                // when the log.removed = true\n                if (sub.filter.orphan === \"drop-log\") {\n                    return new UnmanagedSubscriber(\"drop-log\");\n                }\n        }\n        return super._getSubscriber(sub);\n    }\n\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */\n    _register(filterId: number | string, subscriber: SocketSubscriber): void {\n        this.#subs.set(filterId, subscriber);\n        const pending = this.#pending.get(filterId);\n        if (pending) {\n            for (const message of pending) {\n                subscriber._handleMessage(message);\n            }\n            this.#pending.delete(filterId);\n        }\n    }\n\n    async _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>> {\n        // WebSocket provider doesn't accept batches\n        assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n\n        // @TODO: stringify payloads here and store to prevent mutations\n\n        // Prepare a promise to respond to\n        const promise = new Promise((resolve, reject) => {\n            this.#callbacks.set(payload.id, { payload, resolve, reject });\n        });\n\n        // Wait until the socket is connected before writing to it\n        await this._waitUntilReady();\n\n        // Write the request to the socket\n        await this._write(JSON.stringify(payload));\n\n        return <Array<JsonRpcResult | JsonRpcError>>[ await promise ];\n    }\n\n    // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n\n        for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n\n        this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n\n    /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */\n    async _processMessage(message: string): Promise<void> {\n        const result = <JsonRpcResult | JsonRpcError | JsonRpcSubscription>(JSON.parse(message));\n\n        if (result && typeof(result) === \"object\" && \"id\" in result) {\n            const callback = this.#callbacks.get(result.id);\n            if (callback == null) {\n                this.emit(\"error\", makeError(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                    reasonCode: \"UNKNOWN_ID\",\n                    result\n                }));\n                return;\n            }\n            this.#callbacks.delete(result.id);\n\n            callback.resolve(result);\n\n        } else if (result && result.method === \"eth_subscription\") {\n            const filterId = result.params.subscription;\n            const subscriber = this.#subs.get(filterId);\n            if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n            } else {\n                let pending = this.#pending.get(filterId);\n                if (pending == null) {\n                    pending = [ ];\n                    this.#pending.set(filterId, pending);\n                }\n                pending.push(result.params.result);\n            }\n\n        } else {\n            this.emit(\"error\", makeError(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result\n            }));\n            return;\n        }\n    }\n\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */\n    async _write(message: string): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}