{"ast":null,"code":"\"use strict\";\n\n// Cipher Feedback\nvar _classCallCheck = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CFB = void 0;\nvar mode_js_1 = require(\"./mode.js\");\nvar CFB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {\n  _inherits(CFB, _mode_js_1$ModeOfOper);\n  var _super = _createSuper(CFB);\n  function CFB(key, iv) {\n    var _this;\n    var segmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    _classCallCheck(this, CFB);\n    _this = _super.call(this, \"CFB\", key, CFB);\n    _CFB_instances.add(_assertThisInitialized(_this));\n    _CFB_iv.set(_assertThisInitialized(_this), void 0);\n    _CFB_shiftRegister.set(_assertThisInitialized(_this), void 0);\n    // This library currently only handles byte-aligned segmentSize\n    if (!Number.isInteger(segmentSize) || segmentSize % 8) {\n      throw new TypeError(\"invalid segmentSize\");\n    }\n    Object.defineProperties(_assertThisInitialized(_this), {\n      segmentSize: {\n        enumerable: true,\n        value: segmentSize\n      }\n    });\n    if (iv) {\n      if (iv.length % 16) {\n        throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n      }\n      __classPrivateFieldSet(_assertThisInitialized(_this), _CFB_iv, new Uint8Array(iv), \"f\");\n    } else {\n      __classPrivateFieldSet(_assertThisInitialized(_this), _CFB_iv, new Uint8Array(16), \"f\");\n    }\n    __classPrivateFieldSet(_assertThisInitialized(_this), _CFB_shiftRegister, _this.iv, \"f\");\n    return _this;\n  }\n  _createClass(CFB, [{\n    key: \"iv\",\n    get: function get() {\n      return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\"));\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(plaintext) {\n      if (8 * plaintext.length % this.segmentSize) {\n        throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n      }\n      var segmentSize = this.segmentSize / 8;\n      var ciphertext = new Uint8Array(plaintext);\n      for (var i = 0; i < ciphertext.length; i += segmentSize) {\n        var xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n        for (var j = 0; j < segmentSize; j++) {\n          ciphertext[i + j] ^= xorSegment[j];\n        }\n        __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n      }\n      return ciphertext;\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(ciphertext) {\n      if (8 * ciphertext.length % this.segmentSize) {\n        throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n      }\n      var segmentSize = this.segmentSize / 8;\n      var plaintext = new Uint8Array(ciphertext);\n      for (var i = 0; i < plaintext.length; i += segmentSize) {\n        var xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n        for (var j = 0; j < segmentSize; j++) {\n          plaintext[i + j] ^= xorSegment[j];\n        }\n        __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n      }\n      return plaintext;\n    }\n  }]);\n  return CFB;\n}(mode_js_1.ModeOfOperation);\nexports.CFB = CFB;\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n  var segmentSize = this.segmentSize / 8;\n  // Shift the register\n  __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n  __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n};","map":{"version":3,"names":["_classCallCheck","require","default","_createClass","_assertThisInitialized","_inherits","_createSuper","mode_js_1","CFB","_mode_js_1$ModeOfOper","_super","key","iv","_this","segmentSize","arguments","length","undefined","call","_CFB_iv","set","_CFB_shiftRegister","Number","isInteger","TypeError","Object","defineProperties","enumerable","value","__classPrivateFieldSet","Uint8Array","get","__classPrivateFieldGet","encrypt","plaintext","ciphertext","i","xorSegment","aes","j","_CFB_instances","_CFB_shift","subarray","decrypt","ModeOfOperation","exports","data"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/aes-js/src.ts/mode-cfb.ts"],"sourcesContent":["// Cipher Feedback\n\nimport { ModeOfOperation } from \"./mode.js\";\n\nexport class CFB extends ModeOfOperation {\n  #iv: Uint8Array;\n  #shiftRegister: Uint8Array;\n\n  readonly segmentSize!: number;\n\n  constructor(key: Uint8Array, iv?: Uint8Array, segmentSize: number = 8) {\n    super(\"CFB\", key, CFB);\n\n    // This library currently only handles byte-aligned segmentSize\n    if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {\n      throw new TypeError(\"invalid segmentSize\");\n    }\n\n    Object.defineProperties(this, {\n      segmentSize: { enumerable: true, value: segmentSize }\n    });\n\n    if (iv) {\n      if (iv.length % 16) {\n        throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n      }\n      this.#iv = new Uint8Array(iv);\n    } else {\n      this.#iv = new Uint8Array(16);\n    }\n\n    this.#shiftRegister = this.iv;\n  }\n\n  get iv(): Uint8Array { return new Uint8Array(this.#iv); }\n\n  #shift(data: Uint8Array): void {\n    const segmentSize = this.segmentSize / 8;\n\n    // Shift the register\n    this.#shiftRegister.set(this.#shiftRegister.subarray(segmentSize));\n    this.#shiftRegister.set(data.subarray(0, segmentSize), 16 - segmentSize);\n  }\n\n  encrypt(plaintext: Uint8Array): Uint8Array {\n    if (8 * plaintext.length % this.segmentSize) {\n      throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n    }\n\n    const segmentSize = this.segmentSize / 8;\n\n    const ciphertext = new Uint8Array(plaintext);\n\n    for (let i = 0; i < ciphertext.length; i += segmentSize) {\n      const xorSegment = this.aes.encrypt(this.#shiftRegister);\n      for (let j = 0; j < segmentSize; j++) {\n        ciphertext[i + j] ^= xorSegment[j];\n      }\n\n      this.#shift(ciphertext.subarray(i));\n    }\n\n    return ciphertext;\n  }\n\n  decrypt(ciphertext: Uint8Array): Uint8Array {\n    if (8 * ciphertext.length % this.segmentSize) {\n        throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n    }\n\n    const segmentSize = this.segmentSize / 8;\n\n    const plaintext = new Uint8Array(ciphertext);\n\n    for (let i = 0; i < plaintext.length; i += segmentSize) {\n      const xorSegment = this.aes.encrypt(this.#shiftRegister);\n      for (let j = 0; j < segmentSize; j++) {\n        plaintext[i + j] ^= xorSegment[j];\n      }\n\n      this.#shift(ciphertext.subarray(i));\n    }\n\n    return plaintext;\n  }\n}\n"],"mappings":";;AAAA;AAAA,IAAAA,eAAA,GAAAC,OAAA,oGAAAC,OAAA;AAAA,IAAAC,YAAA,GAAAF,OAAA,iGAAAC,OAAA;AAAA,IAAAE,sBAAA,GAAAH,OAAA,2GAAAC,OAAA;AAAA,IAAAG,SAAA,GAAAJ,OAAA,8FAAAC,OAAA;AAAA,IAAAI,YAAA,GAAAL,OAAA,iGAAAC,OAAA;;;;;;;;;;;;;;;;;AAEA,IAAAK,SAAA,GAAAN,OAAA;AAA4C,IAE/BO,GAAI,0BAAAC,qBAAA;EAAAJ,SAAA,CAAAG,GAAA,EAAAC,qBAAA;EAAA,IAAAC,MAAA,GAAAJ,YAAA,CAAAE,GAAA;EAMf,SAAAA,IAAYG,GAAe,EAAEC,EAAe,EAAyB;IAAA,IAAAC,KAAA;IAAA,IAAvBC,WAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAsB,CAAC;IAAAf,eAAA,OAAAQ,GAAA;IACnEK,KAAA,GAAAH,MAAA,CAAAQ,IAAA,OAAM,KAAK,EAAEP,GAAG,EAAEH,GAAG;;IANvBW,OAAA,CAAAC,GAAA,CAAAhB,sBAAA,CAAAS,KAAA;IACAQ,kBAAA,CAAAD,GAAA,CAAAhB,sBAAA,CAAAS,KAAA;IAOE;IACA,IAAI,CAACS,MAAM,CAACC,SAAS,CAACT,WAAW,CAAC,IAAKA,WAAW,GAAG,CAAE,EAAE;MACvD,MAAM,IAAIU,SAAS,CAAC,qBAAqB,CAAC;;IAG5CC,MAAM,CAACC,gBAAgB,CAAAtB,sBAAA,CAAAS,KAAA,GAAO;MAC5BC,WAAW,EAAE;QAAEa,UAAU,EAAE,IAAI;QAAEC,KAAK,EAAEd;MAAW;KACpD,CAAC;IAEF,IAAIF,EAAE,EAAE;MACN,IAAIA,EAAE,CAACI,MAAM,GAAG,EAAE,EAAE;QAClB,MAAM,IAAIQ,SAAS,CAAC,oCAAoC,CAAC;;MAE3DK,sBAAA,CAAAzB,sBAAA,CAAAS,KAAA,GAAIM,OAAA,EAAO,IAAIW,UAAU,CAAClB,EAAE,CAAC;KAC9B,MAAM;MACLiB,sBAAA,CAAAzB,sBAAA,CAAAS,KAAA,GAAIM,OAAA,EAAO,IAAIW,UAAU,CAAC,EAAE,CAAC;;IAG/BD,sBAAA,CAAAzB,sBAAA,CAAAS,KAAA,GAAIQ,kBAAA,EAAkBR,KAAA,CAAKD,EAAE;IAAC,OAAAC,KAAA;EAChC;EAACV,YAAA,CAAAK,GAAA;IAAAG,GAAA;IAAAoB,GAAA,EAED,SAAAA,IAAA,EAAM;MAAiB,OAAO,IAAID,UAAU,CAACE,sBAAA,KAAI,EAAAb,OAAA,MAAI,CAAC;IAAE;EAAC;IAAAR,GAAA;IAAAiB,KAAA,EAUzD,SAAAK,QAAQC,SAAqB;MAC3B,IAAI,CAAC,GAAGA,SAAS,CAAClB,MAAM,GAAG,IAAI,CAACF,WAAW,EAAE;QAC3C,MAAM,IAAIU,SAAS,CAAC,gEAAgE,CAAC;;MAGvF,IAAMV,WAAW,GAAG,IAAI,CAACA,WAAW,GAAG,CAAC;MAExC,IAAMqB,UAAU,GAAG,IAAIL,UAAU,CAACI,SAAS,CAAC;MAE5C,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,CAACnB,MAAM,EAAEoB,CAAC,IAAItB,WAAW,EAAE;QACvD,IAAMuB,UAAU,GAAG,IAAI,CAACC,GAAG,CAACL,OAAO,CAACD,sBAAA,KAAI,EAAAX,kBAAA,MAAe,CAAC;QACxD,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,WAAW,EAAEyB,CAAC,EAAE,EAAE;UACpCJ,UAAU,CAACC,CAAC,GAAGG,CAAC,CAAC,IAAIF,UAAU,CAACE,CAAC,CAAC;;QAGpCP,sBAAA,KAAI,EAAAQ,cAAA,OAAAC,UAAA,CAAO,CAAAvB,IAAA,CAAX,IAAI,EAAQiB,UAAU,CAACO,QAAQ,CAACN,CAAC,CAAC,CAAC;;MAGrC,OAAOD,UAAU;IACnB;EAAC;IAAAxB,GAAA;IAAAiB,KAAA,EAED,SAAAe,QAAQR,UAAsB;MAC5B,IAAI,CAAC,GAAGA,UAAU,CAACnB,MAAM,GAAG,IAAI,CAACF,WAAW,EAAE;QAC1C,MAAM,IAAIU,SAAS,CAAC,iEAAiE,CAAC;;MAG1F,IAAMV,WAAW,GAAG,IAAI,CAACA,WAAW,GAAG,CAAC;MAExC,IAAMoB,SAAS,GAAG,IAAIJ,UAAU,CAACK,UAAU,CAAC;MAE5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAAClB,MAAM,EAAEoB,CAAC,IAAItB,WAAW,EAAE;QACtD,IAAMuB,UAAU,GAAG,IAAI,CAACC,GAAG,CAACL,OAAO,CAACD,sBAAA,KAAI,EAAAX,kBAAA,MAAe,CAAC;QACxD,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,WAAW,EAAEyB,CAAC,EAAE,EAAE;UACpCL,SAAS,CAACE,CAAC,GAAGG,CAAC,CAAC,IAAIF,UAAU,CAACE,CAAC,CAAC;;QAGnCP,sBAAA,KAAI,EAAAQ,cAAA,OAAAC,UAAA,CAAO,CAAAvB,IAAA,CAAX,IAAI,EAAQiB,UAAU,CAACO,QAAQ,CAACN,CAAC,CAAC,CAAC;;MAGrC,OAAOF,SAAS;IAClB;EAAC;EAAA,OAAA1B,GAAA;AAAA,EAhFsBD,SAAA,CAAAqC,eAAe;AAAxCC,OAAA,CAAArC,GAAA,GAAAA,GAAA;8HAgCSsC,IAAgB;EACrB,IAAMhC,WAAW,GAAG,IAAI,CAACA,WAAW,GAAG,CAAC;EAExC;EACAkB,sBAAA,KAAI,EAAAX,kBAAA,MAAe,CAACD,GAAG,CAACY,sBAAA,KAAI,EAAAX,kBAAA,MAAe,CAACqB,QAAQ,CAAC5B,WAAW,CAAC,CAAC;EAClEkB,sBAAA,KAAI,EAAAX,kBAAA,MAAe,CAACD,GAAG,CAAC0B,IAAI,CAACJ,QAAQ,CAAC,CAAC,EAAE5B,WAAW,CAAC,EAAE,EAAE,GAAGA,WAAW,CAAC;AAC1E,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}