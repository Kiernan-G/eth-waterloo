{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nvar data_js_1 = require(\"./data.js\");\nvar errors_js_1 = require(\"./errors.js\");\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nvar maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n  var value = getUint(_value, \"value\");\n  var width = BigInt(getNumber(_width, \"width\"));\n  (0, errors_js_1.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n    operation: \"fromTwos\",\n    fault: \"overflow\",\n    value: _value\n  });\n  // Top bit set; treat as a negative value\n  if (value >> width - BN_1) {\n    var _mask = (BN_1 << width) - BN_1;\n    return -((~value & _mask) + BN_1);\n  }\n  return value;\n}\nexports.fromTwos = fromTwos;\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n  var value = getBigInt(_value, \"value\");\n  var width = BigInt(getNumber(_width, \"width\"));\n  var limit = BN_1 << width - BN_1;\n  if (value < BN_0) {\n    value = -value;\n    (0, errors_js_1.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n    var _mask2 = (BN_1 << width) - BN_1;\n    return (~value & _mask2) + BN_1;\n  } else {\n    (0, errors_js_1.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n  }\n  return value;\n}\nexports.toTwos = toTwos;\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n  var value = getUint(_value, \"value\");\n  var bits = BigInt(getNumber(_bits, \"bits\"));\n  return value & (BN_1 << bits) - BN_1;\n}\nexports.mask = mask;\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      return value;\n    case \"number\":\n      (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return BigInt(value);\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        if (value[0] === \"-\" && value[1] !== \"-\") {\n          return -BigInt(value.substring(1));\n        }\n        return BigInt(value);\n      } catch (e) {\n        (0, errors_js_1.assertArgument)(false, \"invalid BigNumberish string: \".concat(e.message), name || \"value\", value);\n      }\n  }\n  (0, errors_js_1.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\nexports.getBigInt = getBigInt;\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n  var result = getBigInt(value, name);\n  (0, errors_js_1.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n    fault: \"overflow\",\n    operation: \"getUint\",\n    value: value\n  });\n  return result;\n}\nexports.getUint = getUint;\nvar Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n  if (value instanceof Uint8Array) {\n    var result = \"0x0\";\n    var _iterator = _createForOfIteratorHelper(value),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        result += Nibbles[v >> 4];\n        result += Nibbles[v & 0x0f];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return BigInt(result);\n  }\n  return getBigInt(value);\n}\nexports.toBigInt = toBigInt;\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return Number(value);\n    case \"number\":\n      (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return value;\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        return getNumber(BigInt(value), name);\n      } catch (e) {\n        (0, errors_js_1.assertArgument)(false, \"invalid numeric string: \".concat(e.message), name || \"value\", value);\n      }\n  }\n  (0, errors_js_1.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\nexports.getNumber = getNumber;\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n  return getNumber(toBigInt(value));\n}\nexports.toNumber = toNumber;\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n  var value = getUint(_value, \"value\");\n  var result = value.toString(16);\n  if (_width == null) {\n    // Ensure the value is of even length\n    if (result.length % 2) {\n      result = \"0\" + result;\n    }\n  } else {\n    var width = getNumber(_width, \"width\");\n    (0, errors_js_1.assert)(width * 2 >= result.length, \"value exceeds width (\".concat(width, \" bits)\"), \"NUMERIC_FAULT\", {\n      operation: \"toBeHex\",\n      fault: \"overflow\",\n      value: _value\n    });\n    // Pad the value to the required width\n    while (result.length < width * 2) {\n      result = \"0\" + result;\n    }\n  }\n  return \"0x\" + result;\n}\nexports.toBeHex = toBeHex;\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n  var value = getUint(_value, \"value\");\n  if (value === BN_0) {\n    return new Uint8Array([]);\n  }\n  var hex = value.toString(16);\n  if (hex.length % 2) {\n    hex = \"0\" + hex;\n  }\n  var result = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < result.length; i++) {\n    var offset = i * 2;\n    result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n  }\n  return result;\n}\nexports.toBeArray = toBeArray;\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n  var result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n  while (result.startsWith(\"0\")) {\n    result = result.substring(1);\n  }\n  if (result === \"\") {\n    result = \"0\";\n  }\n  return \"0x\" + result;\n}\nexports.toQuantity = toQuantity;","map":{"version":3,"names":["data_js_1","require","errors_js_1","BN_0","BigInt","BN_1","maxValue","fromTwos","_value","_width","value","getUint","width","getNumber","assert","operation","fault","mask","exports","toTwos","getBigInt","limit","_bits","bits","name","assertArgument","Number","isInteger","Error","substring","e","concat","message","result","Nibbles","toBigInt","Uint8Array","_iterator","_createForOfIteratorHelper","_step","s","n","done","v","err","f","toNumber","toBeHex","toString","length","toBeArray","hex","i","offset","parseInt","toQuantity","hexlify","isBytesLike","startsWith"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/utils/maths.ts"],"sourcesContent":["/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n/**\n *  Any type that can be used where a numeric value is needed.\n */\nexport type Numeric = number | bigint;\n\n/**\n *  Any type that can be used where a big number is needed.\n */\nexport type BigNumberish = string | Numeric;\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n\n    return value;\n}\n\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    } else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n\n    return value;\n}\n\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch(e: any) {\n                assertArgument(false, `invalid BigNumberish string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\n\nconst Nibbles = \"0123456789abcdef\";\n\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n    return getBigInt(value);\n}\n\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                return getNumber(BigInt(value), name);\n            } catch(e: any) {\n                assertArgument(false, `invalid numeric string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n\n\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}\n\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${ width } bits)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n\n        // Pad the value to the required width\n        while (result.length < (width * 2)) { result = \"0\" + result; }\n\n    }\n\n    return \"0x\" + result;\n}\n\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n\n    return result;\n}\n\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}