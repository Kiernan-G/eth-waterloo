{"ast":null,"code":"\"use strict\";\n\n/**\n *  @_ignore\n */\nvar _createForOfIteratorHelper = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;\nvar index_js_1 = require(\"../utils/index.js\");\nfunction looseArrayify(hexString) {\n  if (typeof hexString === \"string\" && !hexString.startsWith(\"0x\")) {\n    hexString = \"0x\" + hexString;\n  }\n  return (0, index_js_1.getBytesCopy)(hexString);\n}\nexports.looseArrayify = looseArrayify;\nfunction zpad(value, length) {\n  value = String(value);\n  while (value.length < length) {\n    value = '0' + value;\n  }\n  return value;\n}\nexports.zpad = zpad;\nfunction getPassword(password) {\n  if (typeof password === 'string') {\n    return (0, index_js_1.toUtf8Bytes)(password, \"NFKC\");\n  }\n  return (0, index_js_1.getBytesCopy)(password);\n}\nexports.getPassword = getPassword;\nfunction spelunk(object, _path) {\n  var match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n  (0, index_js_1.assertArgument)(match != null, \"invalid path\", \"path\", _path);\n  var path = match[1];\n  var type = match[3];\n  var reqd = match[4] === \"!\";\n  var cur = object;\n  var _iterator = _createForOfIteratorHelper(path.toLowerCase().split('.')),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var comp = _step.value;\n      // Search for a child object with a case-insensitive matching key\n      if (Array.isArray(cur)) {\n        if (!comp.match(/^[0-9]+$/)) {\n          break;\n        }\n        cur = cur[parseInt(comp)];\n      } else if (typeof cur === \"object\") {\n        var found = null;\n        for (var key in cur) {\n          if (key.toLowerCase() === comp) {\n            found = cur[key];\n            break;\n          }\n        }\n        cur = found;\n      } else {\n        cur = null;\n      }\n      if (cur == null) {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  (0, index_js_1.assertArgument)(!reqd || cur != null, \"missing required value\", \"path\", path);\n  if (type && cur != null) {\n    if (type === \"int\") {\n      if (typeof cur === \"string\" && cur.match(/^-?[0-9]+$/)) {\n        return parseInt(cur);\n      } else if (Number.isSafeInteger(cur)) {\n        return cur;\n      }\n    }\n    if (type === \"number\") {\n      if (typeof cur === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n        return parseFloat(cur);\n      }\n    }\n    if (type === \"data\") {\n      if (typeof cur === \"string\") {\n        return looseArrayify(cur);\n      }\n    }\n    if (type === \"array\" && Array.isArray(cur)) {\n      return cur;\n    }\n    if (type === typeof cur) {\n      return cur;\n    }\n    (0, index_js_1.assertArgument)(false, \"wrong type found for \".concat(type, \" \"), \"path\", path);\n  }\n  return cur;\n}\nexports.spelunk = spelunk;\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","index_js_1","looseArrayify","hexString","startsWith","getBytesCopy","exports","zpad","value","length","String","getPassword","password","toUtf8Bytes","spelunk","object","_path","match","assertArgument","path","type","reqd","cur","_iterator","toLowerCase","split","_step","s","n","done","comp","Array","isArray","parseInt","found","key","err","e","f","Number","isSafeInteger","parseFloat","concat"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/wallet/utils.ts"],"sourcesContent":["/**\n *  @_ignore\n */\n\nimport {\n    getBytesCopy, assertArgument, toUtf8Bytes\n} from \"../utils/index.js\";\n\nexport function looseArrayify(hexString: string): Uint8Array {\n    if (typeof(hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return getBytesCopy(hexString);\n}\n\nexport function zpad(value: String | number, length: number): String {\n    value = String(value);\n    while (value.length < length) { value = '0' + value; }\n    return value;\n}\n\nexport function getPassword(password: string | Uint8Array): Uint8Array {\n    if (typeof(password) === 'string') {\n        return toUtf8Bytes(password, \"NFKC\");\n    }\n    return getBytesCopy(password);\n}\n\nexport function spelunk<T>(object: any, _path: string): T {\n\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    assertArgument(match != null, \"invalid path\", \"path\", _path);\n\n    const path = match[1];\n    const type = match[3];\n    const reqd = (match[4] === \"!\");\n\n    let cur = object;\n    for (const comp of path.toLowerCase().split('.')) {\n\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) { break; }\n            cur = cur[parseInt(comp)];\n\n        } else if (typeof(cur) === \"object\") {\n            let found: any = null;\n            for (const key in cur) {\n                 if (key.toLowerCase() === comp) {\n                     found = cur[key];\n                     break;\n                 }\n            }\n            cur = found;\n\n        } else {\n            cur = null;\n        }\n\n        if (cur == null) { break; }\n    }\n\n    assertArgument(!reqd || cur != null, \"missing required value\", \"path\", path);\n\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof(cur) === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return <T><unknown>parseInt(cur);\n            } else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n\n        if (type === \"number\") {\n            if (typeof(cur) === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return <T><unknown>parseFloat(cur);\n            }\n        }\n\n        if (type === \"data\") {\n            if (typeof(cur) === \"string\") { return <T><unknown>looseArrayify(cur); }\n        }\n\n        if (type === \"array\" && Array.isArray(cur)) { return <T><unknown>cur; }\n        if (type === typeof(cur)) { return cur; }\n\n        assertArgument(false, `wrong type found for ${ type } `, \"path\", path);\n    }\n\n    return cur;\n}\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}