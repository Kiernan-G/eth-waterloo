{"ast":null,"code":"\"use strict\";\n\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nvar _regeneratorRuntime = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aryanbindroo/eth-waterloo/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;\nvar aes_js_1 = require(\"aes-js\");\nvar index_js_1 = require(\"../address/index.js\");\nvar index_js_2 = require(\"../crypto/index.js\");\nvar index_js_3 = require(\"../transaction/index.js\");\nvar index_js_4 = require(\"../utils/index.js\");\nvar utils_js_1 = require(\"./utils.js\");\nvar _version_js_1 = require(\"../_version.js\");\nvar defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nfunction isKeystoreJson(json) {\n  try {\n    var data = JSON.parse(json);\n    var version = data.version != null ? parseInt(data.version) : 0;\n    if (version === 3) {\n      return true;\n    }\n  } catch (error) {}\n  return false;\n}\nexports.isKeystoreJson = isKeystoreJson;\nfunction decrypt(data, key, ciphertext) {\n  var cipher = (0, utils_js_1.spelunk)(data, \"crypto.cipher:string\");\n  if (cipher === \"aes-128-ctr\") {\n    var iv = (0, utils_js_1.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n    var aesCtr = new aes_js_1.CTR(key, iv);\n    return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));\n  }\n  (0, index_js_4.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"decrypt\"\n  });\n}\nfunction getAccount(data, _key) {\n  var key = (0, index_js_4.getBytes)(_key);\n  var ciphertext = (0, utils_js_1.spelunk)(data, \"crypto.ciphertext:data!\");\n  var computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);\n  (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n  var privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n  var address = (0, index_js_3.computeAddress)(privateKey);\n  if (data.address) {\n    var check = data.address.toLowerCase();\n    if (!check.startsWith(\"0x\")) {\n      check = \"0x\" + check;\n    }\n    (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n  }\n  var account = {\n    address: address,\n    privateKey: privateKey\n  };\n  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n  var version = (0, utils_js_1.spelunk)(data, \"x-ethers.version:string\");\n  if (version === \"0.1\") {\n    var mnemonicKey = key.slice(32, 64);\n    var mnemonicCiphertext = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n    var mnemonicIv = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n    var mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n    account.mnemonic = {\n      path: (0, utils_js_1.spelunk)(data, \"x-ethers.path:string\") || defaultPath,\n      locale: (0, utils_js_1.spelunk)(data, \"x-ethers.locale:string\") || \"en\",\n      entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n    };\n  }\n  return account;\n}\nfunction getDecryptKdfParams(data) {\n  var kdf = (0, utils_js_1.spelunk)(data, \"crypto.kdf:string\");\n  if (kdf && typeof kdf === \"string\") {\n    if (kdf.toLowerCase() === \"scrypt\") {\n      var salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n      var N = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.n:int!\");\n      var r = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.r:int!\");\n      var p = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.p:int!\");\n      // Make sure N is a power of 2\n      (0, index_js_4.assertArgument)(N > 0 && (N & N - 1) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n      (0, index_js_4.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n      var dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n      (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n      return {\n        name: \"scrypt\",\n        salt: salt,\n        N: N,\n        r: r,\n        p: p,\n        dkLen: 64\n      };\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      var _salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n      var prf = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n      var algorithm = prf.split(\"-\").pop();\n      (0, index_js_4.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n      var count = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.c:int!\");\n      var _dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n      (0, index_js_4.assertArgument)(_dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", _dkLen);\n      return {\n        name: \"pbkdf2\",\n        salt: _salt,\n        count: count,\n        dkLen: _dkLen,\n        algorithm: algorithm\n      };\n    }\n  }\n  (0, index_js_4.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nfunction decryptKeystoreJsonSync(json, _password) {\n  var data = JSON.parse(json);\n  var password = (0, utils_js_1.getPassword)(_password);\n  var params = getDecryptKdfParams(data);\n  if (params.name === \"pbkdf2\") {\n    var _salt2 = params.salt,\n      count = params.count,\n      _dkLen2 = params.dkLen,\n      algorithm = params.algorithm;\n    var _key2 = (0, index_js_2.pbkdf2)(password, _salt2, count, _dkLen2, algorithm);\n    return getAccount(data, _key2);\n  }\n  (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n    params: params\n  });\n  var salt = params.salt,\n    N = params.N,\n    r = params.r,\n    p = params.p,\n    dkLen = params.dkLen;\n  var key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);\n  return getAccount(data, key);\n}\nexports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;\nfunction stall(duration) {\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve();\n    }, duration);\n  });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nfunction decryptKeystoreJson(_x, _x2, _x3) {\n  return _decryptKeystoreJson.apply(this, arguments);\n}\nfunction _decryptKeystoreJson() {\n  _decryptKeystoreJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(json, _password, progress) {\n    var data, password, params, _salt3, count, _dkLen3, algorithm, _key3, salt, N, r, p, dkLen, key;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          data = JSON.parse(json);\n          password = (0, utils_js_1.getPassword)(_password);\n          params = getDecryptKdfParams(data);\n          if (!(params.name === \"pbkdf2\")) {\n            _context.next = 15;\n            break;\n          }\n          if (!progress) {\n            _context.next = 8;\n            break;\n          }\n          progress(0);\n          _context.next = 8;\n          return stall(0);\n        case 8:\n          _salt3 = params.salt, count = params.count, _dkLen3 = params.dkLen, algorithm = params.algorithm;\n          _key3 = (0, index_js_2.pbkdf2)(password, _salt3, count, _dkLen3, algorithm);\n          if (!progress) {\n            _context.next = 14;\n            break;\n          }\n          progress(1);\n          _context.next = 14;\n          return stall(0);\n        case 14:\n          return _context.abrupt(\"return\", getAccount(data, _key3));\n        case 15:\n          (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n            params: params\n          });\n          salt = params.salt, N = params.N, r = params.r, p = params.p, dkLen = params.dkLen;\n          _context.next = 19;\n          return (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);\n        case 19:\n          key = _context.sent;\n          return _context.abrupt(\"return\", getAccount(data, key));\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _decryptKeystoreJson.apply(this, arguments);\n}\nexports.decryptKeystoreJson = decryptKeystoreJson;\nfunction getEncryptKdfParams(options) {\n  // Check/generate the salt\n  var salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, \"options.salt\") : (0, index_js_2.randomBytes)(32);\n  // Override the scrypt password-based key derivation function parameters\n  var N = 1 << 17,\n    r = 8,\n    p = 1;\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  }\n  (0, index_js_4.assertArgument)(typeof N === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n  (0, index_js_4.assertArgument)(typeof r === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n  (0, index_js_4.assertArgument)(typeof p === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n  return {\n    name: \"scrypt\",\n    dkLen: 32,\n    salt: salt,\n    N: N,\n    r: r,\n    p: p\n  };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n  var privateKey = (0, index_js_4.getBytes)(account.privateKey, \"privateKey\");\n  // Override initialization vector\n  var iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, \"options.iv\") : (0, index_js_2.randomBytes)(16);\n  (0, index_js_4.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n  // Override the uuid\n  var uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, \"options.uuid\") : (0, index_js_2.randomBytes)(16);\n  (0, index_js_4.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n  // This will be used to encrypt the wallet (as per Web3 secret storage)\n  // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n  var derivedKey = key.slice(0, 16);\n  var macPrefix = key.slice(16, 32);\n  // Encrypt the private key\n  var aesCtr = new aes_js_1.CTR(derivedKey, iv);\n  var ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));\n  // Compute the message authentication code, used to check the password\n  var mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));\n  // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n  var data = {\n    address: account.address.substring(2).toLowerCase(),\n    id: (0, index_js_4.uuidV4)(uuidRandom),\n    version: 3,\n    Crypto: {\n      cipher: \"aes-128-ctr\",\n      cipherparams: {\n        iv: (0, index_js_4.hexlify)(iv).substring(2)\n      },\n      ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),\n      kdf: \"scrypt\",\n      kdfparams: {\n        salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),\n        n: kdf.N,\n        dklen: 32,\n        p: kdf.p,\n        r: kdf.r\n      },\n      mac: mac.substring(2)\n    }\n  };\n  // If we have a mnemonic, encrypt it into the JSON wallet\n  if (account.mnemonic) {\n    var client = options.client != null ? options.client : \"ethers/\".concat(_version_js_1.version);\n    var path = account.mnemonic.path || defaultPath;\n    var locale = account.mnemonic.locale || \"en\";\n    var mnemonicKey = key.slice(32, 64);\n    var entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n    var mnemonicIv = (0, index_js_2.randomBytes)(16);\n    var mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n    var mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));\n    var now = new Date();\n    var timestamp = now.getUTCFullYear() + \"-\" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + \"T\" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + \".0Z\";\n    var gethFilename = \"UTC--\" + timestamp + \"--\" + data.address;\n    data[\"x-ethers\"] = {\n      client: client,\n      gethFilename: gethFilename,\n      path: path,\n      locale: locale,\n      mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),\n      mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),\n      version: \"0.1\"\n    };\n  }\n  return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nfunction encryptKeystoreJsonSync(account, password, options) {\n  if (options == null) {\n    options = {};\n  }\n  var passwordBytes = (0, utils_js_1.getPassword)(password);\n  var kdf = getEncryptKdfParams(options);\n  var key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n  return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nfunction encryptKeystoreJson(_x4, _x5, _x6) {\n  return _encryptKeystoreJson.apply(this, arguments);\n}\nfunction _encryptKeystoreJson() {\n  _encryptKeystoreJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, password, options) {\n    var passwordBytes, kdf, key;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (options == null) {\n            options = {};\n          }\n          passwordBytes = (0, utils_js_1.getPassword)(password);\n          kdf = getEncryptKdfParams(options);\n          _context2.next = 5;\n          return (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n        case 5:\n          key = _context2.sent;\n          return _context2.abrupt(\"return\", _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options));\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _encryptKeystoreJson.apply(this, arguments);\n}\nexports.encryptKeystoreJson = encryptKeystoreJson;","map":{"version":3,"names":["_regeneratorRuntime","require","default","_asyncToGenerator","aes_js_1","index_js_1","index_js_2","index_js_3","index_js_4","utils_js_1","_version_js_1","defaultPath","isKeystoreJson","json","data","JSON","parse","version","parseInt","error","exports","decrypt","key","ciphertext","cipher","spelunk","iv","aesCtr","CTR","hexlify","assert","operation","getAccount","_key","getBytes","computedMAC","keccak256","concat","slice","substring","assertArgument","toLowerCase","privateKey","address","computeAddress","check","startsWith","getAddress","account","mnemonicKey","mnemonicCiphertext","mnemonicIv","mnemonicAesCtr","mnemonic","path","locale","entropy","getDecryptKdfParams","kdf","salt","N","r","p","dkLen","name","prf","algorithm","split","pop","count","decryptKeystoreJsonSync","_password","password","getPassword","params","pbkdf2","scryptSync","stall","duration","Promise","resolve","setTimeout","decryptKeystoreJson","_x","_x2","_x3","_decryptKeystoreJson","apply","arguments","mark","_callee","progress","_salt3","_dkLen3","_key3","wrap","_callee$","_context","prev","next","abrupt","scrypt","sent","stop","getEncryptKdfParams","options","randomBytes","Number","isSafeInteger","BigInt","_encryptKeystore","length","uuidRandom","uuid","derivedKey","macPrefix","encrypt","mac","id","uuidV4","Crypto","cipherparams","kdfparams","n","dklen","client","now","Date","timestamp","getUTCFullYear","zpad","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","mnemonicCounter","stringify","encryptKeystoreJsonSync","passwordBytes","encryptKeystoreJson","_x4","_x5","_x6","_encryptKeystoreJson","_callee2","_callee2$","_context2","progressCallback"],"sources":["/Users/aryanbindroo/eth-waterloo/frontend/node_modules/ethers/src.ts/wallet/json-keystore.ts"],"sourcesContent":["/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\n\nimport { CTR } from \"aes-js\";\n\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256, pbkdf2, randomBytes, scrypt, scryptSync } from \"../crypto/index.js\";\nimport { computeAddress } from \"../transaction/index.js\";\nimport {\n    concat, getBytes, hexlify, uuidV4, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport { getPassword, spelunk, zpad } from \"./utils.js\";\n\nimport type { ProgressCallback } from \"../crypto/index.js\";\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport { version } from \"../_version.js\";\n\n\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n\n/**\n *  The contents of a JSON Keystore Wallet.\n */\nexport type KeystoreAccount = {\n    address: string;\n    privateKey: string;\n    mnemonic?: {\n        path?: string;\n        locale?: string;\n        entropy: string;\n    }\n};\n\n/**\n *  The parameters to use when encrypting a JSON Keystore Wallet.\n */\nexport type EncryptOptions = {\n   progressCallback?: ProgressCallback;\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nexport function isKeystoreJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version): 0);\n        if (version === 3) { return true; }\n    } catch (error) { }\n    return false;\n}\n\nfunction decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): string {\n    const cipher = spelunk<string>(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = spelunk<Uint8Array>(data, \"crypto.cipherparams.iv:data!\")\n        const aesCtr = new CTR(key, iv);\n        return hexlify(aesCtr.decrypt(ciphertext));\n    }\n\n    assert(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\n\nfunction getAccount(data: any, _key: string): KeystoreAccount {\n    const key = getBytes(_key);\n    const ciphertext = spelunk<Uint8Array>(data, \"crypto.ciphertext:data!\");\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    assertArgument(computedMAC === spelunk<string>(data, \"crypto.mac:string!\").toLowerCase(),\n        \"incorrect password\", \"password\", \"[ REDACTED ]\");\n\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) { check = \"0x\" + check; }\n\n        assertArgument(getAddress(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n\n    const account: KeystoreAccount = { address, privateKey };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = spelunk(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n\n        const mnemonicCiphertext = spelunk<Uint8Array>(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = spelunk<Uint8Array>(data, \"x-ethers.mnemonicCounter:data!\");\n\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);\n\n        account.mnemonic = {\n            path: (spelunk<null | string>(data, \"x-ethers.path:string\") || defaultPath),\n            locale: (spelunk<null | string>(data, \"x-ethers.locale:string\") || \"en\"),\n            entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n\n    return account;\n}\n\ntype ScryptParams = {\n    name: \"scrypt\";\n    salt: Uint8Array;\n    N: number;\n    r: number;\n    p: number;\n    dkLen: number;\n};\n\ntype KdfParams = ScryptParams | {\n    name: \"pbkdf2\";\n    salt: Uint8Array;\n    count: number;\n    dkLen: number;\n    algorithm: \"sha256\" | \"sha512\";\n};\n\nfunction getDecryptKdfParams<T>(data: any): KdfParams {\n    const kdf = spelunk(data, \"crypto.kdf:string\");\n    if (kdf && typeof(kdf) === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = spelunk<Uint8Array>(data, \"crypto.kdfparams.salt:data!\");\n            const N = spelunk<number>(data, \"crypto.kdfparams.n:int!\");\n            const r = spelunk<number>(data, \"crypto.kdfparams.r:int!\");\n            const p = spelunk<number>(data, \"crypto.kdfparams.p:int!\");\n\n            // Make sure N is a power of 2\n            assertArgument(N > 0 && (N & (N - 1)) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            assertArgument(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n\n            const dkLen = spelunk<number>(data, \"crypto.kdfparams.dklen:int!\");\n            assertArgument(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n\n            return { name: \"scrypt\", salt, N, r, p, dkLen: 64 };\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = spelunk<Uint8Array>(data, \"crypto.kdfparams.salt:data!\");\n\n            const prf = spelunk<string>(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            assertArgument(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n\n            const count = spelunk<number>(data, \"crypto.kdfparams.c:int!\");\n\n            const dkLen = spelunk<number>(data, \"crypto.kdfparams.dklen:int!\");\n            assertArgument(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n\n            return { name: \"pbkdf2\", salt, count, dkLen, algorithm };\n        }\n    }\n\n    assertArgument(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nexport function decryptKeystoreJsonSync(json: string, _password: string | Uint8Array): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = pbkdf2(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n\n    assert(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params })\n\n    const { salt, N, r, p, dkLen } = params;\n    const key = scryptSync(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nexport async function decryptKeystoreJson(json: string, _password: string | Uint8Array, progress?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = pbkdf2(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n\n    assert(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params })\n\n    const { salt, N, r, p, dkLen } = params;\n    const key = await scrypt(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\n\nfunction getEncryptKdfParams(options: EncryptOptions): ScryptParams {\n    // Check/generate the salt\n    const salt = (options.salt != null) ? getBytes(options.salt, \"options.salt\"): randomBytes(32);\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n    assertArgument(typeof(N) === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    assertArgument(typeof(r) === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    assertArgument(typeof(p) === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n\n    return { name: \"scrypt\", dkLen: 32, salt, N, r, p };\n}\n\nfunction _encryptKeystore(key: Uint8Array, kdf: ScryptParams, account: KeystoreAccount, options: EncryptOptions): any {\n\n    const privateKey = getBytes(account.privateKey, \"privateKey\");\n\n    // Override initialization vector\n    const iv = (options.iv != null) ? getBytes(options.iv, \"options.iv\"): randomBytes(16);\n    assertArgument(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n\n    // Override the uuid\n    const uuidRandom = (options.uuid != null) ? getBytes(options.uuid, \"options.uuid\"): randomBytes(16);\n    assertArgument(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n\n    // Encrypt the private key\n    const aesCtr = new CTR(derivedKey, iv);\n    const ciphertext = getBytes(aesCtr.encrypt(privateKey));\n\n    // Compute the message authentication code, used to check the password\n    const mac = keccak256(concat([ macPrefix, ciphertext ]))\n\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data: { [key: string]: any } = {\n        address: account.address.substring(2).toLowerCase(),\n        id: uuidV4(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: hexlify(iv).substring(2),\n            },\n            ciphertext: hexlify(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: hexlify(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = (options.client != null) ? options.client: `ethers/${ version }`;\n\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n\n        const mnemonicKey = key.slice(32, 64);\n\n        const entropy = getBytes(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = randomBytes(16);\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));\n\n        const now = new Date();\n        const timestamp = (now.getUTCFullYear() + \"-\" +\n                           zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                           zpad(now.getUTCDate(), 2) + \"T\" +\n                           zpad(now.getUTCHours(), 2) + \"-\" +\n                           zpad(now.getUTCMinutes(), 2) + \"-\" +\n                           zpad(now.getUTCSeconds(), 2) + \".0Z\");\n        const gethFilename = (\"UTC--\" + timestamp + \"--\" + data.address);\n\n        data[\"x-ethers\"] = {\n            client, gethFilename, path, locale,\n            mnemonicCounter: hexlify(mnemonicIv).substring(2),\n            mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n\n    return JSON.stringify(data);\n}\n\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nexport function encryptKeystoreJsonSync(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): string {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore(getBytes(key), kdf, account, options);\n}\n\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nexport async function encryptKeystoreJson(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): Promise<string> {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore(getBytes(key), kdf, account, options);\n}\n\n"],"mappings":";;AAAA;;;;;;;;;;AAAA,IAAAA,mBAAA,GAAAC,OAAA,wGAAAC,OAAA;AAAA,IAAAC,iBAAA,GAAAF,OAAA,sGAAAC,OAAA;;;;;AAWA,IAAAE,QAAA,GAAAH,OAAA;AAEA,IAAAI,UAAA,GAAAJ,OAAA;AACA,IAAAK,UAAA,GAAAL,OAAA;AACA,IAAAM,UAAA,GAAAN,OAAA;AACA,IAAAO,UAAA,GAAAP,OAAA;AAIA,IAAAQ,UAAA,GAAAR,OAAA;AAKA,IAAAS,aAAA,GAAAT,OAAA;AAGA,IAAMU,WAAW,GAAG,kBAAkB;AAgCtC;;;AAGA,SAAgBC,cAAcA,CAACC,IAAY;EACvC,IAAI;IACA,IAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;IAC7B,IAAMI,OAAO,GAAKH,IAAI,CAACG,OAAO,IAAI,IAAI,GAAIC,QAAQ,CAACJ,IAAI,CAACG,OAAO,CAAC,GAAE,CAAE;IACpE,IAAIA,OAAO,KAAK,CAAC,EAAE;MAAE,OAAO,IAAI;;GACnC,CAAC,OAAOE,KAAK,EAAE;EAChB,OAAO,KAAK;AAChB;AAPAC,OAAA,CAAAR,cAAA,GAAAA,cAAA;AASA,SAASS,OAAOA,CAACP,IAAS,EAAEQ,GAAe,EAAEC,UAAsB;EAC/D,IAAMC,MAAM,GAAG,IAAAf,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,sBAAsB,CAAC;EAC5D,IAAIU,MAAM,KAAK,aAAa,EAAE;IAC1B,IAAME,EAAE,GAAG,IAAAjB,UAAA,CAAAgB,OAAO,EAAaX,IAAI,EAAE,8BAA8B,CAAC;IACpE,IAAMa,MAAM,GAAG,IAAIvB,QAAA,CAAAwB,GAAG,CAACN,GAAG,EAAEI,EAAE,CAAC;IAC/B,OAAO,IAAAlB,UAAA,CAAAqB,OAAO,EAACF,MAAM,CAACN,OAAO,CAACE,UAAU,CAAC,CAAC;;EAG9C,IAAAf,UAAA,CAAAsB,MAAM,EAAC,KAAK,EAAE,oBAAoB,EAAE,uBAAuB,EAAE;IACzDC,SAAS,EAAE;GACd,CAAC;AACN;AAEA,SAASC,UAAUA,CAAClB,IAAS,EAAEmB,IAAY;EACvC,IAAMX,GAAG,GAAG,IAAAd,UAAA,CAAA0B,QAAQ,EAACD,IAAI,CAAC;EAC1B,IAAMV,UAAU,GAAG,IAAAd,UAAA,CAAAgB,OAAO,EAAaX,IAAI,EAAE,yBAAyB,CAAC;EAEvE,IAAMqB,WAAW,GAAG,IAAA3B,UAAA,CAAAqB,OAAO,EAAC,IAAAvB,UAAA,CAAA8B,SAAS,EAAC,IAAA5B,UAAA,CAAA6B,MAAM,EAAC,CAAEf,GAAG,CAACgB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,EAAEf,UAAU,CAAE,CAAC,CAAC,CAAC,CAACgB,SAAS,CAAC,CAAC,CAAC;EAC9F,IAAA/B,UAAA,CAAAgC,cAAc,EAACL,WAAW,KAAK,IAAA1B,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,oBAAoB,CAAC,CAAC2B,WAAW,EAAE,EACpF,oBAAoB,EAAE,UAAU,EAAE,cAAc,CAAC;EAErD,IAAMC,UAAU,GAAGrB,OAAO,CAACP,IAAI,EAAEQ,GAAG,CAACgB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAEf,UAAU,CAAC;EAE9D,IAAMoB,OAAO,GAAG,IAAApC,UAAA,CAAAqC,cAAc,EAACF,UAAU,CAAC;EAC1C,IAAI5B,IAAI,CAAC6B,OAAO,EAAE;IACd,IAAIE,KAAK,GAAG/B,IAAI,CAAC6B,OAAO,CAACF,WAAW,EAAE;IACtC,IAAI,CAACI,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MAAED,KAAK,GAAG,IAAI,GAAGA,KAAK;;IAEnD,IAAArC,UAAA,CAAAgC,cAAc,EAAC,IAAAnC,UAAA,CAAA0C,UAAU,EAACF,KAAK,CAAC,KAAKF,OAAO,EAAE,sCAAsC,EAAE,SAAS,EAAE7B,IAAI,CAAC6B,OAAO,CAAC;;EAGlH,IAAMK,OAAO,GAAoB;IAAEL,OAAO,EAAPA,OAAO;IAAED,UAAU,EAAVA;EAAU,CAAE;EAExD;EACA,IAAMzB,OAAO,GAAG,IAAAR,UAAA,CAAAgB,OAAO,EAACX,IAAI,EAAE,yBAAyB,CAAC;EACxD,IAAIG,OAAO,KAAK,KAAK,EAAE;IACnB,IAAMgC,WAAW,GAAG3B,GAAG,CAACgB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;IAErC,IAAMY,kBAAkB,GAAG,IAAAzC,UAAA,CAAAgB,OAAO,EAAaX,IAAI,EAAE,mCAAmC,CAAC;IACzF,IAAMqC,UAAU,GAAG,IAAA1C,UAAA,CAAAgB,OAAO,EAAaX,IAAI,EAAE,gCAAgC,CAAC;IAE9E,IAAMsC,cAAc,GAAG,IAAIhD,QAAA,CAAAwB,GAAG,CAACqB,WAAW,EAAEE,UAAU,CAAC;IAEvDH,OAAO,CAACK,QAAQ,GAAG;MACfC,IAAI,EAAG,IAAA7C,UAAA,CAAAgB,OAAO,EAAgBX,IAAI,EAAE,sBAAsB,CAAC,IAAIH,WAAY;MAC3E4C,MAAM,EAAG,IAAA9C,UAAA,CAAAgB,OAAO,EAAgBX,IAAI,EAAE,wBAAwB,CAAC,IAAI,IAAK;MACxE0C,OAAO,EAAE,IAAAhD,UAAA,CAAAqB,OAAO,EAAC,IAAArB,UAAA,CAAA0B,QAAQ,EAACkB,cAAc,CAAC/B,OAAO,CAAC6B,kBAAkB,CAAC,CAAC;KACxE;;EAGL,OAAOF,OAAO;AAClB;AAmBA,SAASS,mBAAmBA,CAAI3C,IAAS;EACrC,IAAM4C,GAAG,GAAG,IAAAjD,UAAA,CAAAgB,OAAO,EAACX,IAAI,EAAE,mBAAmB,CAAC;EAC9C,IAAI4C,GAAG,IAAI,OAAOA,GAAI,KAAK,QAAQ,EAAE;IACjC,IAAIA,GAAG,CAACjB,WAAW,EAAE,KAAK,QAAQ,EAAE;MAChC,IAAMkB,IAAI,GAAG,IAAAlD,UAAA,CAAAgB,OAAO,EAAaX,IAAI,EAAE,6BAA6B,CAAC;MACrE,IAAM8C,CAAC,GAAG,IAAAnD,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,yBAAyB,CAAC;MAC1D,IAAM+C,CAAC,GAAG,IAAApD,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,yBAAyB,CAAC;MAC1D,IAAMgD,CAAC,GAAG,IAAArD,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,yBAAyB,CAAC;MAE1D;MACA,IAAAN,UAAA,CAAAgC,cAAc,EAACoB,CAAC,GAAG,CAAC,IAAI,CAACA,CAAC,GAAIA,CAAC,GAAG,CAAE,MAAM,CAAC,EAAE,eAAe,EAAE,OAAO,EAAEA,CAAC,CAAC;MACzE,IAAApD,UAAA,CAAAgC,cAAc,EAACqB,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,EAAE,aAAa,EAAE,KAAK,EAAEJ,GAAG,CAAC;MAEzD,IAAMK,KAAK,GAAG,IAAAtD,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,6BAA6B,CAAC;MAClE,IAAAN,UAAA,CAAAgC,cAAc,EAACuB,KAAK,KAAK,EAAE,EAAE,mBAAmB,EAAE,WAAW,EAAEA,KAAK,CAAC;MAErE,OAAO;QAAEC,IAAI,EAAE,QAAQ;QAAEL,IAAI,EAAJA,IAAI;QAAEC,CAAC,EAADA,CAAC;QAAEC,CAAC,EAADA,CAAC;QAAEC,CAAC,EAADA,CAAC;QAAEC,KAAK,EAAE;MAAE,CAAE;KAEtD,MAAM,IAAIL,GAAG,CAACjB,WAAW,EAAE,KAAK,QAAQ,EAAE;MAEvC,IAAMkB,KAAI,GAAG,IAAAlD,UAAA,CAAAgB,OAAO,EAAaX,IAAI,EAAE,6BAA6B,CAAC;MAErE,IAAMmD,GAAG,GAAG,IAAAxD,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,8BAA8B,CAAC;MACjE,IAAMoD,SAAS,GAAGD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAE;MACtC,IAAA5D,UAAA,CAAAgC,cAAc,EAAC0B,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,QAAQ,EAAE,iBAAiB,EAAE,SAAS,EAAED,GAAG,CAAC;MAEnG,IAAMI,KAAK,GAAG,IAAA5D,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,yBAAyB,CAAC;MAE9D,IAAMiD,MAAK,GAAG,IAAAtD,UAAA,CAAAgB,OAAO,EAASX,IAAI,EAAE,6BAA6B,CAAC;MAClE,IAAAN,UAAA,CAAAgC,cAAc,EAACuB,MAAK,KAAK,EAAE,EAAE,mBAAmB,EAAE,WAAW,EAAEA,MAAK,CAAC;MAErE,OAAO;QAAEC,IAAI,EAAE,QAAQ;QAAEL,IAAI,EAAJA,KAAI;QAAEU,KAAK,EAALA,KAAK;QAAEN,KAAK,EAALA,MAAK;QAAEG,SAAS,EAATA;MAAS,CAAE;;;EAIhE,IAAA1D,UAAA,CAAAgC,cAAc,EAAC,KAAK,EAAE,qCAAqC,EAAE,KAAK,EAAEkB,GAAG,CAAC;AAC5E;AAGA;;;;;;;;;;;;AAYA,SAAgBY,uBAAuBA,CAACzD,IAAY,EAAE0D,SAA8B;EAChF,IAAMzD,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;EAE7B,IAAM2D,QAAQ,GAAG,IAAA/D,UAAA,CAAAgE,WAAW,EAACF,SAAS,CAAC;EAEvC,IAAMG,MAAM,GAAGjB,mBAAmB,CAAC3C,IAAI,CAAC;EACxC,IAAI4D,MAAM,CAACV,IAAI,KAAK,QAAQ,EAAE;IAC1B,IAAQL,MAAI,GAA8Be,MAAM,CAAxCf,IAAI;MAAEU,KAAK,GAAuBK,MAAM,CAAlCL,KAAK;MAAEN,OAAK,GAAgBW,MAAM,CAA3BX,KAAK;MAAEG,SAAS,GAAKQ,MAAM,CAApBR,SAAS;IACrC,IAAM5C,KAAG,GAAG,IAAAhB,UAAA,CAAAqE,MAAM,EAACH,QAAQ,EAAEb,MAAI,EAAEU,KAAK,EAAEN,OAAK,EAAEG,SAAS,CAAC;IAC3D,OAAOlC,UAAU,CAAClB,IAAI,EAAEQ,KAAG,CAAC;;EAGhC,IAAAd,UAAA,CAAAsB,MAAM,EAAC4C,MAAM,CAACV,IAAI,KAAK,QAAQ,EAAE,mBAAmB,EAAE,eAAe,EAAE;IAAEU,MAAM,EAANA;EAAM,CAAE,CAAC;EAElF,IAAQf,IAAI,GAAqBe,MAAM,CAA/Bf,IAAI;IAAEC,CAAC,GAAkBc,MAAM,CAAzBd,CAAC;IAAEC,CAAC,GAAea,MAAM,CAAtBb,CAAC;IAAEC,CAAC,GAAYY,MAAM,CAAnBZ,CAAC;IAAEC,KAAK,GAAKW,MAAM,CAAhBX,KAAK;EAC5B,IAAMzC,GAAG,GAAG,IAAAhB,UAAA,CAAAsE,UAAU,EAACJ,QAAQ,EAAEb,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC;EACtD,OAAO/B,UAAU,CAAClB,IAAI,EAAEQ,GAAG,CAAC;AAChC;AAjBAF,OAAA,CAAAkD,uBAAA,GAAAA,uBAAA;AAmBA,SAASO,KAAKA,CAACC,QAAgB;EAC3B,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAI;IAAGC,UAAU,CAAC,YAAK;MAAGD,OAAO,EAAE;IAAE,CAAC,EAAEF,QAAQ,CAAC;EAAE,CAAC,CAAC;AACpF;AAEA;;;;;;;;;;;AAAA,SAWsBI,mBAAmBA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,oBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,qBAAA;EAAAA,oBAAA,GAAAnF,iBAAA,eAAAH,mBAAA,GAAAyF,IAAA,CAAlC,SAAAC,QAAmC7E,IAAY,EAAE0D,SAA8B,EAAEoB,QAA2B;IAAA,IAAA7E,IAAA,EAAA0D,QAAA,EAAAE,MAAA,EAAAkB,MAAA,EAAAvB,KAAA,EAAAwB,OAAA,EAAA3B,SAAA,EAAA4B,KAAA,EAAAnC,IAAA,EAAAC,CAAA,EAAAC,CAAA,EAAAC,CAAA,EAAAC,KAAA,EAAAzC,GAAA;IAAA,OAAAtB,mBAAA,GAAA+F,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UACzGrF,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;UAEvB2D,QAAQ,GAAG,IAAA/D,UAAA,CAAAgE,WAAW,EAACF,SAAS,CAAC;UAEjCG,MAAM,GAAGjB,mBAAmB,CAAC3C,IAAI,CAAC;UAAA,MACpC4D,MAAM,CAACV,IAAI,KAAK,QAAQ;YAAAiC,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,KACpBR,QAAQ;YAAAM,QAAA,CAAAE,IAAA;YAAA;UAAA;UACRR,QAAQ,CAAC,CAAC,CAAC;UAACM,QAAA,CAAAE,IAAA;UAAA,OACNtB,KAAK,CAAC,CAAC,CAAC;QAAA;UAEVlB,MAAI,GAA8Be,MAAM,CAAxCf,IAAI,EAAEU,KAAK,GAAuBK,MAAM,CAAlCL,KAAK,EAAEN,OAAK,GAAgBW,MAAM,CAA3BX,KAAK,EAAEG,SAAS,GAAKQ,MAAM,CAApBR,SAAS;UAC/B5C,KAAG,GAAG,IAAAhB,UAAA,CAAAqE,MAAM,EAACH,QAAQ,EAAEb,MAAI,EAAEU,KAAK,EAAEN,OAAK,EAAEG,SAAS,CAAC;UAAA,KACvDyB,QAAQ;YAAAM,QAAA,CAAAE,IAAA;YAAA;UAAA;UACRR,QAAQ,CAAC,CAAC,CAAC;UAACM,QAAA,CAAAE,IAAA;UAAA,OACNtB,KAAK,CAAC,CAAC,CAAC;QAAA;UAAA,OAAAoB,QAAA,CAAAG,MAAA,WAEXpE,UAAU,CAAClB,IAAI,EAAEQ,KAAG,CAAC;QAAA;UAGhC,IAAAd,UAAA,CAAAsB,MAAM,EAAC4C,MAAM,CAACV,IAAI,KAAK,QAAQ,EAAE,mBAAmB,EAAE,eAAe,EAAE;YAAEU,MAAM,EAANA;UAAM,CAAE,CAAC;UAE1Ef,IAAI,GAAqBe,MAAM,CAA/Bf,IAAI,EAAEC,CAAC,GAAkBc,MAAM,CAAzBd,CAAC,EAAEC,CAAC,GAAea,MAAM,CAAtBb,CAAC,EAAEC,CAAC,GAAYY,MAAM,CAAnBZ,CAAC,EAAEC,KAAK,GAAKW,MAAM,CAAhBX,KAAK;UAAAkC,QAAA,CAAAE,IAAA;UAAA,OACV,IAAA7F,UAAA,CAAA+F,MAAM,EAAC7B,QAAQ,EAAEb,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAE4B,QAAQ,CAAC;QAAA;UAA5DrE,GAAG,GAAA2E,QAAA,CAAAK,IAAA;UAAA,OAAAL,QAAA,CAAAG,MAAA,WACFpE,UAAU,CAAClB,IAAI,EAAEQ,GAAG,CAAC;QAAA;QAAA;UAAA,OAAA2E,QAAA,CAAAM,IAAA;MAAA;IAAA,GAAAb,OAAA;EAAA,CAC/B;EAAA,OAAAJ,oBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAzBDpE,OAAA,CAAA8D,mBAAA,GAAAA,mBAAA;AA2BA,SAASsB,mBAAmBA,CAACC,OAAuB;EAChD;EACA,IAAM9C,IAAI,GAAI8C,OAAO,CAAC9C,IAAI,IAAI,IAAI,GAAI,IAAAnD,UAAA,CAAA0B,QAAQ,EAACuE,OAAO,CAAC9C,IAAI,EAAE,cAAc,CAAC,GAAE,IAAArD,UAAA,CAAAoG,WAAW,EAAC,EAAE,CAAC;EAE7F;EACA,IAAI9C,CAAC,GAAI,CAAC,IAAI,EAAG;IAAEC,CAAC,GAAG,CAAC;IAAEC,CAAC,GAAG,CAAC;EAC/B,IAAI2C,OAAO,CAACJ,MAAM,EAAE;IAChB,IAAII,OAAO,CAACJ,MAAM,CAACzC,CAAC,EAAE;MAAEA,CAAC,GAAG6C,OAAO,CAACJ,MAAM,CAACzC,CAAC;;IAC5C,IAAI6C,OAAO,CAACJ,MAAM,CAACxC,CAAC,EAAE;MAAEA,CAAC,GAAG4C,OAAO,CAACJ,MAAM,CAACxC,CAAC;;IAC5C,IAAI4C,OAAO,CAACJ,MAAM,CAACvC,CAAC,EAAE;MAAEA,CAAC,GAAG2C,OAAO,CAACJ,MAAM,CAACvC,CAAC;;;EAEhD,IAAAtD,UAAA,CAAAgC,cAAc,EAAC,OAAOoB,CAAE,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,IAAI+C,MAAM,CAACC,aAAa,CAAChD,CAAC,CAAC,IAAI,CAACiD,MAAM,CAACjD,CAAC,CAAC,GAAGiD,MAAM,CAACjD,CAAC,GAAG,CAAC,CAAC,MAAMiD,MAAM,CAAC,CAAC,CAAC,EAAE,4BAA4B,EAAE,WAAW,EAAEjD,CAAC,CAAC;EACrK,IAAApD,UAAA,CAAAgC,cAAc,EAAC,OAAOqB,CAAE,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,IAAI8C,MAAM,CAACC,aAAa,CAAC/C,CAAC,CAAC,EAAE,4BAA4B,EAAE,WAAW,EAAEA,CAAC,CAAC;EACxH,IAAArD,UAAA,CAAAgC,cAAc,EAAC,OAAOsB,CAAE,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,IAAI6C,MAAM,CAACC,aAAa,CAAC9C,CAAC,CAAC,EAAE,4BAA4B,EAAE,WAAW,EAAEA,CAAC,CAAC;EAExH,OAAO;IAAEE,IAAI,EAAE,QAAQ;IAAED,KAAK,EAAE,EAAE;IAAEJ,IAAI,EAAJA,IAAI;IAAEC,CAAC,EAADA,CAAC;IAAEC,CAAC,EAADA,CAAC;IAAEC,CAAC,EAADA;EAAC,CAAE;AACvD;AAEA,SAASgD,gBAAgBA,CAACxF,GAAe,EAAEoC,GAAiB,EAAEV,OAAwB,EAAEyD,OAAuB;EAE3G,IAAM/D,UAAU,GAAG,IAAAlC,UAAA,CAAA0B,QAAQ,EAACc,OAAO,CAACN,UAAU,EAAE,YAAY,CAAC;EAE7D;EACA,IAAMhB,EAAE,GAAI+E,OAAO,CAAC/E,EAAE,IAAI,IAAI,GAAI,IAAAlB,UAAA,CAAA0B,QAAQ,EAACuE,OAAO,CAAC/E,EAAE,EAAE,YAAY,CAAC,GAAE,IAAApB,UAAA,CAAAoG,WAAW,EAAC,EAAE,CAAC;EACrF,IAAAlG,UAAA,CAAAgC,cAAc,EAACd,EAAE,CAACqF,MAAM,KAAK,EAAE,EAAE,2BAA2B,EAAE,YAAY,EAAEN,OAAO,CAAC/E,EAAE,CAAC;EAEvF;EACA,IAAMsF,UAAU,GAAIP,OAAO,CAACQ,IAAI,IAAI,IAAI,GAAI,IAAAzG,UAAA,CAAA0B,QAAQ,EAACuE,OAAO,CAACQ,IAAI,EAAE,cAAc,CAAC,GAAE,IAAA3G,UAAA,CAAAoG,WAAW,EAAC,EAAE,CAAC;EACnG,IAAAlG,UAAA,CAAAgC,cAAc,EAACwE,UAAU,CAACD,MAAM,KAAK,EAAE,EAAE,6BAA6B,EAAE,cAAc,EAAEN,OAAO,CAAC/E,EAAE,CAAC;EAEnG;EACA;EACA;EACA,IAAMwF,UAAU,GAAG5F,GAAG,CAACgB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACnC,IAAM6E,SAAS,GAAG7F,GAAG,CAACgB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EAEnC;EACA,IAAMX,MAAM,GAAG,IAAIvB,QAAA,CAAAwB,GAAG,CAACsF,UAAU,EAAExF,EAAE,CAAC;EACtC,IAAMH,UAAU,GAAG,IAAAf,UAAA,CAAA0B,QAAQ,EAACP,MAAM,CAACyF,OAAO,CAAC1E,UAAU,CAAC,CAAC;EAEvD;EACA,IAAM2E,GAAG,GAAG,IAAA/G,UAAA,CAAA8B,SAAS,EAAC,IAAA5B,UAAA,CAAA6B,MAAM,EAAC,CAAE8E,SAAS,EAAE5F,UAAU,CAAE,CAAC,CAAC;EAExD;EACA,IAAMT,IAAI,GAA2B;IACjC6B,OAAO,EAAEK,OAAO,CAACL,OAAO,CAACJ,SAAS,CAAC,CAAC,CAAC,CAACE,WAAW,EAAE;IACnD6E,EAAE,EAAE,IAAA9G,UAAA,CAAA+G,MAAM,EAACP,UAAU,CAAC;IACtB/F,OAAO,EAAE,CAAC;IACVuG,MAAM,EAAE;MACJhG,MAAM,EAAE,aAAa;MACrBiG,YAAY,EAAE;QACV/F,EAAE,EAAE,IAAAlB,UAAA,CAAAqB,OAAO,EAACH,EAAE,CAAC,CAACa,SAAS,CAAC,CAAC;OAC9B;MACDhB,UAAU,EAAE,IAAAf,UAAA,CAAAqB,OAAO,EAACN,UAAU,CAAC,CAACgB,SAAS,CAAC,CAAC,CAAC;MAC5CmB,GAAG,EAAE,QAAQ;MACbgE,SAAS,EAAE;QACP/D,IAAI,EAAE,IAAAnD,UAAA,CAAAqB,OAAO,EAAC6B,GAAG,CAACC,IAAI,CAAC,CAACpB,SAAS,CAAC,CAAC,CAAC;QACpCoF,CAAC,EAAEjE,GAAG,CAACE,CAAC;QACRgE,KAAK,EAAE,EAAE;QACT9D,CAAC,EAAEJ,GAAG,CAACI,CAAC;QACRD,CAAC,EAAEH,GAAG,CAACG;OACV;MACDwD,GAAG,EAAEA,GAAG,CAAC9E,SAAS,CAAC,CAAC;;GAE3B;EAED;EACA,IAAIS,OAAO,CAACK,QAAQ,EAAE;IAClB,IAAMwE,MAAM,GAAIpB,OAAO,CAACoB,MAAM,IAAI,IAAI,GAAIpB,OAAO,CAACoB,MAAM,aAAAxF,MAAA,CAAa3B,aAAA,CAAAO,OAAQ,CAAE;IAE/E,IAAMqC,IAAI,GAAGN,OAAO,CAACK,QAAQ,CAACC,IAAI,IAAI3C,WAAW;IACjD,IAAM4C,MAAM,GAAGP,OAAO,CAACK,QAAQ,CAACE,MAAM,IAAI,IAAI;IAE9C,IAAMN,WAAW,GAAG3B,GAAG,CAACgB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;IAErC,IAAMkB,OAAO,GAAG,IAAAhD,UAAA,CAAA0B,QAAQ,EAACc,OAAO,CAACK,QAAQ,CAACG,OAAO,EAAE,0BAA0B,CAAC;IAC9E,IAAML,UAAU,GAAG,IAAA7C,UAAA,CAAAoG,WAAW,EAAC,EAAE,CAAC;IAClC,IAAMtD,cAAc,GAAG,IAAIhD,QAAA,CAAAwB,GAAG,CAACqB,WAAW,EAAEE,UAAU,CAAC;IACvD,IAAMD,kBAAkB,GAAG,IAAA1C,UAAA,CAAA0B,QAAQ,EAACkB,cAAc,CAACgE,OAAO,CAAC5D,OAAO,CAAC,CAAC;IAEpE,IAAMsE,GAAG,GAAG,IAAIC,IAAI,EAAE;IACtB,IAAMC,SAAS,GAAIF,GAAG,CAACG,cAAc,EAAE,GAAG,GAAG,GAC1B,IAAAxH,UAAA,CAAAyH,IAAI,EAACJ,GAAG,CAACK,WAAW,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,GACpC,IAAA1H,UAAA,CAAAyH,IAAI,EAACJ,GAAG,CAACM,UAAU,EAAE,EAAE,CAAC,CAAC,GAAG,GAAG,GAC/B,IAAA3H,UAAA,CAAAyH,IAAI,EAACJ,GAAG,CAACO,WAAW,EAAE,EAAE,CAAC,CAAC,GAAG,GAAG,GAChC,IAAA5H,UAAA,CAAAyH,IAAI,EAACJ,GAAG,CAACQ,aAAa,EAAE,EAAE,CAAC,CAAC,GAAG,GAAG,GAClC,IAAA7H,UAAA,CAAAyH,IAAI,EAACJ,GAAG,CAACS,aAAa,EAAE,EAAE,CAAC,CAAC,GAAG,KAAM;IACxD,IAAMC,YAAY,GAAI,OAAO,GAAGR,SAAS,GAAG,IAAI,GAAGlH,IAAI,CAAC6B,OAAQ;IAEhE7B,IAAI,CAAC,UAAU,CAAC,GAAG;MACf+G,MAAM,EAANA,MAAM;MAAEW,YAAY,EAAZA,YAAY;MAAElF,IAAI,EAAJA,IAAI;MAAEC,MAAM,EAANA,MAAM;MAClCkF,eAAe,EAAE,IAAAjI,UAAA,CAAAqB,OAAO,EAACsB,UAAU,CAAC,CAACZ,SAAS,CAAC,CAAC,CAAC;MACjDW,kBAAkB,EAAE,IAAA1C,UAAA,CAAAqB,OAAO,EAACqB,kBAAkB,CAAC,CAACX,SAAS,CAAC,CAAC,CAAC;MAC5DtB,OAAO,EAAE;KACZ;;EAGL,OAAOF,IAAI,CAAC2H,SAAS,CAAC5H,IAAI,CAAC;AAC/B;AAEA;;;;;;;;AAQA,SAAgB6H,uBAAuBA,CAAC3F,OAAwB,EAAEwB,QAA6B,EAAEiC,OAAwB;EACrH,IAAIA,OAAO,IAAI,IAAI,EAAE;IAAEA,OAAO,GAAG,EAAG;;EAEpC,IAAMmC,aAAa,GAAG,IAAAnI,UAAA,CAAAgE,WAAW,EAACD,QAAQ,CAAC;EAC3C,IAAMd,GAAG,GAAG8C,mBAAmB,CAACC,OAAO,CAAC;EACxC,IAAMnF,GAAG,GAAG,IAAAhB,UAAA,CAAAsE,UAAU,EAACgE,aAAa,EAAElF,GAAG,CAACC,IAAI,EAAED,GAAG,CAACE,CAAC,EAAEF,GAAG,CAACG,CAAC,EAAEH,GAAG,CAACI,CAAC,EAAE,EAAE,CAAC;EACxE,OAAOgD,gBAAgB,CAAC,IAAAtG,UAAA,CAAA0B,QAAQ,EAACZ,GAAG,CAAC,EAAEoC,GAAG,EAAEV,OAAO,EAAEyD,OAAO,CAAC;AACjE;AAPArF,OAAA,CAAAuH,uBAAA,GAAAA,uBAAA;AASA;;;;;;;;;AAAA,SASsBE,mBAAmBA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,oBAAA,CAAA1D,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAyD,qBAAA;EAAAA,oBAAA,GAAA9I,iBAAA,eAAAH,mBAAA,GAAAyF,IAAA,CAAlC,SAAAyD,SAAmClG,OAAwB,EAAEwB,QAA6B,EAAEiC,OAAwB;IAAA,IAAAmC,aAAA,EAAAlF,GAAA,EAAApC,GAAA;IAAA,OAAAtB,mBAAA,GAAA+F,IAAA,UAAAoD,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAlD,IAAA,GAAAkD,SAAA,CAAAjD,IAAA;QAAA;UACvH,IAAIM,OAAO,IAAI,IAAI,EAAE;YAAEA,OAAO,GAAG,EAAG;;UAE9BmC,aAAa,GAAG,IAAAnI,UAAA,CAAAgE,WAAW,EAACD,QAAQ,CAAC;UACrCd,GAAG,GAAG8C,mBAAmB,CAACC,OAAO,CAAC;UAAA2C,SAAA,CAAAjD,IAAA;UAAA,OACtB,IAAA7F,UAAA,CAAA+F,MAAM,EAACuC,aAAa,EAAElF,GAAG,CAACC,IAAI,EAAED,GAAG,CAACE,CAAC,EAAEF,GAAG,CAACG,CAAC,EAAEH,GAAG,CAACI,CAAC,EAAE,EAAE,EAAE2C,OAAO,CAAC4C,gBAAgB,CAAC;QAAA;UAA9F/H,GAAG,GAAA8H,SAAA,CAAA9C,IAAA;UAAA,OAAA8C,SAAA,CAAAhD,MAAA,WACFU,gBAAgB,CAAC,IAAAtG,UAAA,CAAA0B,QAAQ,EAACZ,GAAG,CAAC,EAAEoC,GAAG,EAAEV,OAAO,EAAEyD,OAAO,CAAC;QAAA;QAAA;UAAA,OAAA2C,SAAA,CAAA7C,IAAA;MAAA;IAAA,GAAA2C,QAAA;EAAA,CAChE;EAAA,OAAAD,oBAAA,CAAA1D,KAAA,OAAAC,SAAA;AAAA;AAPDpE,OAAA,CAAAyH,mBAAA,GAAAA,mBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}